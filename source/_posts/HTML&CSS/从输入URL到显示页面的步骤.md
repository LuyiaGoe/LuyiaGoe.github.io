---
title: 从输入URL到显示页面的步骤
date: 2020-08-11 12:21:12
layout: post
categories: HTML
tags: HTML
---


## 精简
1. 根据请求的`URL`交给`DNS`域名解析，找到真实`IP`，向服务器发起请求；
2. 服务器交给后台处理完成后返回数据，浏览器接受文件（`HTML、JS、CSS`、图像等）；
3. 浏览器对返还的资源进行解析，并建立相应的内部数据结构（如`HTML`的`DOM`）；
4. 载入解析到的资源文件，渲染页面

## 详细
1. 输入URL
2. 浏览器检查缓存
 + 若未缓存，发起新请求
 + 若有缓存，且新鲜，则直接使用缓存，跳到转码步骤
 + 若不新鲜，则携带缓存标识对服务器发起请求，根据服务器相应数据再生成页面
3. 浏览器解析URL获取协议、主机、端口、path
4. 组装一个HTTP请求报文
5. 浏览器获取主机IP地址，过程如下：
 + 浏览器缓存
 + 本级缓存
 + hosts文件
 + 路由器缓存
 + ISP DNS缓存
 + DNS递归查询
6. 打开一个socket与目标IP地址，开始TCP三次握手：
 + 客户端发送一个TCP的`SYN=1,Seq=X`的包到服务器端口
 + 服务器返回`SYN=1,ACK=X+1,Seq=Y`的响应包
 + 客户端发送`ACK=Y+1,Seq=Z`
7. TCP连接建立后发送HTTP请求
8. 服务器接受请求并解析，转到服务程序
9. 检查请求头是否携带缓存标识，有则验证是否新鲜，返回304等对应状态码
10. 处理程序读取完整请求并准备HTTP相应，可能需要查询数据库等操作
11. 服务器等响应报文通过TCP连接发送回浏览器
12. 浏览器接受HTTP响应，根据情况选择关闭TCP连接或保留重用，关闭则进行TCP四次挥手：
 + 主动方发送`Fin=1, Ack=Z, Seq=X`
 + 被动方发送`ACK=X+1, Seq=Z`
 + 被动方发送`Fin=1, ACK=X, Seq=Y`
 + 主动方发送`ACK=Y,Seq=X`
13. 浏览器检查响应码：是否为1XX，3XX，4XX，5XX，这些情况处理与2XX不同
14. 查看是否可缓存，可以则缓存
15. 对相应进行解码（如gzip压缩）
16. 根据资源类型决定如何处理（假设资源为HTML文档）
17. 解析HTML文档，构件DOM树，下载资源，构造CSSOM树，执行JS脚本，这些操作没有严格的先后顺序
18. 构件DOM树：
 + `Tokenizing`：根据**HTML规范**将字符流解析为标记
 + `Lexing`：**词法分析**将标记转换为对象并定义属性和规则
 + `DOM construction`：根据**HTML标记关系**将对象组成DOM树
19. 解析过程中遇到图片、样式表、js脚本，启动下载
20. 构件**CSSOM树：**
 + `Tokenizing`：将字符流转换为标记流
 + `Node`：根据标记创建节点
 + `CSSOM`：节点创建CSSOM树
21. **根据DOM树和CSSOM树构件渲染树：**
 + 从DOM树的根节点遍历所有可见节点，不可见节点包括：
  + `script、meta`这样本身不可见的标签
  + 被css隐藏的节点，如`display:none`
 + 对没一个可见节点，找到恰当的CSSOM规则并应用
 + 发布可视节点的内容个计算样式
22. JS解析如下：
 + 浏览器创建Document对象，并解析HTML，将解析到的元素和文本节点添加到文档中，此时**document.readystate为loading**
 + 遇到**同步的script**时，将它们添加到文档，文档暂停解析，转而进行下载并运行脚本。如此可以用document.write()可以吧文本插入到输入流中。**同步脚本经常简单定义函数和注册事件处理程序，他们可以遍历和操作script和他们之前的文档内容**
 + 遇到**async的script**时，开始下载脚本，并继续解析文档。脚本会在**下载完成后尽快执行**。**异步脚本禁止使用write，它们可以访问自己script和之前的文档元素**
 + 当文档完成解析，**document.readyState变成interactive**
 + 所有**defer的script**也会挂起下载而不阻塞解析，**在文档完全被解析和显示后，按照在文档中出现的顺序进行执行**，可以访问完整文档树，禁止使用write()
 + Document对象**触发DOMContentLoaded事件**
 + 此时文档完全解析，浏览器可能还在等待如图片的内容的加载，这些内容完成载入并且所有异步脚本完成载入和执行，**document.readyState变为complete，window触发load事件**
23. 显示页面（HTML解析过程中会逐步显示页面）
 + 从浏览器接受`URL`到开启网络请求线程（可以展开浏览器的机制及进程与线程间的关系）
 + 开启网络线程到发出一个完整的`HTTP`请求（设计到DNS查询，`TCP/IP`请求，五层因特网协议栈等）
 + 服务器接受到请求到对应后台接收到请求（可能设计到负载均衡，安全拦截以及后台内部的处理）
 + 后台和前台的`HTTP`交互（这部分包括报文组成、`cookie`等知识，静态资源的`cookie`优化，以及编码解码，如`gzip`压缩等）
 + 单独拎出来的缓存问题（包括缓存头部、ETag、catch-control等）
 + 浏览器接收到数据包后的解析流程（解析`HTML`-词法分析-生成DOM树、解析`CSS`生成css规则树、合并成`render`树，然后`layout`、`painting`渲染、复合图层的合成、`GPU`绘制、外链资源的处理、`loaded`和`DOMContentLoaded`等）
 + CSS的可视化格式模型（元素的渲染规则，如包含块、控制框、BFC、IFC等概念）
 + JS引擎解析过程（JS的解释阶段、预处理阶段、执行阶段生成执行上下文，VO，作用域链、回收机制等等）
 + 其他（如跨域、web安全、hybrid模式等等）