<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>仿网易云项目</title>
      <link href="2021/04/16/Vue/%E4%BB%BF%E7%BD%91%E6%98%93%E4%BA%91%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/"/>
      <url>2021/04/16/Vue/%E4%BB%BF%E7%BD%91%E6%98%93%E4%BA%91%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h2 id="项目介绍"><a href="#项目介绍" class="headerlink" title="项目介绍"></a>项目介绍</h2><p>本项目采用Vue全家桶，与ElementUI搭配搭建而成，展示链接：<a href="https://luyiagoe.gitee.io/imitating-netease-cloud" target="_blank" rel="noopener">仿网易云展示页</a><img src="https://LuyiaGoe.github.io/assets/posts/wangyi_project_index.png" alt=""><img src="https://LuyiaGoe.github.io/assets/posts/wangyi_project_songlistpage.png" alt=""><img src="https://LuyiaGoe.github.io/assets/posts/wangyi_project_play.png" alt=""><img src="https://LuyiaGoe.github.io/assets/posts/wangyi_project_videopage.png" alt=""><img src="https://LuyiaGoe.github.io/assets/posts/wangyi_project_videoplay.png" alt=""></p><h2 id="核心内容"><a href="#核心内容" class="headerlink" title="核心内容"></a>核心内容</h2><ol><li>页面搭建<ul><li>Vue-cli快速搭建</li><li>采用ElementUI搭建页面</li><li>通过Vue-Router和组件构建前端路由</li><li>采用axios请求开源API：<a href="https://neteasecloudmusicapi.vercel.app" target="_blank" rel="noopener">网易云音乐 NodeJS 版 API</a></li></ul></li><li>播放组件</li><li>播放列表<ul><li>利用VueX管理播放数据（如正在播放歌曲信息、待播放歌曲列表、添加或切换的播放歌曲信息）</li></ul></li><li>播放事件<ul><li>通过组件中触发相应事件调用VueX的mutations达到切换、添加歌曲及切换播放列表等播放事件</li></ul></li></ol><h2 id="创建项目的细节（部分）"><a href="#创建项目的细节（部分）" class="headerlink" title="创建项目的细节（部分）"></a>创建项目的细节（部分）</h2><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><ol><li>图片</li><li>后端api <a href="https://neteasecloudmusicapi.vercel.app" target="_blank" rel="noopener">https://neteasecloudmusicapi.vercel.app</a></li><li>创建相应文件夹</li><li>插件下载及导入</li><li>main.js</li></ol><h3 id="首页制作"><a href="#首页制作" class="headerlink" title="首页制作"></a>首页制作</h3><ol><li>采用elementui的Container 布局容器</li><li>侧边栏采用NavMenu 导航菜单组件<ul><li>使用 vue-router 的模式 即：:router=”true”</li><li>取消选中高亮，使高亮跟普通字体颜色一样 active-text-color=”black”</li><li>设置路由index</li></ul></li><li>设置登录<ul><li>dialog组件 弹出登录框</li><li>带验证的 Form表单组件 输入登录信息</li><li>配置vecel后端api，并设置axios根路径，vue.config.js配置跨域问题</li><li>向api的/login/cellphone发送请求进行登录操作，登陆成功会返回res.data.coda=200</li><li>存储登录后的cookie信息到 localStorage ，命名为musicCookie</li><li>设置头像，头像图片URL存在res.data.profile.avatarUrl中</li></ul></li><li>设置退出登录</li><li>获取用户歌单并循环放入侧边栏<ul><li>向/user/playlist请求，歌单在res.data.playlist中，存入currentUserPlayList</li><li>侧边栏v-for循环currentUserPlayList,通过其中的subscribed判断是用户创建的还是收藏的歌单</li><li>v-if与v-for不能在同一个标签中使用，通过外包一层div将v-for与key扔到里面避免该问题</li></ul></li><li>主体部分路由设置</li><li>脚部播放组件<ul><li>通过slider组件实现</li><li>左边放置歌曲图片、名、歌手，中间放滑动条、前后首、暂停播放按钮，右边放音量、歌单</li><li>设置全局过滤器，将播放时间过滤成mm:ss的形式，并将过滤后的时间放到滑动条两侧</li></ul></li></ol><h3 id="发现音乐页制作"><a href="#发现音乐页制作" class="headerlink" title="发现音乐页制作"></a>发现音乐页制作</h3><ol><li>tab标签页制作<ul><li>tab页签头更换样式</li><li>tab内容中放入router-view，并根据不同的页签配置不同的路由</li></ul></li><li>个性推荐页制作<ul><li>轮播图采用Carousel 走马灯形式</li><li>轮播图api为‘bannner’</li><li>推荐歌单区域采用Divider 分割线</li><li>歌单内容列表采用layout布局，一行4个单元通过获取列表清单后循环渲染上去（此处出现空白渲染bug  通过对el-row更改flex布局并设置flex-wrap换行解决</li><li>独家放送页同上</li><li>最新歌曲采用el-row+el-table方式布局</li></ul></li><li>歌单页面制作<ul><li>添加分类按钮，根据分类获取不同的歌单</li><li>制作歌单列表</li></ul></li><li>排行榜页面制作</li><li>歌手页面制作</li><li>最新音乐制作</li></ol><h3 id="音乐播放列表页面制作"><a href="#音乐播放列表页面制作" class="headerlink" title="音乐播放列表页面制作"></a>音乐播放列表页面制作</h3><ol><li>创建文件及相应路由</li><li>根据route传来的params获取相应歌单的清单</li><li>制作歌单页面上部信息</li><li>制作内容区域<ul><li>放入路由占位符，出现请求头部信息</li><li>制作歌曲列表页</li><li>制作评论页</li><li>制作收藏者页</li></ul></li></ol><h3 id="视频页面制作"><a href="#视频页面制作" class="headerlink" title="视频页面制作"></a>视频页面制作</h3><ol><li>视频和mv清单页面制作</li><li>视频播放页面制作</li><li>mv播放页面制作<ul><li>与视频播放页面一致，但仅是采用的api不同，因此进行了合并</li></ul></li></ol><h3 id="播放功能制作"><a href="#播放功能制作" class="headerlink" title="播放功能制作"></a>播放功能制作</h3><ol><li>采用vuex，想法是<ul><li>将  正在播放的歌单、正播放的歌曲信息  放入状态管理</li><li>将  切换歌曲、切换歌单、添加歌曲入播放列表  放入mutations属性</li><li>因为请求用的api和传回的参数不尽相同，因此其他组件调用上述mutations属性时，需自行请求完数据，再进行调用并传递处理好的参数，而不是在vuex中进行请求</li></ul></li><li>实现<ul><li>从$store中调出当前即将播放的歌曲id，请求得到URL送入audio标签播放</li><li>获取audio的dom，为dom贴上timeupdate事件，以获取已播放时长以及歌曲时长，并绑定到拖动条上</li></ul></li></ol><h3 id="碰到的问题"><a href="#碰到的问题" class="headerlink" title="碰到的问题"></a>碰到的问题</h3><ol><li>有些样式在当前页面内无法更改，甚至添加！important也没用，如何区分，如何变更<ul><li>有些样式可以在global.css中定义并更改，并在HTML文件中引入，原因尚需思考,如圆角按钮和方角按钮，一个需要！impotant才能改padding，一个不需要</li></ul></li><li>出现相同path，不同query的路由请求，却不触发跳转的情况<ul><li>在标签内添加：key属性，<router-view :key="$route.path"></router-view>，原因需了解</li><li>音乐播放列表出现子路由变换，父组件却重新渲染的问题，原因在于上一条的：key属性，只要key值发生变动，父组件就会重新渲染，此时path中已经换了，导致无法根据path中的params按需（如，根据id找到歌单信息）请求静态资源，导致父组件渲染失败，之前的解决方法是让子路由带上父组件的params，之后通过导入单独组件而不用路由的方式解决</li></ul></li><li>音乐清单页面需要优化的点是切换内容区域的不同模块时，都只需要加载一边，不要切一次加载一次，因此需要父子组件传值，或者用vuex</li><li>出现全局污染</li><li>添加歌单按钮出现不同浏览器不同显示效果问题</li><li>el-input键入事件无法生效，通过在事件后添加.native可以解决</li><li>在搜索页面搜索时会不刷新页面，通过在路由跳转时加上一串随机数字或者关键字，配合路由占位符中:key强制刷新</li><li>父子组件传值时，父组件还在获取数据中，给子组件传递了空值或默认值，即使后面更新了，子组件却已经渲染出了空值并不再渲染后面传来的真数据，可以通过watch监视解决此问题</li></ol><h3 id="想法"><a href="#想法" class="headerlink" title="想法"></a>想法</h3><ol><li>为了减少请求次数，父组件一次性在请求完自身页面数据并显示完后，再一次性请求完子组件数据，并通过父子组件传值传递数据，如歌单页面与其子路由清单页面利用父子组件传值</li><li>vuex中存储正在播放的歌单，以及正在播放的歌曲id，为保证歌单中不出现重复的歌曲，利用同一首歌不能有同样的id的特点，采用set对象创建歌单</li><li>home页面的播放组件从vuex中获取正在播放的歌曲，播放并展示相关歌曲信息图片</li><li>切换歌曲时，将set对象Array.from()转换为数组，通过在这个数组中查找正在播放的歌曲id所在位置，按需（传入的步长，如-1是上一首，1是下一首）切换歌曲</li><li>往歌单中添加歌曲时，同上，先转换为数组，再找当前播放，然后用splice(index+1,0,addsong)在当前播放的歌曲后面插入要添加的歌曲</li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> Project </tag>
            
            <tag> VueX </tag>
            
            <tag> ElementUI </tag>
            
            <tag> axios </tag>
            
            <tag> Vue-Router </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue组件化开发</title>
      <link href="2021/03/26/Vue/VueComponentDevelopment/"/>
      <url>2021/03/26/Vue/VueComponentDevelopment/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="Vue组件化开发"><a href="#Vue组件化开发" class="headerlink" title="Vue组件化开发"></a>Vue组件化开发</h1><p>Vue很多人都会，而组件化也是近年来比较热的一个话题，那么你对Vue中的组件化了解多少呢？</p><h2 id="组件化开发："><a href="#组件化开发：" class="headerlink" title="组件化开发："></a>组件化开发：</h2><p>1、组件化开发指的是将复杂的业务拆分为一个有一个的组件2、组件化开发的组件一般来说要灵活3、组件化开发涉及到了Vue的js组件封装，需要掌握Vue基础、Vue实例方法与属性、Vue.extend、Vue插件等知识</p><h2 id="Vue实例方法与属性"><a href="#Vue实例方法与属性" class="headerlink" title="Vue实例方法与属性"></a>Vue实例方法与属性</h2><p><strong>vm.$mount(el)</strong>会将当前的组件挂载el元素上，该操作会替换当前的元素若$mount中接收的el为空，则会挂载到当前的vue实例以外的地方当vm对象中存在el时，会挂载到el上</p><p><strong>vm.$el</strong>返回当前挂载的元素</p><h2 id="Vue-extend与Vue-Component"><a href="#Vue-extend与Vue-Component" class="headerlink" title="Vue.extend与Vue.Component"></a>Vue.extend与Vue.Component</h2><p>1、Vue.Component</p><p>定义了一个在Vue的挂载点下的一个全局组件</p><p>2、Vue.extend</p><p>定义了一个未挂载的组件类</p><p>可以接收一个组件作为当前组件类的模板</p><p>使用关键字new实例组件，可以接收参数，这个组件需要手动挂载</p><p>3、插件</p><p><strong>Vue.use(Plugin, options)</strong></p><p>Plugin：若为对象时，会查找并执行对象下的install方法，若为函数，会直接执行</p><p>options：传递到insntall函数中的参数</p><blockquote><p>install函数的第一个参数是Vue，第二个参数为options</p></blockquote><h2 id="全局指定、组件、方法"><a href="#全局指定、组件、方法" class="headerlink" title="全局指定、组件、方法"></a>全局指定、组件、方法</h2><pre><code class="highlight js"><span class="keyword">import</span> MyPlugin <span class="keyword">from</span> <span class="string">""</span>MyPlugin.install=<span class="function">(<span class="params">Vue, options</span>)=&gt;</span>{    <span class="comment">// 添加全局组件</span>    Vue.component(MyPlugin.name, MyPlugin)    <span class="comment">// 挂载原型方法</span>    <span class="keyword">var</span> Plugin = Vue.extend(MyPlugin)    Vue.prototype.doPlugin = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{        <span class="keyword">var</span> plugin = <span class="keyword">new</span> Plugin({})        <span class="built_in">document</span>.body.appendChild(plugin.$mount().$el)    }    <span class="comment">// 添加全局方法或属性</span>    Vue.myGlobalMethod = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{        <span class="comment">// code</span>    }    Vue.myGlobalProperty = <span class="string">'property'</span>    <span class="comment">// 添加全局资源</span>    Vue.directive(<span class="string">'my-directive'</span>, {        bind (el, binding, vnode, oldVnode) {            <span class="comment">// code</span>        }        <span class="comment">// code</span>    })    <span class="comment">// 注入组件选项</span>    Vue.mixin({        created: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{            <span class="comment">// code</span>        } ...    })}<span class="keyword">export</span> <span class="keyword">default</span> MyPlugin</code></pre><h2 id="实例：Popup插件的封装"><a href="#实例：Popup插件的封装" class="headerlink" title="实例：Popup插件的封装"></a>实例：Popup插件的封装</h2><p>编写：<strong>src/components/Popup/Popup.vue</strong></p><pre><code class="highlight vue">&lt;template&gt;&lt;div class='popup-container' v-if="status"&gt;&lt;div class="popup-content"&gt;&lt;div class="popup-title"&gt;{{title}}&lt;/div&gt;&lt;div class="popup-msg"&gt;{{msg}}&lt;/div&gt;&lt;a class="popup-btn" href="javascript: void(0)" @click="hidePopup"&gt;x&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default {    name: 'popup'}&lt;/script&gt;&lt;style lang="scss"&gt;    div.popup-container{        position: fixed;        top: 0;        left: 0;        width: 100vw;        height: 100vh;        background: rgba(33, 33, 33, .5);        box-sizing: content-box;        div.popup-content{        position: absolute;        top: 50%;        left: 50%;        margin: -150px -300px;        background: #fff;        width: 600px;        height: 300px;    }    div.popup-title{        width: 590px;        height: 20px;        padding: 5px;        line-height: 20px;        text-align: center;        background: #3498db;    }    div.popup-msg{        width: 588px;        height: 239px;        text-align: center;        border: 1px solid #999;        border-top: none;        padding: 15px 5px;    }    a.popup-btn{        position: absolute;        top: 5px;        right: 5px;        display: block;        width: 20px;        height: 20px;        line-height: 20px;        font-size: 16px;        text-align: center;        text-decoration: none;        color: #666;        background: #f00;    }}&lt;/style&gt;</code></pre><p><strong>src/components/Popup/index.js</strong></p><pre><code class="highlight js"><span class="keyword">import</span> Popup <span class="keyword">from</span> <span class="string">'./Popup.vue'</span><span class="keyword">const</span> defaultData = {    status: <span class="literal">false</span>,    title: <span class="string">'Popup'</span>,    msg: <span class="string">'Message'</span>}Popup.install = <span class="function">(<span class="params">Vue</span>) =&gt;</span> {    <span class="keyword">let</span> PopupCom = Vue.extend(Popup)    <span class="built_in">console</span>.log(<span class="string">'PopupCom'</span>, PopupCom)    Vue.prototype.$popup = <span class="function"><span class="keyword">function</span>(<span class="params">params</span>) </span>{        <span class="keyword">let</span> popup = <span class="keyword">new</span> PopupCom({            el: <span class="built_in">document</span>.createElement(<span class="string">'div'</span>),            data() {                <span class="keyword">for</span>(<span class="keyword">let</span> item <span class="keyword">in</span> params){                    defaultData[item] = params[item]                }                <span class="keyword">return</span> defaultData            },            methods: {                hidePopup() {                    <span class="keyword">this</span>.status = <span class="literal">false</span>;                },            },        })        <span class="built_in">console</span>.log(<span class="string">'popup'</span>, popup);        <span class="built_in">console</span>.log(<span class="string">'popup.$mount()'</span>, popup.$mount());        <span class="built_in">document</span>.body.appendChild(popup.$mount().$el)    }}<span class="keyword">export</span> <span class="keyword">default</span> Popup</code></pre><p>使用：<strong>src/main.js</strong></p><pre><code class="highlight js"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./App.vue'</span><span class="comment">//引用并使用插件</span><span class="keyword">import</span> Popup <span class="keyword">from</span> <span class="string">'./components/Popup'</span>Vue.use(Popup)<span class="keyword">new</span> Vue({    render: <span class="function"><span class="params">h</span> =&gt;</span> h(App),}).$mount(<span class="string">'#app'</span>)</code></pre><p><strong>src/main.js</strong></p><pre><code class="highlight vue">&lt;template&gt;&lt;div id="app"&gt;&lt;img alt="Vue logo" src="./assets/logo.png"&gt;&lt;button @click="doit"&gt;do&lt;/button&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default {    name: 'app',    methods: {        //调用方法进行弹窗        doit() {            this.$popup({                status: true            })        }    },}&lt;/script&gt;&lt;style lang="scss"&gt;#app {    text-align: center;}&lt;/style&gt;</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unable to preventDefault inside passive event listener due to target being treated as passive</title>
      <link href="2021/03/14/Webpack/Unable%20to%20preventDefault%20inside%20passive%20event%20listener%20due%20to%20target%20being%20treated%20as%20passive/"/>
      <url>2021/03/14/Webpack/Unable%20to%20preventDefault%20inside%20passive%20event%20listener%20due%20to%20target%20being%20treated%20as%20passive/</url>
      
        <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>翻译：chrome 监听touch类事件报错：无法被动侦听事件preventDefault<br><br>这是chrome浏览器报错，目的是为了最快速地相应touch事件而做出的改变<br><br>因为preventDefault()是取消默认事件的，如果这个函数起作用的话，比如默认的表单提交，a链接的点击跳转，就不好用了<br><br>历史：当浏览器首先对默认的事件进行响应的时候，要检查一下是否进行了默认事件的取消。这样就在响应滑动操作之前有那么一丝丝的耽误时间<br><br>现在：google就决定默认取消了对这个事件的检查，默认时间就取消了。直接执行滑动操作。这样就更加的顺滑了。但是浏览器的控制台就会进行错误提醒了<br><br>具体情况：从 chrome56 开始，在 window、document 和 body 上注册的 touchstart 和 touchmove 事件处理函数，会默认为是 passive: true。浏览器忽略 preventDefault() 就可以第一时间滚动了<br><br>导致下面的效果一致：</p><pre><code class="highlight javascript">wnidow.addEventListener(<span class="string">'touchmove'</span>, func) 效果和下面一句一样wnidow.addEventListener(<span class="string">'touchmove'</span>, func, { <span class="attr">passive</span>: <span class="literal">true</span> })</code></pre><p>这样会出现新的问题:<br>如果在以上这 3 个元素的 touchstart 和 touchmove 事件处理函数中调用 e.preventDefault() ，会被浏览器忽略掉，并不会阻止默认行为</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><ol><li>注册处理函数时，用如下方式，明确声明为不是被动的<br>window.addEventListener(‘touchmove’, func, { passive: false })</li><li>应用 CSS 属性 touch-action: none; 这样任何触摸事件都不会产生默认行为，但是 touch 事件照样触发</li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Webpack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>webpack 中 使用 url-loader 后图片src=&quot;[object Module]&quot; 导致图片无法显示</title>
      <link href="2021/03/12/Webpack/webpack-URL-rules/"/>
      <url>2021/03/12/Webpack/webpack-URL-rules/</url>
      
        <content type="html"><![CDATA[<h1 id="webpack-中-使用-url-loader-后图片src-”-object-Module-”-导致图片无法显示"><a href="#webpack-中-使用-url-loader-后图片src-”-object-Module-”-导致图片无法显示" class="headerlink" title="webpack 中 使用 url-loader 后图片src=”[object Module]” 导致图片无法显示"></a>webpack 中 使用 url-loader 后图片src=”[object Module]” 导致图片无法显示</h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>在webpack.config.js文件中,对图片的匹配规则如下：</p><pre><code class="highlight javascript"><span class="built_in">module</span>.exports={  <span class="built_in">module</span>:{    rules:[      { <span class="attr">test</span>: <span class="regexp">/\.jpg|png|gif|bmp|jpeg$/</span>, <span class="attr">use</span>: <span class="string">'url-loader?limit=7630&amp;name=[hash:8]-[name].[ext]'</span> }    ]  }}</code></pre><p>打包后网页中显示图片为：<img src="https://LuyiaGoe.github.io/assets/posts/object-Module1.png" alt=""></p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>在webpack.config.js文件中,对匹配规则修改如下：</p><pre><code class="highlight javascript"><span class="built_in">module</span>.exports={  <span class="built_in">module</span>:{    rules:[      { <span class="attr">test</span>: <span class="regexp">/\.jpg|png|gif|bmp|jpeg$/</span>, <span class="attr">use</span>: <span class="string">'url-loader?limit=7630&amp;name=[hash:8]-[name].[ext]&amp;esModule=false'</span> }    ]  }}</code></pre><p>修改完成后，显示为：<img src="https://LuyiaGoe.github.io/assets/posts/object-Module2.png" alt=""></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Webpack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue 给UI库添加按需加载时启动项目时 babel-preset-es2015 报错</title>
      <link href="2021/03/11/Vue/vue%20%E7%BB%99UI%E5%BA%93%E6%B7%BB%E5%8A%A0%E6%8C%89%E9%9C%80%E5%8A%A0%E8%BD%BD%E6%97%B6%E5%90%AF%E5%8A%A8%E9%A1%B9%E7%9B%AE%E6%97%B6%20babel-preset-es2015%20%E6%8A%A5%E9%94%99/"/>
      <url>2021/03/11/Vue/vue%20%E7%BB%99UI%E5%BA%93%E6%B7%BB%E5%8A%A0%E6%8C%89%E9%9C%80%E5%8A%A0%E8%BD%BD%E6%97%B6%E5%90%AF%E5%8A%A8%E9%A1%B9%E7%9B%AE%E6%97%B6%20babel-preset-es2015%20%E6%8A%A5%E9%94%99/</url>
      
        <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>项目使用vue cli3脚手架工具构建按照element 官方文档中所示</p><p><code>npm install babel-plugin-component -D</code></p><p>然后添加.babelrc文件</p><pre><code class="highlight javascript">{  <span class="string">"presets"</span>: [[<span class="string">"es2015"</span>, { <span class="string">"modules"</span>: <span class="literal">false</span> }]],  <span class="string">"plugins"</span>: [    [      <span class="string">"component"</span>,      {        <span class="string">"libraryName"</span>: <span class="string">"element-ui"</span>,        <span class="string">"styleLibraryName"</span>: <span class="string">"theme-chalk"</span>      }    ]  ]}</code></pre><p>报如下错误：</p><pre><code class="highlight javascript"><span class="built_in">Error</span>: Cannot find <span class="built_in">module</span> <span class="string">'babel-preset-es2015'</span> <span class="keyword">from</span> <span class="string">'C:\Users\Administrator\Des</span><span class="string">ktop\vueProject\vuedemo'</span></code></pre><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><h3 id="1-此时应该安装-babel-preset-env"><a href="#1-此时应该安装-babel-preset-env" class="headerlink" title="1.此时应该安装@babel/preset-env"></a>1.此时应该安装@babel/preset-env</h3><p><code>npm i @babel/preset-env -D</code></p><h3 id="2-并且修改-babelrc文件中的’presets’属性"><a href="#2-并且修改-babelrc文件中的’presets’属性" class="headerlink" title="2.并且修改.babelrc文件中的’presets’属性"></a>2.并且修改.babelrc文件中的’presets’属性</h3><pre><code class="highlight javascript">{  <span class="string">"presets"</span>: [[<span class="string">"@babel/preset-env"</span>, { <span class="string">"modules"</span>: <span class="literal">false</span> }]],  <span class="string">"plugins"</span>: [    [      <span class="string">"component"</span>,      {        <span class="string">"libraryName"</span>: <span class="string">"element-ui"</span>,        <span class="string">"styleLibraryName"</span>: <span class="string">"theme-chalk"</span>      }    ]  ]}</code></pre><p>解决问题</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript变量转换</title>
      <link href="2021/03/09/JavaScript/JavaScriptValueChange/"/>
      <url>2021/03/09/JavaScript/JavaScriptValueChange/</url>
      
        <content type="html"><![CDATA[<h2 id="JavaScript变量转换"><a href="#JavaScript变量转换" class="headerlink" title="JavaScript变量转换 "></a>JavaScript变量转换 <span id="home"></span></h2><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><strong><a href="#1">自动转换 </a></strong><ul><li><strong><a href="#1.1">(1)Number与Boolean</a></strong></li><li><strong><a href="#1.2">(2)Number与String</a></strong></li><li><strong><a href="#1.3">(3)String与Boolean</a></strong></li><li><strong><a href="#1.4">(4)null的自动转换</a></strong></li><li><strong><a href="#1.5">(5)undefined的自动转换</a></strong></li></ul></li><li><strong><a href="#2">强制转换 </a></strong><ul><li><strong><a href="#2.1">运算强制转换 </a></strong><ul><li><strong><a href="#2.1.1">(1)Number与Boolean</a></strong></li><li><strong><a href="#2.1.2">(2)Number与String</a></strong></li><li><strong><a href="#2.1.3">(3)String与Boolean</a></strong></li><li><strong><a href="#2.1.4">(4)null</a></strong></li><li><strong><a href="#2.1.5">(5)undefined</a></strong></li></ul></li><li><strong><a href="#2.2">类型强制转换 </a></strong><ul><li><strong><a href="#2.2.1">(1)Number</a></strong></li><li><strong><a href="#2.2.2">(2)String</a></strong></li><li><strong><a href="#2.2.3">(3)Boolean</a></strong></li><li><strong><a href="#2.2.4">(4)null</a></strong></li><li><strong><a href="#2.2.5">(5)undefined</a></strong></li></ul></li></ul></li></ul><hr><h2 id="一、自动转换"><a href="#一、自动转换" class="headerlink" title="一、自动转换 "></a>一、自动转换 <span id="1"></span></h2><p>“==”的自动转换</p><p>自动转换优先级：number&gt;boolean&gt;String，越小越先转换</p><h3 id="1-Number与Boolean"><a href="#1-Number与Boolean" class="headerlink" title="(1)Number与Boolean: "></a>(1)Number与Boolean: <span id="1.1"></span></h3><pre><code>console.log(0==false); //trueconsole.log(1==true);  //trueconsole.log(2==true);  //flase//这个过程其实是Boolean类型转换为数字的过程</code></pre><h3 id="2-Number与String"><a href="#2-Number与String" class="headerlink" title="(2)Number与String: "></a>(2)Number与String: <span id="1.2"></span></h3><pre><code>console.log(""==0);  //trueconsole.log("12"==12);  //trueconsole.log("12a"==12);  //false//String自动转换时只能转换纯数字的字符串</code></pre><h3 id="3-String与Boolean"><a href="#3-String与Boolean" class="headerlink" title="(3)String与Boolean "></a>(3)String与Boolean <span id="1.3"></span></h3><pre><code>console.log(""==false);  //trueconsole.log("s"==true);  //true//字符串转换为boolean均为true</code></pre><h3 id="4-null的自动转换"><a href="#4-null的自动转换" class="headerlink" title="(4)null的自动转换 "></a>(4)null的自动转换 <span id="1.4"></span></h3><p>null的本质是空对象，自动转换时会处理空对象的引用地址，转换为数字与其他对象的处理</p><pre><code>console.log(null==0);  //false//地址是数字，且肯定不是0console.log(null==false);  //falseconsole.log(null==true);  //false//地址是数字，比较时会将boolean转换为数字console.log(null=="null");  //falseconsole.log(null=="");  //false//地址为数字，比较时会将String转换为数字</code></pre><h3 id="5-undefined的自动转换"><a href="#5-undefined的自动转换" class="headerlink" title="(5)undefined的自动转换 "></a>(5)undefined的自动转换 <span id="1.5"></span></h3><p>undefined表示未定义，不带任何东西，大家可以理解为老顽固(偷笑)</p><pre><code>console.log(undefined==0);  //false//无法自动转换数字console.log(undefined==false);  //falseconsole.log(undefined==true);  //false//无法自动转换booleanconsole.log(undefined=="");  //falseconsole.log(undefined=="undefined");  //false//无法自动转换为Stringconsole.log(undefined==null);  //trueconsole.log(undefined===null);  //false//null是空对象，会被认为是undefined，但严格的来说两者是不相等的</code></pre><h2 id="二、强制转换"><a href="#二、强制转换" class="headerlink" title="二、强制转换 "></a>二、强制转换 <span id="2"></span></h2><h3 id="1、运算强制转换"><a href="#1、运算强制转换" class="headerlink" title="1、运算强制转换 "></a>1、运算强制转换 <span id="2.1"></span></h3><p>“+”会尝试将两端的值尝试转换为字符串或数字。优先级：String&gt;Number</p><h4 id="1-Number与Boolean-1"><a href="#1-Number与Boolean-1" class="headerlink" title="(1)Number与Boolean: "></a>(1)Number与Boolean: <span id="2.1.1"></span></h4><pre><code>console.log(1+false); //1console.log(1+true);  //2</code></pre><h4 id="2-Number与String-1"><a href="#2-Number与String-1" class="headerlink" title="(2)Number与String: "></a>(2)Number与String: <span id="2.1.2"></span></h4><pre><code>console.log(""+1);  //"1"console.log("1"+1);  //"11"//运算时，String优先级大于Number，Number转换为String</code></pre><h3 id="3-String与Boolean-1"><a href="#3-String与Boolean-1" class="headerlink" title="(3)String与Boolean "></a>(3)String与Boolean <span id="2.1.3"></span></h3><pre><code>console.log(""+false);  //falseconsole.log(""+true);  //trueconsole.log(typeof(""+true));  //String//按照优先级，会将boolean转换为String</code></pre><h4 id="4-null"><a href="#4-null" class="headerlink" title="(4)null "></a>(4)null <span id="2.1.4"></span></h4><pre><code>console.log(null+1);  //1//null的本质是空对象,强制转换会转换为0</code></pre><h4 id="5-undefined"><a href="#5-undefined" class="headerlink" title="(5)undefined "></a>(5)undefined <span id="2.1.5"></span></h4><pre><code>console.log(undefined+0);  //NaN//强制转换数字时为NaNconsole.log(Boolean(undefined));  //false</code></pre><h3 id="2、类型强制转换"><a href="#2、类型强制转换" class="headerlink" title="2、类型强制转换 "></a>2、类型强制转换 <span id="2.2"></span></h3><h4 id="1-Number"><a href="#1-Number" class="headerlink" title="(1)Number "></a>(1)Number <span id="2.2.1"></span></h4><pre><code>String:这里说下String()和toString()的区别toString()可以将除了null、undefined以外的一切对象转换为String，且toString()可以接收第二个参数，将字符串的进制进行改变String()可以将任何对象转换为String，String只有一个传参Boolean:console.log(Boolean(0));  //falseconsole.log(Boolean(1));  //trueconsole.log(Boolean(2));  //trueconsole.log(Boolean(-2));  //true//除0以外均为true</code></pre><h4 id="2-String"><a href="#2-String" class="headerlink" title="(2)String "></a>(2)String <span id="2.2.2"></span></h4><pre><code>Number:console.log(Number("1"));  //1console.log(Number("1a"));  //NaNconsole.log(Number(""));  //0console.log(parseInt("1a"));  //1console.log(parseInt("a1"));  //NaNconsole.log(parseInt(""));  //NaN//使用Number进行转换时必须是纯数字字符串，否则为NaN//使用parseInt转换时，头部必须有数字，否则为NaN//parseInt是全局函数，不属于Number，与Number强制转换有区别Boolean:console.log(Boolean(""));  //falseconsole.log(Boolean("true"));  //trueconsole.log(Boolean("false"));  //true//String为空是flase，其他均为true</code></pre><h4 id="3-Boolean"><a href="#3-Boolean" class="headerlink" title="(3)Boolean "></a>(3)Boolean <span id="2.2.3"></span></h4><pre><code>Number:console.log(Number(false));  //0console.log(Number(true));  //1String:输出对应的字符串</code></pre><h4 id="4-null-1"><a href="#4-null-1" class="headerlink" title="(4)null "></a>(4)null <span id="2.2.4"></span></h4><pre><code>Number:console.log(Number(null));  //0String:输出对应的字符串Boolean:console.log(Boolean(null));  //false</code></pre><h4 id="5-undefined-1"><a href="#5-undefined-1" class="headerlink" title="(5)undefined "></a>(5)undefined <span id="2.2.5"></span></h4><pre><code>Number:console.log(Number(undefined));  //NaN//此种方式强制转换依旧为非数字String:输出对应的字符串Boolean:console.log(Boolean(undefined));  //false</code></pre><p>码字不易，后面还会放出各种文章，喜欢的关注一下我吖，你们的关注是我最大的动力</p><p>github：<a href="https://github.com/LuyiaGoe" target="_blank" rel="noopener">github.com/LuyiaGoe</a></p><p>个人博客：<a href="https://LuyiaGoe.github.io" target="_blank" rel="noopener">LuyiaGoe.github.io</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Variable </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浏览器异步加载JS的方法</title>
      <link href="2021/03/01/JavaScript/HTMLAsyncLoadScript/"/>
      <url>2021/03/01/JavaScript/HTMLAsyncLoadScript/</url>
      
        <content type="html"><![CDATA[<h1 id="浏览器异步加载JS的方法"><a href="#浏览器异步加载JS的方法" class="headerlink" title="浏览器异步加载JS的方法"></a>浏览器异步加载JS的方法</h1><h2 id="浏览器加载JS的方法"><a href="#浏览器加载JS的方法" class="headerlink" title="浏览器加载JS的方法"></a>浏览器加载JS的方法</h2><p>说到这个，最常见的就是内置JS和外联JS了</p><p>内置：</p><pre><code class="highlight html"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"><span class="built_in">console</span>.log(<span class="string">'加载完成'</span>)</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></code></pre><p>外联：</p><pre><code class="highlight html"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">""</span> <span class="attr">type</span>=<span class="string">"application/javascript"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></code></pre><p>而后，由于浏览器默认的脚本语言为JavaScript，因此type属性可以去掉。</p><pre><code class="highlight html"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">""</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></code></pre><h2 id="浏览器渲染规则"><a href="#浏览器渲染规则" class="headerlink" title="浏览器渲染规则"></a>浏览器渲染规则</h2><p>浏览器的渲染规则是，从上到下加载，正常情况下加载完马上就会执行。</p><p>CSS文件可以边加载边渲染，而JS文件必须等到加载完成才能渲染。</p><p>若在加载过程中遇到大体积的JS文件，则会等到JS加载完后才会继续渲染，对整个页面的加载造成阻塞。</p><h2 id="浏览器的异步加载"><a href="#浏览器的异步加载" class="headerlink" title="浏览器的异步加载"></a>浏览器的异步加载</h2><p>而为了解决加载阻塞问题，浏览器提供了defer属性和async属性。</p><p>那么，defer和async有什么区别呢？</p><p>给script标签加上defer属性，其内部的JS会在整个页面加载完成后才执行。这个加载完包括整个页面的渲染和其他脚本的执行。存在多个defer时，会按照顺序执行。</p><p>而若是加上async属性，JS会在该script标签加载完后执行。这个加载完成后会中断渲染来执行。执行完成后再继续渲染。由于加载速度是不确定的，多个async脚本之间无法确保执行顺序。</p><h2 id="浏览器ES6模块支持"><a href="#浏览器ES6模块支持" class="headerlink" title="浏览器ES6模块支持"></a>浏览器ES6模块支持</h2><p>在ES6中，添加了JS模块化的标准，在script标签上添加<code>type="module"</code>即可声明为ES6模块。</p><pre><code class="highlight html"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"module"</span> <span class="attr">src</span>=<span class="string">""</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></code></pre><p>对添加了<code>type="module"</code>的标签，浏览器默认会对其进行defer属性的处理，即等到整个页面加载完成后再执行，同时，也可以添加async标签，这样，该标签会在加载完成后执行。</p><pre><code class="highlight html"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"module"</span> <span class="attr">src</span>=<span class="string">""</span> <span class="attr">async</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></code></pre><p>同时，添加了<code>type="module"</code>的标签也可以直接内嵌，这样浏览器会按照默认的加载方式加载。</p><pre><code class="highlight html"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"module"</span>&gt;</span><span class="javascript">    <span class="keyword">import</span> moduleA <span class="keyword">from</span> <span class="string">'./moduleA.js'</span></span><span class="javascript"><span class="built_in">console</span>.log(<span class="string">'加载完成'</span>)</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> HTML </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Async </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1ink与@import的区别</title>
      <link href="2021/02/13/HTML&amp;CSS/CSSImport/"/>
      <url>2021/02/13/HTML&amp;CSS/CSSImport/</url>
      
        <content type="html"><![CDATA[<h2 id="1ink与-import的区别"><a href="#1ink与-import的区别" class="headerlink" title="1ink与@import的区别 "></a><code>1ink</code>与<code>@import</code>的区别 <span id="home"></span></h2><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><strong><a href="#1"><code>1ink</code>与<code>@import</code>的区别 </a></strong><ul><li><strong><a href="#1.1">差别1：归属关系的差别 </a></strong></li><li><strong><a href="#1.2">差别2：加载顺序的差别 </a></strong><ul><li><strong><a href="#3.1">差别3：兼容性的差别 </a></strong></li><li><strong><a href="#3.1">差别4：使用dom控制样式时的差别 </a></strong></li></ul></li></ul></li></ul><hr><h2 id="1ink与-import的区别-1"><a href="#1ink与-import的区别-1" class="headerlink" title="1ink与@import的区别 "></a><code>1ink</code>与<code>@import</code>的区别 <span id="1"></span></h2><h4 id="差别1：归属关系的差别"><a href="#差别1：归属关系的差别" class="headerlink" title="差别1：归属关系的差别 "></a>差别1：归属关系的差别 <span id="1.1"></span></h4><p><code>link</code>属于<code>xhtml</code>标签，而<code>@import</code>属于<code>css</code>提供的方式，必须写在<code>style</code>标签里。<code>link</code>标签除了可以加载<code>css</code>外，还可以定义RSS、定义<code>rel</code>连接属性等，<code>＠import</code>只能加载<code>css</code>。</p><h4 id="差别2：加载顺序的差别"><a href="#差别2：加载顺序的差别" class="headerlink" title="差别2：加载顺序的差别 "></a>差别2：加载顺序的差别 <span id="1.2"></span></h4><p>当一个页面被加载的时候，即浏览者浏览页面时，<code>link</code>引用的<code>css</code>会同时被加载，而<code>@import</code>引用的<code>css</code>会等到页面全部被下载完后加载。使用<code>＠import</code>可能存在页面的样式在开始时不显示的问题。</p><h4 id="差别3：兼容性的差别"><a href="#差别3：兼容性的差别" class="headerlink" title="差别3：兼容性的差别 "></a>差别3：兼容性的差别 <span id="1.2"></span></h4><p><code>@import</code>是<code>CSS2.1</code>提出的，只在IE5以上才能识别，而<code>link</code>标签不存在兼容问题。</p><h4 id="差别4：使用dom控制样式时的差别"><a href="#差别4：使用dom控制样式时的差别" class="headerlink" title="差别4：使用dom控制样式时的差别 "></a>差别4：使用dom控制样式时的差别 <span id="1.2"></span></h4><p>当使用<code>JS</code>控制<code>dom</code>改变样式时，只能使用<code>link</code>，<code>dom</code>无法控制<code>＠import</code>。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>窗口间的通信与iframe跨域</title>
      <link href="2020/12/21/JavaScript/JavaScriptIframeCrossOrigin/"/>
      <url>2020/12/21/JavaScript/JavaScriptIframeCrossOrigin/</url>
      
        <content type="html"><![CDATA[<h1 id="窗口间的通信与-iframe-跨域"><a href="#窗口间的通信与-iframe-跨域" class="headerlink" title="窗口间的通信与 iframe 跨域"></a>窗口间的通信与 iframe 跨域</h1><h2 id="iframe-跨域场景"><a href="#iframe-跨域场景" class="headerlink" title="iframe 跨域场景"></a>iframe 跨域场景</h2><p>1、若需要通讯的两个窗口在同源域名下，则无需跨域。</p><p>2、若需要通讯的两个窗口在同一个顶级域名下，可以手动配置两个窗口的域名为该顶级域名，从而实现通讯。代码如下：</p><pre><code class="highlight js"><span class="built_in">document</span>.domain = <span class="string">"localhost"</span>;</code></pre><p>3、若需要通讯的两个窗口不在同一顶级域名下，则需要使用到 postMessage 方法。</p><h2 id="postMessage"><a href="#postMessage" class="headerlink" title="postMessage"></a>postMessage</h2><p>该方法是 window 下的一个方法，用于发送一条消息。</p><p>对应的事件是 onmessage 事件。</p><pre><code class="highlight js"><span class="keyword">const</span> recvMsg = <span class="function"><span class="params">event</span> =&gt;</span> {  <span class="keyword">if</span> (event.origin === <span class="string">"http://localhost:8080"</span>) {    <span class="built_in">console</span>.log(event.data);  }};<span class="built_in">window</span>.onmessage = recvMsg;<span class="comment">// 也可以用事件监听</span><span class="comment">// window.addEventListener("message", recvMsg)</span></code></pre><p>该方法可以在其他的窗口中调用，而不会产生跨域问题。（安全通讯）</p><h2 id="获取到不同窗口的-window-对象"><a href="#获取到不同窗口的-window-对象" class="headerlink" title="获取到不同窗口的 window 对象"></a>获取到不同窗口的 window 对象</h2><p>1、若是使用 window.open 打开，则可以通过 window.opener 获取到 window 对象。</p><p>2、若是使用 iframe 引用，则可以通过使用 window.top 获取到 window 对象。</p><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><p>1、同顶级域名localhost 域名<code>index.html</code></p><pre><code class="highlight html"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span><span class="tag">&lt;<span class="name">html</span>&gt;</span>  <span class="tag">&lt;<span class="name">body</span>&gt;</span>    <span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">"http://localhost:8080/iframe.html"</span> <span class="attr">frameborder</span>=<span class="string">"0"</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span>    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript">      <span class="built_in">document</span>.domain = <span class="string">"localhost"</span>;</span><span class="javascript">      <span class="built_in">window</span>.list = [];</span><span class="javascript">      <span class="built_in">window</span>.setValue = <span class="function">(<span class="params">key, value</span>) =&gt;</span> {</span><span class="javascript">        <span class="built_in">window</span>[key] = value;</span>      };<span class="javascript">      <span class="built_in">window</span>.getValue = <span class="function"><span class="params">key</span> =&gt;</span> {</span><span class="javascript">        <span class="keyword">return</span> <span class="built_in">window</span>[key];</span>      };    <span class="tag">&lt;/<span class="name">script</span>&gt;</span>  <span class="tag">&lt;/<span class="name">body</span>&gt;</span><span class="tag">&lt;/<span class="name">html</span>&gt;</span></code></pre><p>localhost:8080 域名<code>iframe.html</code></p><pre><code class="highlight html"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span><span class="tag">&lt;<span class="name">html</span>&gt;</span>  <span class="tag">&lt;<span class="name">body</span>&gt;</span>    iframe    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript">      <span class="built_in">document</span>.domain = <span class="string">"localhost"</span>;</span><span class="javascript">      <span class="built_in">console</span>.log(top.setValue(<span class="string">"list"</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]));</span><span class="javascript">      <span class="built_in">console</span>.log(top.getValue(<span class="string">"list"</span>));</span>    <span class="tag">&lt;/<span class="name">script</span>&gt;</span>  <span class="tag">&lt;/<span class="name">body</span>&gt;</span><span class="tag">&lt;/<span class="name">html</span>&gt;</span></code></pre><p>2、open 形式localhost 域名<code>index.html</code></p><pre><code class="highlight html"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span><span class="tag">&lt;<span class="name">html</span>&gt;</span>  <span class="tag">&lt;<span class="name">body</span>&gt;</span>    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript">      <span class="built_in">window</span>.open(<span class="string">"http://localhost:8080/iframe.html"</span>);</span><span class="javascript">      <span class="built_in">window</span>.onmessage = <span class="function"><span class="params">event</span> =&gt;</span> {</span><span class="actionscript">        <span class="keyword">if</span> (event.origin == <span class="string">"http://localhost:8080"</span>) {</span><span class="javascript">          <span class="built_in">console</span>.log(event.origin, event.data);</span>        }      };    <span class="tag">&lt;/<span class="name">script</span>&gt;</span>  <span class="tag">&lt;/<span class="name">body</span>&gt;</span><span class="tag">&lt;/<span class="name">html</span>&gt;</span></code></pre><p>localhost:8080 域名<code>iframe.html</code></p><pre><code class="highlight html"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span><span class="tag">&lt;<span class="name">html</span>&gt;</span>  <span class="tag">&lt;<span class="name">body</span>&gt;</span>    iframe    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript">      <span class="built_in">window</span>.onload = <span class="function"><span class="params">()</span> =&gt;</span> {</span><span class="javascript">        <span class="built_in">window</span>.opener.postMessage(<span class="string">"value"</span>, <span class="string">"http://localhost"</span>);</span>      };    <span class="tag">&lt;/<span class="name">script</span>&gt;</span>  <span class="tag">&lt;/<span class="name">body</span>&gt;</span><span class="tag">&lt;/<span class="name">html</span>&gt;</span></code></pre><p>3、iframe 形式localhost 域名<code>index.html</code></p><pre><code class="highlight html"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span><span class="tag">&lt;<span class="name">html</span>&gt;</span>  <span class="tag">&lt;<span class="name">body</span>&gt;</span>    <span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">"http://localhost:8080/iframe.html"</span> <span class="attr">frameborder</span>=<span class="string">"0"</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span>    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript">      <span class="built_in">window</span>.onmessage = <span class="function"><span class="params">event</span> =&gt;</span> {</span><span class="actionscript">        <span class="keyword">if</span> (event.origin == <span class="string">"http://localhost:8080"</span>) {</span><span class="javascript">          <span class="built_in">console</span>.log(event.origin, event.data);</span>        }      };    <span class="tag">&lt;/<span class="name">script</span>&gt;</span>  <span class="tag">&lt;/<span class="name">body</span>&gt;</span><span class="tag">&lt;/<span class="name">html</span>&gt;</span></code></pre><p>localhost:8080 域名<code>iframe.html</code></p><pre><code class="highlight html"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span><span class="tag">&lt;<span class="name">html</span>&gt;</span>  <span class="tag">&lt;<span class="name">body</span>&gt;</span>    iframe    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript">      <span class="built_in">window</span>.onload = <span class="function"><span class="params">()</span> =&gt;</span> {</span><span class="javascript">        <span class="built_in">window</span>.top.postMessage(<span class="string">"value"</span>, <span class="string">"http://localhost"</span>);</span>      };    <span class="tag">&lt;/<span class="name">script</span>&gt;</span>  <span class="tag">&lt;/<span class="name">body</span>&gt;</span><span class="tag">&lt;/<span class="name">html</span>&gt;</span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iframe </tag>
            
            <tag> postMessage </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>package.json详解</title>
      <link href="2020/11/11/Node/NodePackage.json/"/>
      <url>2020/11/11/Node/NodePackage.json/</url>
      
        <content type="html"><![CDATA[<h1 id="package-json详解"><a href="#package-json详解" class="headerlink" title="package.json详解"></a>package.json详解</h1><p><strong>name</strong>: 包名称，符合正则<code>/\w+/</code></p><p><strong>description</strong>：包详情</p><p><strong>author</strong>：包作者</p><p><strong>version</strong>：版本</p><p><strong>keywords</strong>：关键字数组</p><p><strong>maintainers</strong>：维护者数组，元素包含name [, name] [, web]</p><p><strong>licenses</strong>：许可证数组, 元素包含type和url</p><p><strong>repositories</strong>: 仓库托管地址数组, 元素包含type(仓库类型，如git)、url和path(相对于仓库的路径)</p><p><strong>dependencies</strong>: 生产环境所依赖的包, 关联数组，由包名称和版本号组成</p><p><strong>devDependencies</strong>: 开发环境所依赖的包，一个关联数组，由包名称和版本号组成</p><p><strong>main</strong>: 被require时的入口js文件</p><p><strong>node-echo</strong>: 命令行程序名和主模块位置</p><p><strong>bin</strong>: 用来指定各个内部命令对应的可执行文件的位置，可用于其他命令中，如scripts</p><pre><code class="highlight json">"bin": {    "someTool": "./bin/someTool.js"  }</code></pre><p><strong>config</strong>: 添加命令行的环境变量，在js文件中可以进行引用，如：</p><pre><code class="highlight js">process.env.npm_package_config_[key]</code></pre><p><strong>scripts</strong>: 定义脚本命令，使用<code>npm run [command]</code> 或 <code>npm [command]</code>  执行</p><pre><code class="highlight json">"scripts": {    "start": "node index.js",    "test": "tap test/*.js",    "myscript": "echo myscript"}</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Node </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Npm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Object原型梳理</title>
      <link href="2020/11/11/JavaScript/JavaScriptObjectPrototype/"/>
      <url>2020/11/11/JavaScript/JavaScriptObjectPrototype/</url>
      
        <content type="html"><![CDATA[<h1 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h1><p>最近我建议你读Vue框架的源码，你说你看不懂？什么？Object的方法不会？好吧，来，先来恶补一波Object原型吧~</p><p>Object是一种引用数据类型，也是一个构造函数。</p><h2 id="Object属性"><a href="#Object属性" class="headerlink" title="Object属性"></a>Object属性</h2><h3 id="1、Object-prototype"><a href="#1、Object-prototype" class="headerlink" title="1、Object.prototype"></a>1、Object.prototype</h3><p>Object的原型。Object原型处于原型链的顶端，是所有对象的原型。</p><h3 id="2、Object-name"><a href="#2、Object-name" class="headerlink" title="2、Object.name"></a>2、Object.name</h3><p>返回Object函数名。</p><h2 id="Object方法"><a href="#Object方法" class="headerlink" title="Object方法"></a>Object方法</h2><h3 id="1、Object-assign"><a href="#1、Object-assign" class="headerlink" title="1、Object.assign()"></a>1、Object.assign()</h3><p>将两个对象合并，并返回新的对象。在产生冲突时，后者的属性会覆盖前者。该方法属于浅拷贝。</p><pre><code class="highlight js"><span class="keyword">var</span> target={<span class="attr">name</span>: <span class="string">"failte"</span>, <span class="attr">age</span>: <span class="number">18</span>};<span class="keyword">var</span> source={<span class="attr">sex</span>: <span class="string">"man"</span>, <span class="attr">age</span>: <span class="number">22</span>};<span class="keyword">var</span> obj = <span class="built_in">Object</span>.assign(target, source);</code></pre><h3 id="2、Object-create"><a href="#2、Object-create" class="headerlink" title="2、Object.create()"></a>2、Object.create()</h3><p>以对象原型，创建一个新对象。第一个参数为原型对象，第二个参数为新描述符属性对象。</p><pre><code class="highlight js"><span class="keyword">var</span> obj = {    <span class="keyword">this</span>.a=<span class="string">"a"</span>;    <span class="keyword">this</span>.b=<span class="string">"b"</span>};<span class="keyword">var</span> nobj = <span class="built_in">Object</span>.create(obj, {    name: {        value: <span class="number">42</span>,        writable: <span class="literal">true</span>,        enumerable: <span class="literal">true</span>,        configurable: <span class="literal">true</span>    }});</code></pre><h3 id="3、Object-seal"><a href="#3、Object-seal" class="headerlink" title="3、Object.seal()"></a>3、Object.seal()</h3><p>封装对象。封装后的对象无法增删属性，但可以修改属性。可以通过<code>Object.isSealed()</code>方法判断对象是否被封装。</p><pre><code class="highlight js"><span class="keyword">var</span> obj = {<span class="attr">a</span>: <span class="number">1</span>};<span class="built_in">Object</span>.seal(obj);obj.b = <span class="string">'el'</span>;<span class="keyword">delete</span> obj.a;<span class="built_in">console</span>.log(obj);</code></pre><h3 id="4、Object-freeze"><a href="#4、Object-freeze" class="headerlink" title="4、Object.freeze()"></a>4、Object.freeze()</h3><p>冻结对象。被冻结的对象增删改属性。返回和传入的参数是同一对象。可以使用<code>Object.isFrozen()</code>方法判断对象是否被冻结。</p><pre><code class="highlight js"><span class="keyword">var</span> obj = {<span class="attr">a</span>: <span class="number">1</span>};<span class="built_in">Object</span>.freeze(obj);obj.b = <span class="number">2</span>;<span class="keyword">delete</span> obj.a;obj.a = <span class="number">10</span>;<span class="built_in">console</span>.log(obj);</code></pre><h3 id="5、Object-is"><a href="#5、Object-is" class="headerlink" title="5、Object.is()"></a>5、Object.is()</h3><p>判断两个对象是否相同。比较两方为 undefined、null、true、false、相同字符串、同一对象、NaN、+0、0、-0、数字时，返回true，其他情况返回false。</p><pre><code class="highlight js"><span class="keyword">var</span> obj = {<span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>};<span class="built_in">console</span>.log(<span class="built_in">Object</span>.is(<span class="literal">undefined</span>, <span class="literal">undefined</span>));<span class="built_in">console</span>.log(<span class="built_in">Object</span>.is(<span class="literal">null</span>, <span class="literal">null</span>));<span class="built_in">console</span>.log(<span class="built_in">Object</span>.is(<span class="literal">true</span>, <span class="literal">true</span>));<span class="built_in">console</span>.log(<span class="built_in">Object</span>.is(<span class="literal">false</span>, <span class="literal">false</span>));<span class="built_in">console</span>.log(<span class="built_in">Object</span>.is(<span class="string">'aaa'</span>, <span class="string">'aaa'</span>));<span class="built_in">console</span>.log(<span class="built_in">Object</span>.is(obj, obj));<span class="built_in">console</span>.log(<span class="built_in">Object</span>.is(<span class="literal">NaN</span>, <span class="literal">NaN</span>));<span class="built_in">console</span>.log(<span class="built_in">Object</span>.is(<span class="number">-0</span>, <span class="number">-0</span>));<span class="built_in">console</span>.log(<span class="built_in">Object</span>.is(+<span class="number">0</span>, +<span class="number">0</span>));<span class="built_in">console</span>.log(<span class="built_in">Object</span>.is(<span class="number">0</span>, <span class="number">0</span>));<span class="built_in">console</span>.log(<span class="built_in">Object</span>.is(<span class="number">100</span>, <span class="number">100</span>));</code></pre><h3 id="6、Object-preventExtensions"><a href="#6、Object-preventExtensions" class="headerlink" title="6、Object.preventExtensions()"></a>6、Object.preventExtensions()</h3><p>限制对象不可扩展。可以通过<code>Object.isExtensible()</code>判断对象是否被限制。</p><pre><code class="highlight js"><span class="keyword">var</span> obj = {<span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>};<span class="built_in">Object</span>.preventExtensions(obj);obj.c = <span class="number">3</span>;<span class="built_in">console</span>.log(obj);</code></pre><h3 id="7、Object-getOwnPropertyNames"><a href="#7、Object-getOwnPropertyNames" class="headerlink" title="7、Object.getOwnPropertyNames()"></a>7、Object.getOwnPropertyNames()</h3><p>返回对象可以遍历的属性的键名数组。</p><p>ES6的简洁写法为：<code>Object.keys(obj)</code></p><pre><code class="highlight js"><span class="keyword">var</span> obj = {<span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>};<span class="built_in">console</span>.log(<span class="built_in">Object</span>.keys(obj));</code></pre><h3 id="8、obj-hasOwnProperty"><a href="#8、obj-hasOwnProperty" class="headerlink" title="8、obj.hasOwnProperty()"></a>8、obj.hasOwnProperty()</h3><p>判断对象是否存在属性</p><p>ES6简洁写法：<code>key in obj</code></p><pre><code class="highlight js"><span class="keyword">var</span> obj = {<span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>};<span class="built_in">console</span>.log(obj.hasOwnProperty(<span class="string">'a'</span>)); <span class="comment">// ES5</span><span class="built_in">console</span>.log(<span class="string">'a'</span> <span class="keyword">in</span> obj); <span class="comment">//ES6</span></code></pre><h3 id="9、Object-getOwnPropertyDescriptor"><a href="#9、Object-getOwnPropertyDescriptor" class="headerlink" title="9、Object.getOwnPropertyDescriptor()"></a>9、Object.getOwnPropertyDescriptor()</h3><p>查询对象属性的描述符。</p><pre><code class="highlight js"><span class="keyword">var</span> obj = {<span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>};<span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptor(obj, <span class="string">'a'</span>));</code></pre><h3 id="10、Object-getOwnPropertyDescriptors"><a href="#10、Object-getOwnPropertyDescriptors" class="headerlink" title="10、Object.getOwnPropertyDescriptors()"></a>10、Object.getOwnPropertyDescriptors()</h3><p>查询对象的描述符。</p><pre><code class="highlight js"><span class="keyword">var</span> obj = {<span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>};<span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptors(obj));</code></pre><h3 id="11、Object-getOwnPropertySymbols"><a href="#11、Object-getOwnPropertySymbols" class="headerlink" title="11、Object.getOwnPropertySymbols()"></a>11、Object.getOwnPropertySymbols()</h3><p>返回对象所有的Symbol值属性键名数组。</p><pre><code class="highlight js"><span class="keyword">var</span> obj = {<span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>, [<span class="built_in">Symbol</span>(<span class="string">'a'</span>)]: <span class="number">3</span>};<span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertySymbols(obj));</code></pre><h3 id="12、Object-defineProperties"><a href="#12、Object-defineProperties" class="headerlink" title="12、Object.defineProperties()"></a>12、Object.defineProperties()</h3><p>定义对象属性。</p><pre><code class="highlight js"><span class="keyword">var</span> obj = {};<span class="built_in">Object</span>.defineProperties(obj, <span class="string">"val"</span>, {    value: <span class="literal">undefined</span>, <span class="comment">// 属性值，默认undefined</span>    writable: <span class="literal">false</span>, <span class="comment">// 是否可写，默认false</span>    enumerable: <span class="literal">false</span>, <span class="comment">// 是否可枚举，默认false</span>    configurable: <span class="literal">false</span>, <span class="comment">// 是否可配置，默认false</span>    <span class="keyword">get</span>: undefined, // 该属性的getter，默认undefined    <span class="keyword">set</span>: undefined, // 该属性的setter，默认undefined})</code></pre><h3 id="13、Object-values"><a href="#13、Object-values" class="headerlink" title="13、Object.values()"></a>13、Object.values()</h3><p>返回对象所有的属性值数组。</p><pre><code class="highlight js"><span class="keyword">var</span> obj = {<span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>};<span class="built_in">console</span>.log(<span class="built_in">Object</span>.values(obj));</code></pre><h3 id="14、Object-entries"><a href="#14、Object-entries" class="headerlink" title="14、Object.entries()"></a>14、Object.entries()</h3><p>返回对象所有属性与属性值的键值对列表。</p><pre><code class="highlight js"><span class="keyword">var</span> obj = {<span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>};<span class="built_in">console</span>.log(<span class="built_in">Object</span>.entries(obj));</code></pre><h3 id="15、Object-fromEntries"><a href="#15、Object-fromEntries" class="headerlink" title="15、Object.fromEntries()"></a>15、Object.fromEntries()</h3><p>把键值对列表转换为一个对象。与Object.entries()方法相反。</p><pre><code class="highlight js"><span class="keyword">var</span> obj = {<span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>};<span class="keyword">var</span> entries = <span class="built_in">Object</span>.entries(obj);<span class="built_in">console</span>.log(<span class="built_in">Object</span>.fromEntries(entries));</code></pre><h3 id="16、Object-getPrototypeOf"><a href="#16、Object-getPrototypeOf" class="headerlink" title="16、Object.getPrototypeOf()"></a>16、Object.getPrototypeOf()</h3><p>获取对象的原型。相当于直接获取obj.prototype。</p><pre><code class="highlight js"><span class="keyword">var</span> obj = {<span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>};<span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(obj));</code></pre><h3 id="17、Object-setPrototypeOf"><a href="#17、Object-setPrototypeOf" class="headerlink" title="17、Object.setPrototypeOf()"></a>17、Object.setPrototypeOf()</h3><p>设置对象的原型。相当于直接设置obj.prototype。</p><pre><code class="highlight js"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params"></span>) </span>{    <span class="keyword">this</span>.a = <span class="number">1</span>;    <span class="keyword">this</span>.b = <span class="number">2</span>;}<span class="keyword">var</span> obj = {};<span class="built_in">Object</span>.setPrototypeOf(obj, <span class="keyword">new</span> Animal());<span class="built_in">console</span>.log(obj.a);</code></pre><h3 id="18、Object-toString"><a href="#18、Object-toString" class="headerlink" title="18、Object.toString()"></a>18、Object.toString()</h3><h2 id="原型方法"><a href="#原型方法" class="headerlink" title="原型方法"></a>原型方法</h2><h3 id="1、apply"><a href="#1、apply" class="headerlink" title="1、apply()"></a>1、apply()</h3><p>可以修改this的指向，执行并返回改变指向后的函数的运行结果。</p><p>原函数的传参以数组的方式传入。</p><h3 id="2、arguments"><a href="#2、arguments" class="headerlink" title="2、arguments"></a>2、arguments</h3><p>返回当前函数的实参列表。</p><p>get/set</p><h3 id="3、bind"><a href="#3、bind" class="headerlink" title="3、bind()"></a>3、bind()</h3><p>可以修改this的指向，返回改变指向后的函数。</p><h3 id="4、call"><a href="#4、call" class="headerlink" title="4、call()"></a>4、call()</h3><p>可以修改this的指向，执行并返回改变指向后的函数的运行结果。</p><p>原函数的传参以多个参数的的方式传入。</p><p>get/set</p><h3 id="5、caller"><a href="#5、caller" class="headerlink" title="5、caller()"></a>5、caller()</h3><p>返回函数的调用环境。</p><h3 id="6、constructor"><a href="#6、constructor" class="headerlink" title="6、constructor()"></a>6、constructor()</h3><p>返回当前对象的构造函数。</p><h3 id="7、length"><a href="#7、length" class="headerlink" title="7、length"></a>7、length</h3><p>返回当前函数的形参个数。</p><h3 id="8、name"><a href="#8、name" class="headerlink" title="8、name"></a>8、name</h3><p>返回当前对象的名称。</p><h3 id="9、toString"><a href="#9、toString" class="headerlink" title="9、toString()"></a>9、toString()</h3><p>返回当前对象的字符串形式。</p><h3 id="10、Symbol-hasInstance"><a href="#10、Symbol-hasInstance" class="headerlink" title="10、Symbol.hasInstance"></a>10、Symbol.hasInstance</h3><p>判断某对象是否为某构造器的实例。用它自定义instanceof操作符在某个类上的行为。</p><p>获取Function原型的instanceof对应的方法</p><pre><code class="highlight js"><span class="keyword">var</span> func = <span class="function"><span class="params">()</span> =&gt;</span> {};<span class="keyword">var</span> obj = {};<span class="keyword">var</span> log1 = <span class="built_in">Function</span>[<span class="built_in">Symbol</span>.hasInstance](func, <span class="built_in">Function</span>);<span class="keyword">var</span> log2 = <span class="built_in">Object</span>[<span class="built_in">Symbol</span>.hasInstance](obj, <span class="built_in">Object</span>);<span class="built_in">console</span>.log(log1, log2)</code></pre><p>自定义类，并重写instanceof方法</p><pre><code class="highlight js"><span class="class"><span class="keyword">class</span> <span class="title">My</span> </span>{[<span class="built_in">Symbol</span>.hasInstance](instance) {<span class="built_in">console</span>.log(instance)<span class="keyword">return</span> <span class="literal">true</span>;}<span class="keyword">constructor</span>() {<span class="keyword">this</span>.a=<span class="number">1</span>}}<span class="keyword">var</span> my = <span class="keyword">new</span> My()<span class="built_in">console</span>.log(my <span class="keyword">instanceof</span> My)</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Object </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>节流和防抖</title>
      <link href="2020/11/11/JavaScript/%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81/"/>
      <url>2020/11/11/JavaScript/%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81/</url>
      
        <content type="html"><![CDATA[<h2 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h2><p>定义：在一段时间内，多次触发同一函数，只执行第一次触发的函数</p><h3 id="1、实现"><a href="#1、实现" class="headerlink" title="1、实现"></a>1、实现</h3><p>如下实现的关键是靠一个标识flag达成，只有标识为true才被允许创建一个定时器，设置完后将标识改为false防止再次创建，只有定时器所定的回调执行后，标识才会被设置回true</p><pre><code class="highlight javascript"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">callback,delay</span>)</span>{  <span class="keyword">let</span> flag = <span class="literal">true</span>;  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{    <span class="keyword">if</span>(!flag) <span class="keyword">return</span>    flag = <span class="literal">false</span>    setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>{      callback()      flag = <span class="literal">true</span>    },delay)  }}</code></pre><h3 id="2、应用"><a href="#2、应用" class="headerlink" title="2、应用"></a>2、应用</h3><ul><li>滚动加载，加载更多或者滚到底部监听</li><li>频繁点击按钮</li></ul><h2 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h2><p>定义：在函数被触发的n秒内，如果又被触发，就会重新计时</p><h3 id="1、实现-1"><a href="#1、实现-1" class="headerlink" title="1、实现"></a>1、实现</h3><p>如下实现关键靠一个标识flag达成，只有标识为true才设置一个定时器，设置完后将标识改为false，只有定时器执行后，标识才会被设置回true</p><pre><code class="highlight javascript"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">callback,delay</span>)</span>{  <span class="keyword">let</span> timer = <span class="literal">null</span>;  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{    clearTimeout(timer)  timer = setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>{      callback()    },delay)  }}</code></pre><h3 id="2、应用-1"><a href="#2、应用-1" class="headerlink" title="2、应用"></a>2、应用</h3><ul><li>input输入动作触发搜索事件</li><li>验证</li><li>resize事件</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Object </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字符串拼接性能优化</title>
      <link href="2020/10/09/JavaScript/JavaScriptStringBuffer/"/>
      <url>2020/10/09/JavaScript/JavaScriptStringBuffer/</url>
      
        <content type="html"><![CDATA[<h1 id="字符串拼接性能优化"><a href="#字符串拼接性能优化" class="headerlink" title="字符串拼接性能优化"></a>字符串拼接性能优化</h1><p>在Java中，对大量字符串处理时存在StringBuilder、StringBuffer来进行优化，那么JavaScript的String是否也能进行优化呢？</p><p>这里以Java的StringBuffer为命名实现了一个JavaScript的StringBuffer。</p><h2 id="传统String拼接"><a href="#传统String拼接" class="headerlink" title="传统String拼接"></a>传统String拼接</h2><ul><li><strong><code>ECMAScript</code></strong> 的字符串的值 <strong>不能改变</strong>。</li></ul><h3 id="字符串拼接过程"><a href="#字符串拼接过程" class="headerlink" title="字符串拼接过程"></a>字符串拼接过程</h3><pre><code class="highlight js">&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">var</span> str = <span class="string">"hello "</span>;&nbsp;&nbsp;&nbsp;&nbsp;str += <span class="string">"world"</span>;</code></pre><p>以上代码的执行步骤如下：</p><ul><li>1、创建存储 “hello “ 的字符串。</li><li>2、创建存储 “world” 的字符串。</li><li>3、创建存储连接结果的字符串。</li><li>4、把 str 的当前内容复制到结果中。</li><li>5、把 “world” 复制到结果中。</li><li>6、更新 str，使它指向结果。</li></ul><p>每次完成字符串连接都会执行步骤 2 到 6，使得这种操作非常消耗资源。如果重复这一过程几百次，甚至几千次，就会造成性能问题。</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><h3 id="数组解决方法"><a href="#数组解决方法" class="headerlink" title="数组解决方法"></a>数组解决方法</h3><p>用 <code>Array</code> 对象存储字符串，然后用 <code>join()</code> 方法创建最后的字符串。</p><pre><code class="highlight js"><span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>();arr[<span class="number">0</span>] = <span class="string">"hello "</span>;arr[<span class="number">1</span>] = <span class="string">"world"</span>;<span class="keyword">var</span> str = arr.join(<span class="string">""</span>);</code></pre><p>以上代码的执行步骤如下：</p><ul><li>1、创建数组</li><li>2、将需要拼接的字符串加入数组</li><li>3、调用join方法，创建存储结果的字符串，将数组中的元素全部拼接到字符串使用该方法只在调用 join() 方法时才会发生连接操作。缺陷：这段代码不能确切反映出它的意图。</li></ul><h4 id="StringBuffer类打包"><a href="#StringBuffer类打包" class="headerlink" title="StringBuffer类打包"></a>StringBuffer类打包</h4><ul><li>为了解决传统方法存在的缺陷，可以将传统方法类打包为StringBuffer，专门解决拼接问题。</li><li>该类存在两个方法，即 append() 和 toString() 方法。</li></ul><pre><code class="highlight javascript"><span class="function"><span class="keyword">function</span> <span class="title">StringBuffer</span>(<span class="params">str</span>)</span>{    <span class="keyword">var</span> string = str ? [str] : [];    <span class="keyword">if</span>(!StringBuffer.prototype.append){        StringBuffer.prototype.append=<span class="function"><span class="keyword">function</span>(<span class="params">str</span>)</span>{            string.push(str);        }        StringBuffer.prototype.toString=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{            <span class="keyword">return</span> string.join(<span class="string">""</span>);        }    }}</code></pre><p><code>append()</code> 是自定义方法，接收一个参数，并将该参数添加到内部数组中，<code>toString()</code>已经在继承Object原型存在，需要重写，该方法调用数组的<code>join()</code>方法，返回数组拼接后字符串。</p><p>使用demo：</p><pre><code class="highlight javascript"><span class="keyword">var</span> sb=<span class="keyword">new</span> StringBuffer(<span class="string">"failte"</span>);<span class="built_in">console</span>.log(sb);<span class="built_in">console</span>.log(sb.toString());sb.append(<span class="string">"'s"</span>);<span class="built_in">console</span>.log(sb.toString());</code></pre><h4 id="性能对比："><a href="#性能对比：" class="headerlink" title="性能对比："></a>性能对比：</h4><pre><code class="highlight javascript"><span class="function"><span class="keyword">function</span> <span class="title">StringBuffer</span>(<span class="params">str</span>)</span>{    <span class="keyword">var</span> string = str ? [str] : [];    <span class="keyword">if</span>(!StringBuffer.prototype.append) {        StringBuffer.prototype.append = <span class="function"><span class="keyword">function</span> (<span class="params">str</span>) </span>{            string.push(str);        }        StringBuffer.prototype.toString = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{            <span class="keyword">return</span> string.join(<span class="string">""</span>);        }    }}<span class="comment">// 传统拼接</span><span class="keyword">var</span> str1 = <span class="string">""</span>;<span class="keyword">var</span> d1 = <span class="built_in">Date</span>.now(); <span class="comment">// 时刻1</span><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i&lt;<span class="number">100000</span>; i++){    str1 += i;}<span class="keyword">var</span> t1 = <span class="built_in">Date</span>.now() - d1; <span class="comment">// 时间间隔1</span><span class="comment">// StringBuffer拼接</span><span class="keyword">var</span> str2 = <span class="keyword">new</span> StringBuffer(<span class="string">""</span>);<span class="keyword">var</span> d2 = <span class="built_in">Date</span>.now(); <span class="comment">// 时刻2</span><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i&lt;<span class="number">100000</span>; i++){    str2.append(i);}<span class="keyword">var</span> t2 = <span class="built_in">Date</span>.now()-d2; <span class="comment">// 时间间隔2</span><span class="built_in">console</span>.log(<span class="string">"t1: "</span>, t1, <span class="string">"t2: "</span>, t2);</code></pre><p><strong>测试结果</strong>：使用两种方法测试拼接100000个字符串，三次结果如下：</p><ul><li>Round 1：String拼接：26msStringBuffer拼接：5ms</li><li>Round 2：String拼接：24msStringBuffer拼接：5ms</li><li>Round 3：String拼接：28msStringBuffer拼接：5ms</li></ul><p>测试完成。通过比较，可以很明显的发现，StringBuffer拼接的速度比String拼接速度快5倍。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> String </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript之函数尾调用与函数尾递归</title>
      <link href="2020/09/21/JavaScript/JavaScripitFunctionTail-Call/"/>
      <url>2020/09/21/JavaScript/JavaScripitFunctionTail-Call/</url>
      
        <content type="html"><![CDATA[<h1 id="函数尾调用与函数尾递归"><a href="#函数尾调用与函数尾递归" class="headerlink" title="函数尾调用与函数尾递归"></a>函数尾调用与函数尾递归</h1><p>偶然重新学习ES6，发现原来在函数方面还有添加尾调用这个特性，尾调用可以减少一次函数调用帧的生成，而众所周知函数递归存在一个内存消耗的问题，如果把尾调用加入到递归中会怎么样呢……</p><h2 id="尾调用"><a href="#尾调用" class="headerlink" title="尾调用"></a>尾调用</h2><p>函数调用会在内存形成一个调用帧，保存调用位置和内部变量等信息。</p><p>一个函数内存在其他函数调用，其他函数就会在这个函数上形成调用帧，所有的调用帧形成了一个调用栈。</p><p>为尾调用是指在函数的最后一步操作时，返回另一个函数的调用，这个时候，由于不会用到调用的位置和内部变量等信息，不需要保留外层函数的调用帧。</p><p>尾调用：</p><pre><code class="highlight js"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>) </span>{    <span class="keyword">return</span> B() <span class="comment">// 尾调用</span>}<span class="function"><span class="keyword">function</span> <span class="title">B</span>(<span class="params"></span>) </span>{    <span class="keyword">return</span> C() + <span class="number">1</span>; <span class="comment">// 最后一步操作不是函数调用</span>}<span class="function"><span class="keyword">function</span> <span class="title">C</span>(<span class="params"></span>)</span>{    <span class="keyword">var</span> val = D()    <span class="keyword">return</span> val; <span class="comment">// 最后一步操作不是函数调用</span>}<span class="function"><span class="keyword">function</span> <span class="title">D</span>(<span class="params"></span>)</span>{    E() <span class="comment">// 最后一步操作不是函数调用</span>}<span class="function"><span class="keyword">function</span> <span class="title">E</span>(<span class="params"></span>)</span>{    <span class="built_in">console</span>.log(<span class="string">'只有A是尾调用'</span>) <span class="comment">// 最后一步操作不是函数调用</span>}</code></pre><h2 id="尾递归"><a href="#尾递归" class="headerlink" title="尾递归"></a>尾递归</h2><p>函数递归对内存消耗很大，每次递归都会产生一个调用帧，而整个递归下来会产生很多的调用帧，很容易出现栈溢出的问题。</p><p>尾调用是可以有效减少执行栈的，将尾调用和递归结合，有可能将复杂度为O(n)的计算变成O(1)。</p><p>非尾调用</p><pre><code class="highlight js"><span class="function"><span class="keyword">function</span> <span class="title">Fibonacci</span> (<span class="params">n</span>) </span>{    <span class="keyword">if</span> ( n &lt;= <span class="number">1</span> ) {<span class="keyword">return</span> <span class="number">1</span>};    <span class="keyword">return</span> Fibonacci(n - <span class="number">1</span>) + Fibonacci(n - <span class="number">2</span>);}Fibonacci(<span class="number">10</span>) <span class="comment">// 89</span>Fibonacci(<span class="number">100</span>) <span class="comment">// 超时</span>Fibonacci(<span class="number">500</span>) <span class="comment">// 超时</span></code></pre><p>尾调用</p><pre><code class="highlight js"><span class="function"><span class="keyword">function</span> <span class="title">Fibonacci2</span> (<span class="params">n , ac1 = <span class="number">1</span> , ac2 = <span class="number">1</span></span>) </span>{    <span class="keyword">if</span>( n &lt;= <span class="number">1</span> ) {<span class="keyword">return</span> ac2};    <span class="keyword">return</span> Fibonacci2 (n - <span class="number">1</span>, ac2, ac1 + ac2);}Fibonacci2(<span class="number">100</span>) <span class="comment">// 573147844013817200000</span>Fibonacci2(<span class="number">1000</span>) <span class="comment">// 7.0330367711422765e+208</span>Fibonacci2(<span class="number">10000</span>) <span class="comment">// Infinity</span></code></pre><p>建议在ES6中对递归进行尾调用优化。</p><h2 id="兼容"><a href="#兼容" class="headerlink" title="兼容"></a>兼容</h2><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Function </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript闭包详解</title>
      <link href="2020/09/14/JavaScript/JavaScriptClosure/"/>
      <url>2020/09/14/JavaScript/JavaScriptClosure/</url>
      
        <content type="html"><![CDATA[<h4 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h4><p>首先来了解一下Javascript中变量的作用域，除了常见的普通变量外，<strong>对象</strong>和<strong>函数</strong>也是一种变量。变量分为局部变量和全局变量。</p><h5 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h5><p>局部变量就是指在<strong>函数内部</strong>定义的变量，作用域是函数内部网，此变量通常只能在函数内部访问，和外界是区分开的，所以变量名即使和外部的<strong>重复</strong>，也是两个独立的变量，不会相互影响。局部变量在函数执行是创建，执行完后<strong>销毁</strong>。</p><h5 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h5><p>全局变量就是函数外部定义的变量，作用域是网页中的所有脚本和函数，它们都能够访问，全局变量是页面加载时创建，页面关闭后销毁。</p><p>综合举例：</p><pre><code class="highlight js"><span class="keyword">var</span> a = <span class="number">0</span>;<span class="function"><span class="keyword">function</span> <span class="title">fun1</span>(<span class="params"></span>) </span>{<span class="keyword">var</span> a = <span class="number">1</span>;b = <span class="number">2</span>;}</code></pre><p>这里的 <code>var a = 0;</code> 就是全局变量，<code>var a = 1;</code> 是局部变量，虽然名字重复，但这里是两个独立变量，但是还是不建议出现重复，提高代码可读性；<code>b = 2;</code> 也是<strong>全局变量</strong>，因为规定函数内部申明的变量，如果不加 <code>var</code>，即会被认为是全局变量，尤其这点需要小心。</p><h4 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h4><p>先通俗的总结一下，闭包就是一个可以访问其他函数内部变量的<strong>函数</strong>，即一个定义在函数内部的函数，也叫<strong>内嵌函数</strong>。</p><p>其次，是闭包的作用，因为通常情况函数内部变量是无法在外部访问的，即全局变量也局部变量的区别，而闭包，就实现了能在外部访问某函数内部变量的功能，让这些变量值始终保存在<strong>内存</strong>中。</p><p>然后，来讲一下如何实现闭包。有以下代码：</p><pre><code class="highlight js"><span class="function"><span class="keyword">function</span> <span class="title">fun1</span>(<span class="params"></span>) </span>{<span class="keyword">var</span> a = <span class="number">1</span>;           <span class="comment">//定义一个局部变量</span><span class="function"><span class="keyword">function</span> <span class="title">fun2</span>(<span class="params"></span>) </span>{    <span class="comment">//这里的 fun2() 就是闭包</span>alert(a);    <span class="comment">//fun2() 是 fun1()的子函数，所以能访问之前定义的局部变量，这个是关键</span>}<span class="keyword">return</span> fun2;         <span class="comment">//然后通过这里，把之前得到的局部变量成功返回到外部去</span>}fun1();                      <span class="comment">//正常执行函数</span><span class="keyword">var</span> result = fun1();         <span class="comment">//将内部变量传递出去，传给变量 result</span>result();                    <span class="comment">//执行这个函数实现对局部变量的访问</span></code></pre><p>当然形式不止这一种，万变不离其宗，最后实现的功能是一样的，例如下面的方法也是可行的：</p><pre><code class="highlight js"><span class="function"><span class="keyword">function</span> <span class="title">fun1</span>(<span class="params"></span>) </span>{<span class="keyword">var</span> a = <span class="number">1</span>;<span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{alert(a);};}fun1();<span class="keyword">var</span> result = fun1();result();</code></pre><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>也许在很多文章中都能看到这句话“避免滥用闭包”，的确，由于闭包会使一些变量一直保存在内存中，所以如果大量使用的话就会消耗大量内存，影响网页性能。</p><p>同时，由于闭包的特性，还会在外部改变函数的内部变量值，有时候这是很危险的，举个例子：</p><pre><code class="highlight js"><span class="function"><span class="keyword">function</span> <span class="title">fun1</span>(<span class="params"></span>) </span>{<span class="keyword">var</span> a = <span class="number">1</span>;<span class="function"><span class="keyword">function</span> <span class="title">fun2</span>(<span class="params"></span>) </span>{a++;}alert(a);<span class="keyword">return</span> fun2;}fun1();                   <span class="comment">//函数正常执行，输出 1</span><span class="keyword">var</span> change = fun1();change();                 <span class="comment">//在外部执行这个函数后，函数内部变量 a 的值就被改变了，输出 2</span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Closure </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript之正则</title>
      <link href="2020/09/10/JavaScript/JavaScriptRegExp/"/>
      <url>2020/09/10/JavaScript/JavaScriptRegExp/</url>
      
        <content type="html"><![CDATA[<h2 id="JavaScript正则"><a href="#JavaScript正则" class="headerlink" title="JavaScript正则 "></a>JavaScript正则 <span id="home"></span></h2><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><strong><a href="#1">构造 </a></strong></li><li><strong><a href="#2">查找模式 </a></strong><ul><li><strong><a href="#2.1">方括号 </a></strong></li><li><strong><a href="#2.2">元字符 </a></strong></li><li><strong><a href="#2.3">量词 </a></strong></li><li><strong><a href="#2.4">RegExp 对象方法 </a></strong></li><li><strong><a href="#2.5">支持正则表达式的 String 对象的方法 </a></strong></li><li><strong><a href="#2.6">方括号 </a></strong></li></ul></li><li><strong><a href="#3">常用正则式 </a></strong><ul><li><strong><a href="#3.1">验证姓名 </a></strong></li><li><strong><a href="#3.2">验证密码 </a></strong></li><li><strong><a href="#3.3">验证 Email </a></strong></li><li><strong><a href="#3.4">验证身份证 </a></strong></li><li><strong><a href="#3.5">验证手机号 </a></strong></li></ul></li><li><strong><a href="#4">常见的坑 </a></strong></li></ul><hr><h2 id="构造正则表达式"><a href="#构造正则表达式" class="headerlink" title="构造正则表达式 "></a>构造正则表达式 <span id="1"></span></h2><p>1、使用new创建对象</p><pre><code>new RegExp(pattern,modifiers)</code></pre><p>2、pattern模式</p><pre><code>/pattern/modifierspattern（模式） 描述了表达式的模式modifiers(修饰符) 用于指定全局匹配(g)、区分大小写的匹配(i)和多行匹配(m)</code></pre><hr><h2 id="正则查找模式"><a href="#正则查找模式" class="headerlink" title="正则查找模式 "></a>正则查找模式 <span id="2"></span></h2><p>1、方括号：用于查找某个范围内的字符 <span id="2.1"></span></p><pre><code>[abc]    查找方括号之间的任何字符。[^abc]    查找任何不在方括号之间的字符。[0-9]    查找任何从 0 至 9 的数字。[a-z]    查找任何从小写 a 到小写 z 的字符。[A-Z]    查找任何从大写 A 到大写 Z 的字符。[A-z]    查找任何从大写 A 到小写 z 的字符。[adgk]    查找给定集合内的任何字符。[^adgk]    查找给定集合外的任何字符。(red|blue|green)    查找任何指定的选项。</code></pre><p>2、元字符：拥有特殊含义的字符 <span id="2.2"></span></p><pre><code>.    查找单个字符，除了换行和行结束符。\w    查找单词字符。\W    查找非单词字符。\d    查找数字。\D    查找非数字字符。\s    查找空白字符。\S    查找非空白字符。\b    匹配单词边界。\B    匹配非单词边界。\0    查找 NUL 字符。\n    查找换行符。\f    查找换页符。\r    查找回车符。\t    查找制表符。\v    查找垂直制表符。\xxx    查找以八进制数 xxx 规定的字符。\xdd    查找以十六进制数 dd 规定的字符。\uxxxx    查找以十六进制数 xxxx 规定的 Unicode 字符。</code></pre><p>3、量词 <span id="2.3"></span></p><pre><code>n+    匹配任何包含至少一个 n 的字符串。n*    匹配任何包含零个或多个 n 的字符串。n?    匹配任何包含零个或一个 n 的字符串。n{X}    匹配包含 X 个 n 的序列的字符串。n{X,Y}    匹配包含 X 至 Y 个 n 的序列的字符串。n{X,}    匹配包含至少 X 个 n 的序列的字符串。n$    匹配任何结尾为 n 的字符串。^n    匹配任何开头为 n 的字符串。?=n    匹配任何其后紧接指定字符串 n 的字符串。?!n    匹配任何其后没有紧接指定字符串 n 的字符串。</code></pre><p>4、RegExp 对象方法 <span id="2.4"></span></p><pre><code>compile    编译正则表达式。exec    检索字符串中指定的值。返回找到的值，并确定其位置。test    检索字符串中指定的值。返回 true 或 false。</code></pre><p>5、支持正则表达式的 String 对象的方法 <span id="2.5"></span></p><pre><code>search    检索与正则表达式相匹配的值。match    找到一个或多个正则表达式的匹配。replace    替换与正则表达式匹配的子串。split    把字符串分割为字符串数组。</code></pre><hr><h2 id="常用的正则式"><a href="#常用的正则式" class="headerlink" title="常用的正则式 "></a>常用的正则式 <span id="3"></span></h2><p>1、验证姓名 <span id="3.1"></span></p><p>2到9位中文昵称</p><pre><code>^[\u4e00-\u9fa5]{2,9}$</code></pre><p>2、验证密码 <span id="3.2"></span></p><p>只能是字母、数字和下划线，长度不限制：</p><pre><code>^\w+$</code></pre><p>允许小写字母a-z、大写字母A-Z、数字0-9、下划线_、 连接符-，且长度在6-18位数：</p><pre><code>/^[a-zA-Z0-9_-]{6,18}$/</code></pre><p>必须包含数字+小写字母+大写字母的密码，且长度在8-10位之间：</p><pre><code>^(?=.*\d)(?=.*[a-z])(?=.*[A-Z]).{8,10}$</code></pre><p>3、验证 Email <span id="3.3"></span></p><p>允许有一个字符符合[A-Za-z0-9_]之后可以为[A-Za-z0-9_-+.] + @ + 允许有一个字符符合 [A-Za-z0-9_] 之后可以为 [A-Za-z0-9_-.] + . + 允许有一个字符符合 [A-Za-z0-9_] 之后可以有 [A-Za-z0-9_-.] 的邮箱：</p><pre><code>^\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*$</code></pre><p>4、验证身份证 <span id="3.4"></span></p><p>18位身份证号，尾数是数字或者字母X：</p><pre><code>^(\d{6})(\d{4})(\d{2})(\d{2})(\d{3})([0-9]|X)$</code></pre><p>15或者18位身份证号，尾数可以是数字及X或者x：</p><pre><code>(^\d{15}$)|(^\d{18}$)|(^\d{17}(\d|X|x)$)</code></pre><p>5、验证手机号 <span id="3.5"></span></p><p>以 1 开头，第二位数是 3/4/5/7/8 的 11 位手机号码：</p><pre><code>^1[3,4,5,7,8,9]\d{9}$</code></pre><p>移动号码：</p><pre><code>^134[0-8]\d{7}$|^(?:13[5-9]|147|15[0-27-9]|178|1703|1705|1706|18[2-478])\d{7,8}$</code></pre><p>电信号码：</p><pre><code>^(?:133|153|1700|1701|1702|177|173|18[019])\d{7,8}$</code></pre><p>联通号码：    ^(?:13[0-2]|145|15[56]|176|1704|1707|1708|1709|171|18[56])&lt;d&gt;7,8</p><hr><h2 id="常见的坑"><a href="#常见的坑" class="headerlink" title="常见的坑 "></a>常见的坑 <span id="4"></span></h2><p>在[A-Z]与[a-z]中存在其他字符，[A-z]的准确表述为</p><pre><code>[A-Z][a-z]</code></pre><p><a href="https://www.w3cschool.cn/javascript/javascript-expression.html" target="_blank" rel="noopener">w3c学习链接</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RegExp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript逻辑运算符“&amp;&amp;”和“||”短路原则的应用</title>
      <link href="2020/08/30/JavaScript/JavaScriptLogicCompute/"/>
      <url>2020/08/30/JavaScript/JavaScriptLogicCompute/</url>
      
        <content type="html"><![CDATA[<h4 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h4><p>在Javascript中，有逻辑运算符 <code>与 &amp;&amp;</code>, <code>或 ||</code>, <code>非 !</code>，常在条件句或循环中进行逻辑判断。</p><p>例如：</p><pre><code class="highlight js"><span class="keyword">var</span> a = <span class="number">1</span>, b = <span class="number">1</span>, c = <span class="number">2</span>;<span class="keyword">if</span> (a = b &amp;&amp; (b = c || a != c)){alert(<span class="string">"true"</span>);} <span class="keyword">else</span> {alert(<span class="string">"false"</span>);}</code></pre><p>括号中表达式值为<strong>真</strong>，最后提示“true”。</p><h4 id="短路原则"><a href="#短路原则" class="headerlink" title="短路原则"></a>短路原则</h4><p>在逻辑运算中，这是一个通用的原则，这是由于表达式从左到右执行的特性，为了减少运算量而给运算器规定的操作。主要针对 <code>&amp;&amp;</code> 和 <code>||</code> 两种运算。</p><ul><li><p><code>&amp;&amp;</code> 的判断是<strong>同真为真，一假为假</strong>，则运算如果左边的表达式值为 <code>false</code>，那么就不会再执行右边的表达式了，如果左表达式为 <code>true</code>，就会继续执行右表达式；</p></li><li><p><code>||</code> 的判断是<strong>一真为真，同假为假</strong>，则运算如果坐表达式值为 <code>true</code>，那么就不用执行右边的表达式了，如果左表达式为 <code>false</code>，就会继续执行右表达式；</p></li></ul><p>举例说明：</p><pre><code class="highlight js">(<span class="number">1</span> == <span class="number">1</span>) &amp;&amp; alert(<span class="string">"msg1"</span>);(<span class="number">1</span> != <span class="number">1</span>) &amp;&amp; alert(<span class="string">"msg2"</span>);(<span class="number">1</span> == <span class="number">1</span>) || alert(<span class="string">"msg3"</span>);(<span class="number">1</span> != <span class="number">1</span>) || alert(<span class="string">"msg4"</span>);</code></pre><p>结果是提示<strong>“msg1”</strong>和<strong>“msg4”</strong>。原理如上述。</p><p>因此，如果有以下表达式：</p><pre><code class="highlight js"><span class="keyword">var</span> a = <span class="number">9</span>;<span class="keyword">if</span> (a &gt; <span class="number">0</span>){alert(<span class="string">"true"</span>);} <span class="keyword">else</span>{alert(<span class="string">"false"</span>);}</code></pre><p>也许你会使用<strong>三目运算</strong>简化成这样：</p><pre><code class="highlight js"><span class="keyword">var</span> a = <span class="number">9</span>;(a &gt; <span class="number">0</span>) ? alert(<span class="string">"true"</span>) : alert(<span class="string">"false"</span>);</code></pre><p>其实也可以这样写：</p><pre><code class="highlight js"><span class="keyword">var</span> a = <span class="number">9</span>;(a &gt; <span class="number">0</span>) &amp;&amp; alert(<span class="string">"true"</span>);(a &gt; <span class="number">0</span>) || alert(<span class="string">"false"</span>);</code></pre><h4 id="Javascript中的应用"><a href="#Javascript中的应用" class="headerlink" title="Javascript中的应用"></a>Javascript中的应用</h4><p>在javascript中，只有<code>对象(Object)</code>和布尔值<code>true</code>为真，其它例如 <code>undefined</code>, <code>NaN</code>, <code>false</code> 等，值为 <code>false</code>。为被定义的对象或未赋值变量也是 <code>false</code>，因为其值都是 <code>undefined</code>，这里就可以应用于检查某变量是否<strong>已定义</strong>。</p><p>举例说明：</p><pre><code class="highlight js"><span class="keyword">var</span> a = <span class="number">1</span>;<span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();<span class="keyword">var</span> b;a &amp;&amp; alert(<span class="string">"defined"</span>);       <span class="comment">//已定义a，提示“defined”</span>o &amp;&amp; alert(<span class="string">"defined"</span>);       <span class="comment">//已定义对象o，提示“defined”</span><span class="built_in">Object</span> &amp;&amp; alert(<span class="string">"defined"</span>);  <span class="comment">//Object是一个已知的全局对象，提示“defined”</span>b || alert(<span class="string">"not defined"</span>);   <span class="comment">//b未赋值，提示“not defined”</span>p || alert(<span class="string">"not defined"</span>);   <span class="comment">//未定义p，提示“not defined”</span></code></pre><p>除了这个也能衍生出其它相同原理的应用，类似于判断赋值 <code>var  a = (b &gt; 0) &amp;&amp; '9'</code> 或判断定义变量 <code>var abc = abc || ""</code> 等。</p><p>js中使用这种方法可以减少代码量，提示性能，但同时也降低了代码<strong>可读性</strong>，比如个人觉得还是看以下代码比较舒适：</p><pre><code class="highlight js"><span class="keyword">var</span> a = <span class="number">1</span>;<span class="keyword">if</span> (a &gt; <span class="number">1</span>){alert(<span class="string">"true"</span>);}</code></pre><p>方法的选择就要视情况而权衡了。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Operator </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript设计模式之发布&amp;订阅模式</title>
      <link href="2020/08/27/JavaScript/JavaScriptObseverMode/"/>
      <url>2020/08/27/JavaScript/JavaScriptObseverMode/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="发布-amp-订阅模式"><a href="#发布-amp-订阅模式" class="headerlink" title="发布&amp;订阅模式"></a>发布&amp;订阅模式</h1><p>面试官：你能说说发布&amp;订阅模式和观察者模式有什么区别吗？懵逼了吗？来，上车~</p><h2 id="发布-amp-订阅模式满足的条件"><a href="#发布-amp-订阅模式满足的条件" class="headerlink" title="发布&amp;订阅模式满足的条件"></a>发布&amp;订阅模式满足的条件</h2><p>1、存储多个事件</p><p>2、每个事件可以订阅多个函数</p><p>3、提供订阅、取消订阅、触发三种方法</p><h2 id="on-事件绑定"><a href="#on-事件绑定" class="headerlink" title="$on 事件绑定"></a>$on 事件绑定</h2><p>1、语法：<code>$on(eventName, callback)</code></p><p>2、分析：</p><ul><li><p>一个事件对应多个事件函数</p></li><li><p>分析绑定的这个事件名称在事件仓库中是否存在 如果存在则直接将事件函数添加到数组中去</p></li><li><p>如果不存在则创建一个数组然后将事件函数添加到数组中去</p></li></ul><h2 id="emit-事件触发"><a href="#emit-事件触发" class="headerlink" title="$emit 事件触发"></a>$emit 事件触发</h2><p>1、语法：<code>$emit(eventName, params)</code></p><p>2、分析：</p><ul><li><p>判断当前事件名称是否存在</p></li><li><p>如果存在，则遍历数组中所有的函数，将参数传递到数组的函数中，并执行这些函数</p></li></ul><h2 id="off-事件解绑"><a href="#off-事件解绑" class="headerlink" title="$off  事件解绑"></a>$off  事件解绑</h2><p>1、语法：<code>$off(eventName, callback)</code></p><p>2、分析：</p><ul><li><p>判断当前事件名称是否存在</p></li><li><p>如果存在，则再判断第二个参数是否存在</p></li><li><p>如果第二个参数也存在，则解绑对应的函数</p></li><li><p>如果第二个参数不存在则解绑全部</p></li></ul><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>subscribe.js</p><pre><code class="highlight js"><span class="keyword">const</span> eventList = {};<span class="keyword">const</span> $on = <span class="function">(<span class="params">eventName,callback</span>) =&gt;</span> {    <span class="keyword">if</span>(!eventList[eventName]) {        eventList[eventName] = [];    }    eventList[eventName].push(callback);}<span class="keyword">const</span> $emit = <span class="function">(<span class="params">eventName,params</span>) =&gt;</span> {    <span class="keyword">if</span>(eventList[eventName]) {        eventList[eventName].forEach(<span class="function">(<span class="params">cb</span>) =&gt;</span> {            cb(params);        })    }}<span class="keyword">const</span> $off = <span class="function">(<span class="params">eventName,callback</span>) =&gt;</span> {    <span class="keyword">if</span>(eventList[eventName]) {        <span class="keyword">if</span>(callback) {            <span class="keyword">let</span> index = eventList[eventName].indexOf(callback);            eventList[eventName].splice(index,<span class="number">1</span>);        } <span class="keyword">else</span> {            eventList[eventName].length = <span class="number">0</span>;        }    }}<span class="keyword">export</span> <span class="keyword">default</span> {    $on,    $emit,    $off}</code></pre><h2 id="观察者模式和发布订阅模式"><a href="#观察者模式和发布订阅模式" class="headerlink" title="观察者模式和发布订阅模式"></a>观察者模式和发布订阅模式</h2><p>1、观察者模式</p><p>观察者模式主要参与者为主题Subject，观察者Observer。</p><p>Subject和Observer具有松耦合的关系。</p><p>在Subject发生变化时，通知Observer。</p><p>2、订阅模式</p><p>订阅模式的主要参与者为发布者Publisher、订阅者Subscriber、调度中心Broker。</p><p>Publisher和Subscriber没有直接关系。两者间需要通过Broker进行沟通。</p><p>Publisher发布时，会推送到Broker，调度中心负责管理订阅，会将Publisher发布的消息通知给Subscriber。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Patterns </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript核心：两链一包</title>
      <link href="2020/08/23/JavaScript/JavaScriptPrototype&amp;Closure/"/>
      <url>2020/08/23/JavaScript/JavaScriptPrototype&amp;Closure/</url>
      
        <content type="html"><![CDATA[<h1 id="JavaScript核心：两链一包"><a href="#JavaScript核心：两链一包" class="headerlink" title="JavaScript核心：两链一包"></a>JavaScript核心：两链一包</h1><h2 id="作用域与闭包"><a href="#作用域与闭包" class="headerlink" title="作用域与闭包"></a>作用域与闭包</h2><h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p>1、变量提升</p><ul><li>浏览器解析器在解析js时，预解析变量并将变量名提升到作用域的行为</li><li>函数与变量同时声明为一个字符时，预解析时函数有高优先级</li></ul><p>2、全局变量</p><ul><li>在全局声明的变量，作用域在全局</li><li>函数内有未使用声明符声明的变量时，这个变量会被浏览器转换为全局变量</li></ul><p>3、局部变量</p><ul><li>在函数内声明的变量，作用域在函数内</li><li>函数的传参作用域在函数内，传参与全局变量不是同一个变量</li></ul><p>3、作用域链</p><ul><li>执行函数时，总是先从函数内部找局部变量</li><li>若没有，则会依次向上级作用域寻找变量</li></ul><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p><strong>闭包就是访问函数内部私有属性或私有函数的公有方法</strong></p><ul><li>1、函数拥有局部作用域，无法在外部访问局部的属性或方法</li></ul><pre><code class="highlight javascript"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>{    <span class="keyword">var</span> a=<span class="string">"a"</span>;}<span class="built_in">console</span>.log(a);<span class="comment">//undefined</span></code></pre><ul><li>2、函数可以设置公共属性或方法，是的外部能够进行访问</li></ul><pre><code class="highlight javascript"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>{    <span class="keyword">this</span>.a=<span class="string">"a"</span>}<span class="built_in">console</span>.log(<span class="keyword">new</span> test().a);<span class="comment">//a;</span></code></pre><ul><li>3、通过使用公共方法操作私有属性或方法，这种方式就称之为闭包</li></ul><pre><code class="highlight javascript"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>{    <span class="keyword">var</span> a=<span class="string">"a"</span>;    <span class="keyword">this</span>.getA=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{ <span class="keyword">return</span> a; }    <span class="keyword">this</span>.setA=<span class="function"><span class="keyword">function</span>(<span class="params">a</span>)</span>{ <span class="keyword">this</span>.a=a; }}</code></pre><h2 id="原型和原型链"><a href="#原型和原型链" class="headerlink" title="原型和原型链"></a>原型和原型链</h2><h3 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h3><p>1、构造函数：<code>construct</code></p><p>用来生成对象的函数。最常见的有<code>Object</code>、<code>Function</code>、<code>Array</code>、<code>String</code>、<code>Number</code>等。</p><p>2、<code>new</code>的作用</p><p>(1)创建一个对象(2)改变构造函数的this指向为实例对象(3)在实例对象中产生<code>__proto__</code>属性，指向构造函数的<code>ptototype</code></p><p>3、原型</p><p>(1)定义函数时，会生成一个<code>prototype</code>的属性，指向当前函数，这个属性称之为函数的原型(2)构造函数<code>new</code>时，会生成一个对象，并且会生成<code>__proto__</code>属性，指向构造函数的<code>prototype</code>，这个属性称之为这个对象的原型(3)构造函数作为对象时存在<code>__proto__</code>，指向<code>Function</code>原型(4)所有的原型对象的<code>__proto__</code>最后都会指向<code>Object</code>原型，而<code>Object</code>原型的<code>__proto__</code>是null。(5)任何原型的<code>constructor</code>指向构造函数，而构造函数的<code>prototype</code>又指向原型，如此，会形成死循环（类似先有鸡还是先有蛋）</p><h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3><p>根据原型的规则画出的关系链称为原型链。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Prototype </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LESS从入门到精通</title>
      <link href="2020/08/17/Webpack/CSSLESS/"/>
      <url>2020/08/17/Webpack/CSSLESS/</url>
      
        <content type="html"><![CDATA[<h1 id="LESS-从入门到精通"><a href="#LESS-从入门到精通" class="headerlink" title="LESS 从入门到精通"></a>LESS 从入门到精通</h1><h2 id="一、LESS-是什么"><a href="#一、LESS-是什么" class="headerlink" title="一、LESS 是什么"></a>一、LESS 是什么</h2><p><strong>LESS</strong> 是 <strong>CSS 预处理语言</strong>，是 <strong>CSS</strong> 的扩展。</p><p>然后说说比较流行的几款预编译器：<strong>SASS/SCSS</strong>、<strong>LESS</strong>、<strong>Stylus</strong>。</p><p><strong>SASS</strong> 学习网站：</p><ul><li><a href="https://www.sass.hk/" target="_blank" rel="noopener">https://www.sass.hk/</a></li><li><a href="https://www.w3cschool.cn/sass/" target="_blank" rel="noopener">https://www.w3cschool.cn/sass/</a></li><li><a href="https://github.com/sass/sass" target="_blank" rel="noopener">https://github.com/sass/sass</a></li></ul><p><strong>LESS</strong> 学习网站：</p><ul><li><a href="http://lesscss.cn/" target="_blank" rel="noopener">http://lesscss.cn/</a></li><li><a href="https://less.bootcss.com/" target="_blank" rel="noopener">https://less.bootcss.com/</a></li><li><a href="https://www.w3cschool.cn/less/" target="_blank" rel="noopener">https://www.w3cschool.cn/less/</a></li><li><a href="https://github.com/less/less.js" target="_blank" rel="noopener">https://github.com/less/less.js</a></li></ul><p><strong>Stylus</strong> 学习网站：</p><ul><li><a href="https://stylus.bootcss.com/" target="_blank" rel="noopener">https://stylus.bootcss.com/</a></li><li><a href="https://github.com/stylus/stylus" target="_blank" rel="noopener">https://github.com/stylus/stylus</a></li></ul><h2 id="二、为什么用-LESS"><a href="#二、为什么用-LESS" class="headerlink" title="二、为什么用 LESS"></a>二、为什么用 LESS</h2><p>SASS/SCSS 和 Stylus 都很强，但是我还是选择了 LESS，个人喜欢 NodeJS，然后 stylus 空格我又不喜欢，就用了 LESS，现在用的也习惯了，下面就给大家介绍一下 LESS 的一些用法吧。</p><p>LESS——像写 javascript 一样书写 css</p><p>特点：</p><ul><li>1、写样式更简单：嵌套</li><li>2、使用方便：变量、运算、函数</li><li>3、学习成本低：语法</li></ul><h2 id="三、怎么用-LESS"><a href="#三、怎么用-LESS" class="headerlink" title="三、怎么用 LESS"></a>三、怎么用 LESS</h2><h3 id="1、安装使用"><a href="#1、安装使用" class="headerlink" title="1、安装使用"></a>1、安装使用</h3><h4 id="1-浏览器中使用"><a href="#1-浏览器中使用" class="headerlink" title="(1)浏览器中使用"></a>(1)浏览器中使用</h4><h5 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h5><pre><code class="highlight html"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet/less"</span> <span class="attr">type</span>=<span class="string">"text/css"</span> <span class="attr">href</span>=<span class="string">"index.less"</span> /&gt;</span><span class="comment">&lt;!-- 必须加上/less --&gt;</span><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"less-1.3.3.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span><span class="comment">&lt;!-- js必须在less后引用 --&gt;</span></code></pre><p>通过以上配置，在访问页面时，js 会自动编译 less 为 css</p><h5 id="CDN："><a href="#CDN：" class="headerlink" title="CDN："></a>CDN：</h5><p><code>https://cdnjs.cloudflare.com/ajax/libs/less.js/3.9.0/less.min.js</code></p><p><code>https://cdn.bootcss.com/less.js/3.9.0/less.js</code></p><h5 id="观察模式"><a href="#观察模式" class="headerlink" title="观察模式"></a>观察模式</h5><p>在每次保存文件后，调试时，总要进行手动刷新，于是有了观察模式</p><p><strong>基本设置</strong></p><pre><code class="highlight html"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet/less"</span> <span class="attr">href</span>=<span class="string">"index.less"</span> /&gt;</span><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="actionscript">  less = { env: <span class="string">"development"</span> };</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span>//声明开发模式<span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"less-1.3.3.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span><span class="tag">&lt;<span class="name">script</span>&gt;</span>  less.watch();<span class="tag">&lt;/<span class="name">script</span>&gt;</span>//调用观察模式</code></pre><p>调用了观察模式后，就可以实现在每次保存时自动编译观察模式的原理是每隔一段时间进行编译</p><p><strong>扩展配置</strong></p><p>在基础设置的后面添加 script 标签，内容如下</p><pre><code class="highlight js">less = {  <span class="comment">// 开发环境development，生产模式production</span>  env: <span class="string">"development"</span>,  <span class="comment">// 异步加载</span>  <span class="keyword">async</span>: <span class="literal">false</span>,  <span class="comment">// 在页面下异步读取导入</span>  fileAsync: <span class="literal">false</span>,  <span class="comment">// 观察模式间隔</span>  poll: <span class="number">1000</span>,  <span class="comment">// 使用函数</span>  functions: {},  <span class="comment">// 行信息输出comment、mediaQuery、all</span>  dumpLineNumbers: <span class="string">"all"</span>,  <span class="comment">// 是否调整url为相对</span>  relativeUrls: <span class="literal">false</span>,  <span class="comment">// 根路径</span>  rootpath: <span class="string">":/"</span>};</code></pre><h4 id="2-使用-node-编译"><a href="#2-使用-node-编译" class="headerlink" title="(2)使用 node 编译"></a>(2)使用 node 编译</h4><p><strong>使用此方法需要先安装 node</strong></p><p><strong>node 下载链接</strong>：<a href="http://nodejs.cn/download/" target="_blank" rel="noopener">http://nodejs.cn/download/</a></p><p><strong>安装了 node 之后，就可以正式安装 <code>less</code> 了</strong></p><pre><code class="highlight node">npm install -g less</code></pre><p>当 less 文件写好后，就可以使用一下命令进行编译</p><pre><code class="highlight node">lessc index.less index.css</code></pre><h4 id="3-gulp-打包工具"><a href="#3-gulp-打包工具" class="headerlink" title="(3)gulp 打包工具"></a>(3)gulp 打包工具</h4><p>使用此方法需要分别在 <strong>全局</strong> 与 <strong>项目</strong> 安装 gulp</p><pre><code class="highlight node">//全局npm install -g gulp//当前项目npm install --save-dev gulp</code></pre><p>然后在安装 gulp 的插件 <strong>gulp-less</strong></p><pre><code class="highlight node">npm install -save-dev gulp-less</code></pre><p>安装完之后，创建入口文件 <strong>gulpfile.js</strong>，并写入:</p><pre><code class="highlight node">var origin = "./index.less"; //填写你需要转化的less文件的路径var result = "./"; //填写你转化后文件存在的目录路径var gulp = require("gulp");gulp.task("less2css", function() {  gulp    .src(origin)    .pipe(less())    .pipe(result);});</code></pre><p>至此，就可以通过输入 <code>gulp less2css</code> 命令进行编译了但是，每次保存后都要去编译很麻烦，于是，补充以下代码</p><pre><code class="highlight node">gulp.task("lessc", function() {  gulp.watch("origin", ["less2css"]);});</code></pre><p>现在只需要输入 <code>gulp lessc</code> 就可以实现 less 的观察者模式了</p><h3 id="2、语法"><a href="#2、语法" class="headerlink" title="2、语法"></a>2、语法</h3><p>保留 CSS 的基础语法，并进行了扩展</p><pre><code class="highlight less"><span class="keyword">@import</span> <span class="string">"reset.css"</span> <span class="comment">//less在编译时不会变动css文件</span>  <span class="variable">@import</span> <span class="string">"base"</span> <span class="comment">//less导入其他less文件时可以省略文件格式</span>  <span class="variable">@import</span> url(<span class="string">"base.less"</span>);</code></pre><h3 id="3、运算"><a href="#3、运算" class="headerlink" title="3、运算"></a>3、运算</h3><p>在<code>less</code>中，可以在书写属性时直接进行加减乘除</p><p>例子：<code>header</code>插入了一个<code>padding</code></p><pre><code class="highlight less"><span class="variable">@fullWidth:</span> <span class="number">1200px</span>;<span class="selector-class">.header</span> {  <span class="attribute">width</span>: <span class="variable">@fullWidth</span> – <span class="number">20px</span> * <span class="number">2</span>;  <span class="attribute">padding</span>: <span class="number">0px</span> <span class="number">20px</span> * <span class="number">2</span>;}</code></pre><h3 id="4、变量"><a href="#4、变量" class="headerlink" title="4、变量"></a>4、变量</h3><h4 id="1-格式：以-开头"><a href="#1-格式：以-开头" class="headerlink" title="(1)格式：以@开头"></a>(1)格式：以@开头</h4><pre><code class="highlight less"><span class="variable">@headergray:</span> <span class="number">#c0c0c0</span>;<span class="variable">@fullWidth:</span> <span class="number">1200px</span>;<span class="variable">@logoWidth:</span> <span class="number">35%</span>;</code></pre><h4 id="2-字符串插值"><a href="#2-字符串插值" class="headerlink" title="(2)字符串插值"></a>(2)字符串插值</h4><pre><code class="highlight less"><span class="variable">@name:</span> banner;<span class="attribute">background</span>: url(<span class="string">"images/@{name}.png"</span>) no-repeat;</code></pre><p>编译：</p><pre><code class="highlight css">background: url("images/banner.png") no-repeat;</code></pre><h4 id="3-避免编译"><a href="#3-避免编译" class="headerlink" title="(3)避免编译"></a>(3)避免编译</h4><pre><code class="highlight less"><span class="attribute">background</span>: <span class="string">~"red"</span>;</code></pre><p>编译：</p><pre><code class="highlight css"><span class="selector-tag">background</span>: <span class="selector-tag">red</span>;</code></pre><h4 id="4-移动端-rem-布局中的使用"><a href="#4-移动端-rem-布局中的使用" class="headerlink" title="(4)移动端 rem 布局中的使用"></a>(4)移动端 rem 布局中的使用</h4><pre><code class="highlight less"><span class="variable">@fullWidth:</span> <span class="number">750</span>;<span class="variable">@toRem:</span> unit(<span class="variable">@fullWidth</span> / <span class="number">10</span>, rem);<span class="selector-tag">header</span> {  <span class="attribute">height</span>: <span class="number">150</span> / <span class="variable">@toRem</span>;}</code></pre><p>编译：</p><pre><code class="highlight css"><span class="selector-tag">header</span> {  <span class="attribute">height</span>: <span class="number">2rem</span>;}</code></pre><h3 id="5、混合"><a href="#5、混合" class="headerlink" title="5、混合"></a>5、混合</h3><h4 id="1-在一个类中继承另一个类"><a href="#1-在一个类中继承另一个类" class="headerlink" title="(1)在一个类中继承另一个类"></a>(1)在一个类中继承另一个类</h4><pre><code class="highlight less"><span class="selector-class">.class1</span> {  <span class="attribute">color</span>: red;}<span class="selector-class">.class2</span> {  <span class="attribute">background</span>: green;  <span class="selector-class">.class1</span>;}</code></pre><p>编译后：</p><pre><code class="highlight css"><span class="selector-class">.class1</span> {  <span class="attribute">color</span>: red;}<span class="selector-class">.class2</span> {  <span class="attribute">background</span>: green;  <span class="attribute">color</span>: red;}</code></pre><h4 id="2-用-amp-替换当前选择器"><a href="#2-用-amp-替换当前选择器" class="headerlink" title="(2)用&amp;替换当前选择器"></a>(2)用&amp;替换当前选择器</h4><pre><code class="highlight less"><span class="selector-tag">a</span> {  <span class="attribute">color</span>: <span class="number">#000</span>;  <span class="selector-tag">&amp;</span><span class="selector-pseudo">:hover</span> {    <span class="attribute">color</span>: <span class="number">#f00</span>;  }}</code></pre><p>编译后：</p><pre><code class="highlight css"><span class="selector-tag">a</span> {  <span class="attribute">color</span>: <span class="number">#000</span>;}<span class="selector-tag">a</span><span class="selector-pseudo">:hover</span> {  <span class="attribute">color</span>: <span class="number">#f00</span>;}</code></pre><h4 id="3-在父类中嵌套子类"><a href="#3-在父类中嵌套子类" class="headerlink" title="(3)在父类中嵌套子类"></a>(3)在父类中嵌套子类</h4><pre><code class="highlight less"><span class="selector-class">.class1</span> {  <span class="selector-tag">p</span> {    <span class="selector-tag">span</span> {      <span class="selector-tag">a</span> {      }    }    <span class="selector-tag">&amp;</span><span class="selector-pseudo">:hover</span> {    }  }  <span class="selector-tag">div</span> {  }}</code></pre><p>编译后：</p><pre><code class="highlight css"><span class="selector-class">.class1</span>{ }<span class="selector-class">.class1</span> <span class="selector-tag">p</span>{ }<span class="selector-class">.class1</span> <span class="selector-tag">p</span> <span class="selector-tag">span</span>{.class1 p span a{ }<span class="selector-class">.class1</span> <span class="selector-tag">p</span><span class="selector-pseudo">:hover</span>{  }<span class="selector-class">.class1</span> <span class="selector-tag">div</span>{  }</code></pre><h4 id="4-带参混合"><a href="#4-带参混合" class="headerlink" title="(4)带参混合"></a>(4)带参混合</h4><pre><code class="highlight less"><span class="selector-class">.color</span>(<span class="variable">@color</span>=red) {  <span class="attribute">color</span>: <span class="variable">@color</span>;}<span class="selector-class">.class1</span> {  <span class="selector-class">.color</span>(<span class="number">#0f0</span>);}<span class="selector-class">.class2</span> {  <span class="selector-class">.color</span>();}</code></pre><p>编译后：</p><pre><code class="highlight css"><span class="selector-class">.class1</span> {  <span class="attribute">color</span>: <span class="number">#0f0</span>;}<span class="selector-class">.class2</span> {  <span class="attribute">color</span>: red;}</code></pre><h4 id="5-块定义"><a href="#5-块定义" class="headerlink" title="(5)块定义"></a>(5)块定义</h4><pre><code class="highlight less"><span class="variable">@demo:</span> {  <span class="attribute">color</span>: <span class="number">#f00</span>;};<span class="selector-tag">body</span> {  <span class="variable">@demo</span>();}</code></pre><p>编译后：</p><pre><code class="highlight css"><span class="selector-tag">body</span> {  <span class="attribute">color</span>: <span class="number">#f00</span>;}</code></pre><p>该方式和类继承的区别在于该块不会出现在编译的 CSS 中。</p><h3 id="6、函数"><a href="#6、函数" class="headerlink" title="6、函数"></a>6、函数</h3><h4 id="1-逻辑控制"><a href="#1-逻辑控制" class="headerlink" title="(1)逻辑控制"></a>(1)逻辑控制</h4><ul><li><p>格式：statement when(conditons)、prop: if((conditions),value);</p></li><li><p>例子 1：在 less 中使用一个带参类名展示上下左右四个方向的纯 CSS 三角形</p></li></ul><p><strong>index.less</strong></p><pre><code class="highlight less"><span class="selector-class">.base</span>() {  <span class="attribute">width</span>: <span class="number">0</span>;  <span class="attribute">height</span>: <span class="number">0</span>;}<span class="variable">@normal:</span> <span class="number">20px</span> solid transparent;<span class="variable">@anger:</span> <span class="number">20px</span> solid <span class="number">#f00</span>;<span class="selector-class">.triangle</span>(<span class="variable">@val</span>) <span class="keyword">when</span>(<span class="variable">@val</span>=left) {  <span class="selector-class">.base</span>();  <span class="attribute">border-left</span>: none;  <span class="attribute">border-right</span>: <span class="variable">@anger</span>;  <span class="attribute">border-top</span>: <span class="variable">@normal</span>;  <span class="attribute">border-bottom</span>: <span class="variable">@normal</span>;}<span class="selector-class">.triangle</span>(<span class="variable">@val</span>) <span class="keyword">when</span>(<span class="variable">@val</span>=right) {  <span class="selector-class">.base</span>();  <span class="attribute">border-right</span>: none;  <span class="attribute">border-left</span>: <span class="variable">@anger</span>;  <span class="attribute">border-top</span>: <span class="variable">@normal</span>;  <span class="attribute">border-bottom</span>: <span class="variable">@normal</span>;}<span class="selector-class">.triangle</span>(<span class="variable">@val</span>) <span class="keyword">when</span>(<span class="variable">@val</span>=top) {  <span class="selector-class">.base</span>();  <span class="attribute">border-left</span>: <span class="variable">@normal</span>;  <span class="attribute">border-right</span>: <span class="variable">@normal</span>;  <span class="attribute">border-top</span>: none;  <span class="attribute">border-bottom</span>: <span class="variable">@anger</span>;}<span class="selector-class">.triangle</span>(<span class="variable">@val</span>) <span class="keyword">when</span>(<span class="variable">@val</span>=bottom) {  <span class="selector-class">.base</span>();  <span class="attribute">border-left</span>: <span class="variable">@normal</span>;  <span class="attribute">border-right</span>: <span class="variable">@normal</span>;  <span class="attribute">border-top</span>: <span class="variable">@anger</span>;  <span class="attribute">border-bottom</span>: none;}<span class="selector-class">.div1</span> {  <span class="selector-class">.triangle</span>(left);}<span class="selector-class">.div2</span> {  <span class="selector-class">.triangle</span>(right);}<span class="selector-class">.div3</span> {  <span class="selector-class">.triangle</span>(top);}<span class="selector-class">.div4</span> {  <span class="selector-class">.triangle</span>(bottom);}</code></pre><p><strong>index.html</strong></p><pre><code class="highlight html"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span><span class="tag">&lt;<span class="name">html</span>&gt;</span>    <span class="tag">&lt;<span class="name">head</span>&gt;</span>        <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet/less"</span> <span class="attr">href</span>=<span class="string">"index.less"</span>&gt;</span>        <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"../less-1.3.3.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span>    <span class="tag">&lt;/<span class="name">head</span>&gt;</span>    <span class="tag">&lt;<span class="name">body</span>&gt;</span>        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"div1"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span>        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"div2"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span>        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"div3"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span>        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"div4"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span>    <span class="tag">&lt;/<span class="name">body</span></span>&lt;/html&gt;</code></pre><ul><li>例子 2：</li></ul><pre><code class="highlight less"><span class="attribute">background</span>: if((true), <span class="number">#f00</span>);</code></pre><h4 id="2-循环"><a href="#2-循环" class="headerlink" title="(2)循环"></a>(2)循环</h4><p>例子：将 8 个 td 的背景依次更换为 bg_1.png、bg_2.png、…、bg_8.png</p><pre><code class="highlight less"><span class="selector-tag">table</span> <span class="selector-tag">td</span> {  <span class="attribute">width</span>: <span class="number">200px</span>;  <span class="attribute">height</span>: <span class="number">200px</span>;  <span class="selector-class">.loop</span>(<span class="variable">@i</span>) <span class="keyword">when</span>(<span class="variable">@i</span>&lt;<span class="number">9</span>) {    <span class="selector-tag">&amp;</span><span class="selector-pseudo">:nth-child(</span><span class="variable">@{i}</span>) {      <span class="attribute">background</span>: url(<span class="string">~"../images/partner_@{i}.png"</span>) no-repeat;    }    <span class="selector-class">.loop</span>(<span class="variable">@i</span>+<span class="number">1</span>);  }  <span class="selector-class">.loop</span>(<span class="number">1</span>);}</code></pre><h4 id="3-列表"><a href="#3-列表" class="headerlink" title="(3)列表"></a>(3)列表</h4><pre><code class="highlight less"><span class="variable">@backgroundlist:</span> apple, pear, coconut, orange;</code></pre><h4 id="4-less-函数库"><a href="#4-less-函数库" class="headerlink" title="(4)less 函数库"></a>(4)less 函数库</h4><pre><code class="highlight less"><span class="selector-tag">image-size</span>(“bg.png”) <span class="comment">//获取图片的Width和Height</span><span class="selector-tag">image-width</span>() <span class="comment">//获取图片的Width和Height</span><span class="selector-tag">image-height</span>() <span class="comment">//获取图片的Width和Height</span><span class="selector-tag">convert</span>(<span class="number">9s</span>, ms) <span class="comment">//转换9秒为毫秒</span><span class="selector-tag">convert</span>(<span class="number">14cm</span>, mm) <span class="comment">//转换14厘米为毫米</span></code></pre><p>更多函数参考官方函数库，包括混合函数、数学函数、字符串函数、列表函数等等</p><h3 id="7、使用-JS-表达式"><a href="#7、使用-JS-表达式" class="headerlink" title="7、使用 JS 表达式"></a>7、使用 JS 表达式</h3><ul><li><p>less 中还可以引用 js 表达式，不过一般都不推荐使用，此种方式在使用 nodejs 将 less 编译 css 时可能会报错。</p></li><li><p>格式：<strong>`javascript`</strong></p></li><li><p>例子：将高度设置为当前获取到的浏览器的高度</p></li></ul><pre><code class="highlight less"><span class="variable">@fullHeight:</span> unit(<span class="built_in">` window.screen.height `</span>, px);<span class="selector-tag">div</span> {  <span class="attribute">height</span>: <span class="variable">@fullHeight</span>;}</code></pre><ul><li>尝试将 <strong>@width: unit(` window.screen.width `, px)</strong> 引进 <strong>vw 布局</strong> ？不推荐，不建议 less 在正式环境中使用，使用 LESS 时需要在头部引入 js，而在 js 执行时的时候，会消耗时间，而 less 编译需要在 js 执行后，会在一定程度上影响到性能。</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LESS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>有趣的list-style</title>
      <link href="2020/08/12/HTML&amp;CSS/CSSlist-style/"/>
      <url>2020/08/12/HTML&amp;CSS/CSSlist-style/</url>
      
        <content type="html"><![CDATA[<h2 id="有趣的list-style"><a href="#有趣的list-style" class="headerlink" title="有趣的list-style "></a>有趣的list-style <span id="home"></span></h2><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><strong><a href="#1">一、list-style-type </a></strong><ul><li><strong><a href="#1.1">1、CSS2.0 </a></strong></li><li><strong><a href="#1.2">2、CSS2.1 的值 </a></strong></li></ul></li><li><strong><a href="#2">二、list-style-position </a></strong><ul><li><strong><a href="#2.1">1、书写格式 </a></strong></li><li><strong><a href="#2.2">2、可能的值 </a></strong></li></ul></li><li><strong><a href="#3">三、list-style-image </a></strong><ul><li><strong><a href="#3.1">书写格式 </a></strong></li><li><strong><a href="#3.1">可能的值 </a></strong></li></ul></li></ul><hr><h2 id="一、list-style-type"><a href="#一、list-style-type" class="headerlink" title="一、list-style-type "></a>一、list-style-type <span id="1"></span></h2><h4 id="1、CSS2-0"><a href="#1、CSS2-0" class="headerlink" title="1、CSS2.0 "></a>1、CSS2.0 <span id="1.1"></span></h4><pre><code>值                        描述none                    无标记。disc                    默认。标记是实心圆。circle                    标记是空心圆。square                    标记是实心方块。decimal                    标记是数字。decimal-leading-zero    0开头的数字标记。(01, 02, 03, 等。)lower-roman                小写罗马数字(i, ii, iii, iv, v, 等。)upper-roman                大写罗马数字(I, II, III, IV, V, 等。)lower-alpha                小写英文字母The marker is lower-alpha (a, b, c, d, e, 等。)upper-alpha                大写英文字母The marker is upper-alpha (A, B, C, D, E, 等。)lower-greek                小写希腊字母(alpha, beta, gamma, 等。)lower-latin                小写拉丁字母(a, b, c, d, e, 等。)upper-latin                大写拉丁字母(A, B, C, D, E, 等。)hebrew                    传统的希伯来编号方式armenian                传统的亚美尼亚编号方式georgian                传统的乔治亚编号方式(an, ban, gan, 等。)cjk-ideographic            简单的表意数字hiragana                标记是：a, i, u, e, o, ka, ki, 等。（日文片假名）katakana                标记是：A, I, U, E, O, KA, KI, 等。（日文片假名）hiragana-iroha            标记是：i, ro, ha, ni, ho, he, to, 等。（日文片假名）katakana-iroha            标记是：I, RO, HA, NI, HO, HE, TO, 等。（日文片假名）</code></pre><h4 id="2、CSS2-1-的值"><a href="#2、CSS2-1-的值" class="headerlink" title="2、CSS2.1 的值 "></a>2、CSS2.1 的值 <span id="1.2"></span></h4><pre><code>disc | circle | square | decimal | decimal-leading-zero |lower-roman | upper-roman | lower-greek | lower-latin | upper-latin | armenian | georgian | none | inherit</code></pre><hr><h2 id="二、list-style-position"><a href="#二、list-style-position" class="headerlink" title="二、list-style-position "></a>二、list-style-position <span id="2"></span></h2><h4 id="1、说明"><a href="#1、说明" class="headerlink" title="1、说明 "></a>1、说明 <span id="2.1"></span></h4><p>该属性用于声明列表标志相对于列表项内容的位置。外部 (outside) 标志会放在离列表项边框边界一定距离处，不过这距离在 CSS 中未定义。内部 (inside) 标志处理为好像它们是插入在列表项内容最前面的行内元素一样</p><h4 id="2、可能的值"><a href="#2、可能的值" class="headerlink" title="2、可能的值 "></a>2、可能的值 <span id="2.2"></span></h4><pre><code>值            描述inside        列表项目标记放置在文本以内，且环绕文本根据标记对齐。outside        默认值。保持标记位于文本的左侧。列表项目标记放置在文本以外，且环绕文本不根据标记对齐。inherit        规定应该从父元素继承 list-style-position 属性的值。</code></pre><hr><h2 id="三、list-style-image"><a href="#三、list-style-image" class="headerlink" title="三、list-style-image "></a>三、list-style-image <span id="3"></span></h2><h4 id="1、书写格式"><a href="#1、书写格式" class="headerlink" title="1、书写格式 "></a>1、书写格式 <span id="3.1"></span></h4><pre><code>url("position")</code></pre><h4 id="2、可能的值-1"><a href="#2、可能的值-1" class="headerlink" title="2、可能的值 "></a>2、可能的值 <span id="3.2"></span></h4><pre><code>值            描述URL            图像的路径。none        默认。无图形被显示。inherit        规定应该从父元素继承 list-style-image 属性的值。</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从输入URL到显示页面的步骤</title>
      <link href="2020/08/11/HTML&amp;CSS/%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E6%98%BE%E7%A4%BA%E9%A1%B5%E9%9D%A2%E7%9A%84%E6%AD%A5%E9%AA%A4/"/>
      <url>2020/08/11/HTML&amp;CSS/%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E6%98%BE%E7%A4%BA%E9%A1%B5%E9%9D%A2%E7%9A%84%E6%AD%A5%E9%AA%A4/</url>
      
        <content type="html"><![CDATA[<h2 id="精简"><a href="#精简" class="headerlink" title="精简"></a>精简</h2><ol><li>根据请求的<code>URL</code>交给<code>DNS</code>域名解析，找到真实<code>IP</code>，向服务器发起请求；</li><li>服务器交给后台处理完成后返回数据，浏览器接受文件（<code>HTML、JS、CSS</code>、图像等）；</li><li>浏览器对返还的资源进行解析，并建立相应的内部数据结构（如<code>HTML</code>的<code>DOM</code>）；</li><li>载入解析到的资源文件，渲染页面</li></ol><h2 id="详细"><a href="#详细" class="headerlink" title="详细"></a>详细</h2><ol><li>输入URL</li><li>浏览器检查缓存<ul><li>若未缓存，发起新请求</li><li>若有缓存，且新鲜，则直接使用缓存，跳到转码步骤</li><li>若不新鲜，则携带缓存标识对服务器发起请求，根据服务器相应数据再生成页面</li></ul></li><li>浏览器解析URL获取协议、主机、端口、path</li><li>组装一个HTTP请求报文</li><li>浏览器获取主机IP地址，过程如下：<ul><li>浏览器缓存</li><li>本级缓存</li><li>hosts文件</li><li>路由器缓存</li><li>ISP DNS缓存</li><li>DNS递归查询</li></ul></li><li>打开一个socket与目标IP地址，开始TCP三次握手：<ul><li>客户端发送一个TCP的<code>SYN=1,Seq=X</code>的包到服务器端口</li><li>服务器返回<code>SYN=1,ACK=X+1,Seq=Y</code>的响应包</li><li>客户端发送<code>ACK=Y+1,Seq=Z</code></li></ul></li><li>TCP连接建立后发送HTTP请求</li><li>服务器接受请求并解析，转到服务程序</li><li>检查请求头是否携带缓存标识，有则验证是否新鲜，返回304等对应状态码</li><li>处理程序读取完整请求并准备HTTP相应，可能需要查询数据库等操作</li><li>服务器等响应报文通过TCP连接发送回浏览器</li><li>浏览器接受HTTP响应，根据情况选择关闭TCP连接或保留重用，关闭则进行TCP四次挥手：<ul><li>主动方发送<code>Fin=1, Ack=Z, Seq=X</code></li><li>被动方发送<code>ACK=X+1, Seq=Z</code></li><li>被动方发送<code>Fin=1, ACK=X, Seq=Y</code></li><li>主动方发送<code>ACK=Y,Seq=X</code></li></ul></li><li>浏览器检查响应码：是否为1XX，3XX，4XX，5XX，这些情况处理与2XX不同</li><li>查看是否可缓存，可以则缓存</li><li>对相应进行解码（如gzip压缩）</li><li>根据资源类型决定如何处理（假设资源为HTML文档）</li><li>解析HTML文档，构件DOM树，下载资源，构造CSSOM树，执行JS脚本，这些操作没有严格的先后顺序</li><li>构件DOM树：<ul><li><code>Tokenizing</code>：根据<strong>HTML规范</strong>将字符流解析为标记</li><li><code>Lexing</code>：<strong>词法分析</strong>将标记转换为对象并定义属性和规则</li><li><code>DOM construction</code>：根据<strong>HTML标记关系</strong>将对象组成DOM树</li></ul></li><li>解析过程中遇到图片、样式表、js脚本，启动下载</li><li>构件<strong>CSSOM树：</strong><ul><li><code>Tokenizing</code>：将字符流转换为标记流</li><li><code>Node</code>：根据标记创建节点</li><li><code>CSSOM</code>：节点创建CSSOM树</li></ul></li><li><strong>根据DOM树和CSSOM树构件渲染树：</strong><ul><li>从DOM树的根节点遍历所有可见节点，不可见节点包括：</li><li><code>script、meta</code>这样本身不可见的标签</li><li>被css隐藏的节点，如<code>display:none</code></li><li>对没一个可见节点，找到恰当的CSSOM规则并应用</li><li>发布可视节点的内容个计算样式</li></ul></li><li>JS解析如下：<ul><li>浏览器创建Document对象，并解析HTML，将解析到的元素和文本节点添加到文档中，此时<strong>document.readystate为loading</strong></li><li>遇到<strong>同步的script</strong>时，将它们添加到文档，文档暂停解析，转而进行下载并运行脚本。如此可以用document.write()可以吧文本插入到输入流中。<strong>同步脚本经常简单定义函数和注册事件处理程序，他们可以遍历和操作script和他们之前的文档内容</strong></li><li>遇到<strong>async的script</strong>时，开始下载脚本，并继续解析文档。脚本会在<strong>下载完成后尽快执行</strong>。<strong>异步脚本禁止使用write，它们可以访问自己script和之前的文档元素</strong></li><li>当文档完成解析，<strong>document.readyState变成interactive</strong></li><li>所有<strong>defer的script</strong>也会挂起下载而不阻塞解析，<strong>在文档完全被解析和显示后，按照在文档中出现的顺序进行执行</strong>，可以访问完整文档树，禁止使用write()</li><li>Document对象<strong>触发DOMContentLoaded事件</strong></li><li>此时文档完全解析，浏览器可能还在等待如图片的内容的加载，这些内容完成载入并且所有异步脚本完成载入和执行，<strong>document.readyState变为complete，window触发load事件</strong></li></ul></li><li>显示页面（HTML解析过程中会逐步显示页面）<ul><li>从浏览器接受<code>URL</code>到开启网络请求线程（可以展开浏览器的机制及进程与线程间的关系）</li><li>开启网络线程到发出一个完整的<code>HTTP</code>请求（设计到DNS查询，<code>TCP/IP</code>请求，五层因特网协议栈等）</li><li>服务器接受到请求到对应后台接收到请求（可能设计到负载均衡，安全拦截以及后台内部的处理）</li><li>后台和前台的<code>HTTP</code>交互（这部分包括报文组成、<code>cookie</code>等知识，静态资源的<code>cookie</code>优化，以及编码解码，如<code>gzip</code>压缩等）</li><li>单独拎出来的缓存问题（包括缓存头部、ETag、catch-control等）</li><li>浏览器接收到数据包后的解析流程（解析<code>HTML</code>-词法分析-生成DOM树、解析<code>CSS</code>生成css规则树、合并成<code>render</code>树，然后<code>layout</code>、<code>painting</code>渲染、复合图层的合成、<code>GPU</code>绘制、外链资源的处理、<code>loaded</code>和<code>DOMContentLoaded</code>等）</li><li>CSS的可视化格式模型（元素的渲染规则，如包含块、控制框、BFC、IFC等概念）</li><li>JS引擎解析过程（JS的解释阶段、预处理阶段、执行阶段生成执行上下文，VO，作用域链、回收机制等等）</li><li>其他（如跨域、web安全、hybrid模式等等）</li></ul></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> HTML </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS样式之内容居中方法</title>
      <link href="2020/07/14/HTML&amp;CSS/CSSInCenter/"/>
      <url>2020/07/14/HTML&amp;CSS/CSSInCenter/</url>
      
        <content type="html"><![CDATA[<h3 id="水平居中"><a href="#水平居中" class="headerlink" title="水平居中"></a>水平居中</h3><p>HTML中要实现某一内容水平居中显示，要通过设置css样式来实现，主要分为<strong>行内元素</strong>和<strong>块状元素</strong>两种情况，<strong>块状元素</strong>又可分为<strong>块状定宽</strong>与<strong>块状不定宽</strong>两种情况，接下来依次介绍分析。</p><h4 id="行内元素"><a href="#行内元素" class="headerlink" title="行内元素"></a>行内元素</h4><p>像 a、span、i 这类元素叫做行内元素，<strong>文本</strong>和<strong>图片</strong>也是行内元素。行内元素水平居中方法简单，只需要给行内元素的<strong>父元素</strong>设置 <code>text-align: center;</code> css样式就内实现内容水平居中，例如：html:</p><pre><code class="highlight html"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span> = <span class="string">"txt"</span>&gt;</span>居中内容<span class="tag">&lt;/<span class="name">div</span>&gt;</span></code></pre><p>css:</p><pre><code class="highlight css"><span class="selector-class">.txt</span> {<span class="attribute">text-align</span>: center;}</code></pre><p>文本内容的<strong>父元素</strong>就是 <code>div</code> ，这样就内实现水平居中，效果如下：</p><div align="center"><b>居中内容</b></div><h4 id="块状定宽元素"><a href="#块状定宽元素" class="headerlink" title="块状定宽元素"></a>块状定宽元素</h4><p>常见块状元素有 div, p, h 等，定宽即为其设置固定宽度值 <code>width</code>，这时我们可以为元素设置 <code>margin-left</code> 和 <code>margin-right</code> 来实现水平居中，也可以简写为 <code>margin: 0 auto;</code>，例如：html:</p><pre><code class="highlight html"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span> = <span class="string">"txt"</span>&gt;</span>居中内容<span class="tag">&lt;/<span class="name">div</span>&gt;</span></code></pre><p>css:</p><pre><code class="highlight css"><span class="selector-class">.txt</span> {<span class="attribute">width</span>: <span class="number">100px</span>;<span class="attribute">margin</span>: <span class="number">10px</span> auto;}</code></pre><p>实现效果如下：</p><div align="center"><b>居中内容</b></div><h4 id="块状不定宽"><a href="#块状不定宽" class="headerlink" title="块状不定宽"></a>块状不定宽</h4><p>有时候我们不能限制块状元素的宽度，就是块状不定宽元素，主要有三种方法，接下来一次介绍。</p><h5 id="1、加入-table-标签"><a href="#1、加入-table-标签" class="headerlink" title="1、加入 table 标签"></a>1、加入 table 标签</h5><p>利用 table 标签的<strong>长度自适应性</strong>，长度根据内容自动调整，然后通过设置 <code>margin: auto;</code> 实现水平居中，例如：html:</p><pre><code class="highlight html"><span class="tag">&lt;<span class="name">table</span>&gt;</span><span class="tag">&lt;<span class="name">tbody</span>&gt;</span><span class="tag">&lt;<span class="name">tr</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span> = <span class="string">"txt"</span>&gt;</span>居中内容<span class="tag">&lt;/<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">tr</span>&gt;</span><span class="tag">&lt;/<span class="name">tbody</span>&gt;</span><span class="tag">&lt;/<span class="name">table</span>&gt;</span></code></pre><p>css:</p><pre><code class="highlight css"><span class="selector-class">.txt</span> {<span class="attribute">margin</span>: auto;}</code></pre><p>效果如下：</p><div align="center"><b>居中内容</b></div><h5 id="2、设置为行内元素"><a href="#2、设置为行内元素" class="headerlink" title="2、设置为行内元素"></a>2、设置为行内元素</h5><p>就是通过设置 <code>display: inline;</code> 将块状元素设置为<strong>行内元素</strong>，然后就是像行内元素一样设置 <code>text-align: center;</code> 来是内容水平居中，例如：html:</p><pre><code class="highlight html"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span> = <span class="string">"txt"</span>&gt;</span>居中内容<span class="tag">&lt;/<span class="name">div</span>&gt;</span></code></pre><p>css:</p><pre><code class="highlight css"><span class="selector-class">.txt</span> {<span class="attribute">display</span>: inline;<span class="attribute">text-align</span>: center;}</code></pre><p>效果为：</p><div align="center"><b>居中内容</b></div><p><strong>注：</strong></p><blockquote><p><strong>使用这种方法虽然可以不用像table增加无语义标签，但是改变了display，所以会少了一些功能，例如不能设置宽度。</strong></p></blockquote><h5 id="3、设置浮动和相对定位"><a href="#3、设置浮动和相对定位" class="headerlink" title="3、设置浮动和相对定位"></a>3、设置浮动和相对定位</h5><p>这种方法设置就相对复杂，同时设置<strong>浮动</strong>和<strong>相对定位</strong>来实现元素的水平居中。首先设置<strong>父元素</strong>：</p><pre><code class="highlight css"><span class="selector-tag">float</span>: <span class="selector-tag">left</span>;<span class="selector-tag">position</span>: <span class="selector-tag">relative</span>;<span class="selector-tag">left</span>: 50%;</code></pre><p>然后设置<strong>子元素</strong>：</p><pre><code class="highlight css"><span class="selector-tag">position</span>: <span class="selector-tag">relative</span>;<span class="selector-tag">left</span>: <span class="selector-tag">-50</span>%;</code></pre><p>通过代码应该好理解，就是通过<strong>50%</strong>那个关键位置来实现水平居中效果，因为<strong>50%</strong>是界面的中央位置，将父元素右移，直到左边框移到中线位置，在将子元素向左移，这样子元素不就居中了吗。</p><p>这里要<strong>注意</strong>的是分别设置<strong>父元素</strong>的 <code>50%</code> 和<strong>子元素</strong>的 <code>-50%</code>。实现效果如下：</p><div align="center"><b>居中内容</b></div><h3 id="垂直居中"><a href="#垂直居中" class="headerlink" title="垂直居中"></a>垂直居中</h3><p>说完水平居中接着说垂直居中，这里主要又分为两种情况：<strong>父元素高度确定的单行文本</strong> 和<strong>父元素高度确定的多行文本</strong>。</p><h4 id="单行文本"><a href="#单行文本" class="headerlink" title="单行文本"></a>单行文本</h4><p>对于<strong>父元素</strong>高度确定的单行文本，可以通过设置<strong>父元素</strong>的 <code>height</code> 和 <code>line-height</code> 高度一致来实现。</p><p>这里可以这样理解，<code>height</code> 是元素的高度，例如文本字体的高度，<code>line-height</code> 是行高，例如文本的行间距，一行文本中，行间距被<strong>分为两部分</strong>，分别位于这行文本的<strong>顶部</strong>和<strong>底部</strong>（因为行间距是两行之间的距离），所以设置 <code>height</code> 和 <code>line-height</code> <strong>一样大</strong>的话，<code>line-height</code> 就被均分为两部分，分别位于元素顶部和底部，这样中间设置为 <code>height</code> 的元素不就实现<strong>垂直居中</strong>了吗 ^_^ .</p><p>例如：html:</p><pre><code class="highlight html"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span> = <span class="string">"txt"</span>&gt;</span>居中内容<span class="tag">&lt;/<span class="name">div</span>&gt;</span></code></pre><p>css:</p><pre><code class="highlight css"><span class="selector-class">.txt</span> {<span class="attribute">height</span>: <span class="number">200px</span>;<span class="attribute">line-height</span>: <span class="number">200px</span>;}</code></pre><p>效果如下：</p><pre>居中内容</pre><blockquote><p><strong>这里需要注意的是关键词“单行文本”，如果使用这种方法但是一行文本超过宽度限制的话，某些内容就会脱离元素块，子元素有多行的话，这几行就会并排居中，并保持设置的行高。</strong></p></blockquote><h4 id="多行文本"><a href="#多行文本" class="headerlink" title="多行文本"></a>多行文本</h4><p>对于父元素高度确定的<strong>文本</strong>和<strong>图片</strong>等内容设置垂直居中，主要有两种方法。</p><h5 id="1、使用-table-标签"><a href="#1、使用-table-标签" class="headerlink" title="1、使用 table 标签"></a>1、使用 table 标签</h5><p>对元素使用<strong>table</strong>标签，包括 tbody，tr，td，然后对父元素设置 <code>vertical-align: middle;</code> 样式，就能使 <code>inline-block</code> 类型的子元素垂直居中显示。</p><p>因为 td 标签<strong>默认</strong>设置了 <code>vertical-align: middle</code>，所以也可以不用单独设置 <code>vertical-align</code>。例如：html:</p><pre><code class="highlight html"><span class="tag">&lt;<span class="name">table</span>&gt;</span><span class="tag">&lt;<span class="name">tbody</span>&gt;</span><span class="tag">&lt;<span class="name">tr</span>&gt;</span><span class="tag">&lt;<span class="name">td</span> <span class="attr">class</span>=<span class="string">"txt"</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span>居中内容<span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span>居中内容<span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span>居中内容<span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">tr</span>&gt;</span><span class="tag">&lt;/<span class="name">tbody</span>&gt;</span><span class="tag">&lt;/<span class="name">table</span>&gt;</span></code></pre><p>css:</p><pre><code class="highlight css"><span class="selector-class">.txt</span> {        <span class="attribute">height</span>: <span class="number">300px</span>;<span class="attribute">background-color</span>: <span class="number">#ccc</span>;}</code></pre><blockquote><p><strong>这里的父元素就是 td，父元素的高度必须确定，就要为其设置 height。</strong></p></blockquote><p><strong>注意</strong>这里的 p 元素是 <strong>inline</strong> 类型的，所以设置 <code>vertical-align: middle</code> 的话会出现错误，若果是图片元素 img 的话，就可以设置 <code>vertical-align: middle</code>，但是由于 td 标签默认，所以都可以不写。</p><p>效果如下：</p><pre>居中内容</pre><h5 id="2、设置-table-cell"><a href="#2、设置-table-cell" class="headerlink" title="2、设置 table-cell"></a>2、设置 table-cell</h5><p>第二种方法是把要垂直居中显示的元素的父元素设置为<strong>table-cell (表格单元)</strong>类型：<code>display: table-cell;</code>，然后设置 <code>vertical-align: middle</code>就能实现元素垂直居中。</p><p>但是这个方法存在兼容性问题，<strong>chrome, firefox, IE8以上</strong>才支持这个操作。</p><p>例如：html:</p><pre><code class="highlight html"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"txt"</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span>居中内容<span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span>居中内容<span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span>居中内容<span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></code></pre><p>css:</p><pre><code class="highlight css"><span class="selector-class">.txt</span> {        <span class="attribute">height</span>: <span class="number">300px</span>;<span class="attribute">background-color</span>: <span class="number">#ccc</span>;<span class="attribute">display</span>: table-cell;<span class="attribute">vertical-align</span>: middle;}</code></pre><blockquote><p><strong>同样，要为父元素 div 设置高度 height</strong></p></blockquote><p>效果如下：</p><pre>居中内容</pre><p>这种方法除了兼容性问题外，同时也改变了 <strong>display</strong>类型，会在某些方面带来不便。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>flex布局</title>
      <link href="2020/07/08/HTML&amp;CSS/CSSFlexBox/"/>
      <url>2020/07/08/HTML&amp;CSS/CSSFlexBox/</url>
      
        <content type="html"><![CDATA[<h1 id="flex布局"><a href="#flex布局" class="headerlink" title="flex布局"></a>flex布局</h1><h2 id="一、使用注意"><a href="#一、使用注意" class="headerlink" title="一、使用注意"></a>一、使用注意</h2><blockquote><p>将元素display声明为flex，该元素将成为flex布局的父元素，下一级的直系子元素将成为flex子项</p></blockquote><blockquote><p>flex容器内元素，即flex item的float，clear、vertical-align属性将失效</p></blockquote><h2 id="二、flex容器属性"><a href="#二、flex容器属性" class="headerlink" title="二、flex容器属性"></a>二、flex容器属性</h2><p>1、flex-direction  排列方向</p><blockquote><p>row:主轴为水平方向，项目沿主轴从左至右排列</p></blockquote><blockquote><p>column：主轴为竖直方向，项目沿主轴从上至下排列</p></blockquote><blockquote><p>row-reverse：主轴水平，项目从右至左排列，与row反向</p></blockquote><blockquote><p>column-reverse：主轴竖直，项目从下至上排列，与column反向</p></blockquote><p>2、flex-wrap  换行方式</p><blockquote><p>nowrap：自动缩小项目，不换行</p></blockquote><blockquote><p>wrap：换行，且第一行在上方</p></blockquote><blockquote><p>wrap-reverse：换行，第一行在下面</p></blockquote><p>3、flex-flow  flex-direction和flex-wrap的简写</p><p>默认值为row nowrap</p><p>4、justify-content  主轴对齐方式</p><blockquote><p>flex-start：左对齐</p></blockquote><blockquote><p>flex-end：右对齐</p></blockquote><blockquote><p>center：居中对齐</p></blockquote><blockquote><p>space- between：两端对齐</p></blockquote><blockquote><p>space-around：沿轴线均匀分布</p></blockquote><p>5、align-items  交叉轴对齐方式</p><p>6、align-content  多行交叉轴对齐方式</p><p>定义了align-content后，align-items属性将失效</p><blockquote><p>flex-start：左对齐</p></blockquote><blockquote><p>flex-end：右对齐</p></blockquote><blockquote><p>center：居中对齐</p></blockquote><blockquote><p>space-between：两端对齐</p></blockquote><blockquote><p>space-around：沿轴线均匀分布</p></blockquote><blockquote><p>stretch：各行将根据其flex-grow值伸展以充分占据剩余空间</p></blockquote><h2 id="三、flex-item属性详述"><a href="#三、flex-item属性详述" class="headerlink" title="三、flex item属性详述"></a>三、flex item属性详述</h2><p>item的属性在item的style中设置。</p><p>1、order</p><p>order的值是整数，默认为0，整数越小，item排列越靠前</p><p>2、flex-grow</p><p>定义当flex容器有多余空间时，item是否放大。默认值为0，即当有多余空间时也不放大；可能的值为整数，表示不同item的放大比例</p><p>3、flex-shrink定义当容器空间不足时，item是否缩小。默认值为1，表示当空间不足时，item自动缩小，其可能的值为整数，表示不同item的缩小比例。</p><p>4、flex-basis</p><p>主轴占据空间，默认值为auto。</p><p>5、flex</p><p>flex属性是flex-grow、flex-shrink和flex-basis三属性的简写总和。</p><p>6、align-self</p><blockquote><p>align-self属性允许item有自己独特的在交叉轴上的对齐方式，它有六个可能的值。默认值为auto</p></blockquote><blockquote><p>auto：和父元素align-self的值一致</p></blockquote><blockquote><p>flex-start：顶端对齐</p></blockquote><blockquote><p>flex-end：底部对齐</p></blockquote><blockquote><p>center：竖直方向上居中对齐</p></blockquote><blockquote><p>baseline：item第一行文字的底部对齐</p></blockquote><blockquote><p>stretch：当item未设置高度时，item将和容器等高对齐</p></blockquote><h2 id="四、比值排序"><a href="#四、比值排序" class="headerlink" title="四、比值排序"></a>四、比值排序</h2><p>1、等比</p><pre><code class="highlight css"><span class="selector-class">.div1</span>{<span class="attribute">flex</span>:<span class="number">1</span>;}<span class="selector-class">.div2</span>{<span class="attribute">flex</span>:<span class="number">1</span>;}<span class="selector-class">.div3</span>{<span class="attribute">flex</span>:<span class="number">1</span>;}</code></pre><p>2、左固定，其余等比</p><pre><code class="highlight css"><span class="selector-class">.div1</span>{<span class="attribute">width</span>:<span class="number">20%</span>;}<span class="selector-class">.div2</span>{<span class="attribute">flex</span>:<span class="number">1</span>;}<span class="selector-class">.div3</span>{<span class="attribute">flex</span>:<span class="number">1</span>;}</code></pre><p>3、左右固定，其余等比</p><pre><code class="highlight css"><span class="selector-class">.div1</span>{<span class="attribute">width</span>:<span class="number">20%</span>;}<span class="selector-class">.div2</span>{<span class="attribute">flex</span>:<span class="number">1</span>;}<span class="selector-class">.div3</span>{<span class="attribute">width</span>:<span class="number">20%</span>;}</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DIV+CSS布局</title>
      <link href="2020/07/08/HTML&amp;CSS/CSSDIVCSS/"/>
      <url>2020/07/08/HTML&amp;CSS/CSSDIVCSS/</url>
      
        <content type="html"><![CDATA[<h2 id="DIV-CSS布局"><a href="#DIV-CSS布局" class="headerlink" title="DIV+CSS布局"></a>DIV+CSS布局</h2><h3 id="一、DIV结构"><a href="#一、DIV结构" class="headerlink" title="一、DIV结构"></a>一、DIV结构</h3><pre><code class="highlight plain">│body {}　/* 这是一个HTML元素 */└#Container {}　/* 页面层容器 */├#Header {}　/* 页面头部 */├#MianBody {}　/* 页面主体 */│　├#mainbody-left {}　/* 主体页面左边 */│　└#mainbody-center {}　/* 主体页面中间 */│　└#MainBody -right{}　/* 主体页面右边 */└#footer {}　/*页面底部*/</code></pre><p>用DIV+CSS做一个导航栏是非常容易的，而且我们可以通过css来对导航栏的样式方便的作出调整。用div设置导航栏一般就用</p><ul>和<li>标签。<p></p><p>4、高度显示效果不同</p><p>一般情况下只需要使用<code>height: 100px</code>; 即可，当显示效果不同时，则可以<code>_height: 100px</code>;来对IE6的高度进行设置。</p><p>5、嵌套效果不不同</p><p>有些情况下如果div中嵌套的图片大于外层div的高度，则IE6中对高度的设置始终无效，这时要注意对该css添加overflow属性，<code>overloaw:hidden</code>，则可隐藏超出边界的部分。</p><h3 id="二、文件命名规范"><a href="#二、文件命名规范" class="headerlink" title="二、文件命名规范"></a>二、文件命名规范</h3><p>全局样式：global.css；</p><p>框架布局：layout.css；</p><p>字体样式：font.css；</p><p>链接样式：link.css；</p><p>打印样式：print.css；</p><h3 id="三、常用类-ID命名规范"><a href="#三、常用类-ID命名规范" class="headerlink" title="三、常用类/ID命名规范"></a>三、常用类/ID命名规范</h3><p>页　眉：header</p><p>内　容：content</p><p>容　器：container</p><p>页　脚：footer</p><p>版　权：copyright　</p><p>导　航：menu</p><p>主导航：mainMenu</p><p>子导航：subMenu</p><p>标　志：logo</p><p>标　语：banner</p><p>标　题：title</p><p>侧边栏：sidebar</p><p>图　标：Icon</p><p>注　释：note</p><p>搜　索：search</p><p>按　钮：btn</p><p>登　录：login</p><p>链　接：link</p><p>信息框：manage</p><h3 id="四、常规书写规范及方法"><a href="#四、常规书写规范及方法" class="headerlink" title="四、常规书写规范及方法"></a>四、常规书写规范及方法</h3><p>1、选择DOCTYPE</p><p>html5声明</p><pre><code class="highlight html"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></code></pre><p>过渡的(Transitional): 要求非常宽松的DTD // 推荐</p><pre><code class="highlight html"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//W3C//DTD XHTML 1.0 Transitional//EN"</span> <span class="meta-string">"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"</span>&gt;</span></code></pre><p>严格的(Strict):要求严格的DTD</p><pre><code class="highlight html"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//W3C//DTD XHTML 1.0 Strict//EN"</span> <span class="meta-string">"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"</span>&gt;</span></code></pre><p>框架的(Frameset):专门针对框架页面设计使用的DTD</p><pre><code class="highlight html"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//W3C//DTD XHTML 1.0 Frameset//EN"</span> <span class="meta-string">"http://www.w3.org/TR/xhtml1/DTD/xhtml1-frameset.dtd"</span>&gt;</span></code></pre><p>2、指定语言及字符集</p><p>语言定义:</p><pre><code class="highlight html"><span class="tag">&lt;<span class="name">html</span> <span class="attr">xmlns</span>=<span class="string">:http://www.w3.org/1999/xhtml</span>" <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></code></pre><p>编码定义:</p><pre><code class="highlight html"><span class="comment">&lt;!-- 老浏览器 --&gt;</span><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Content-Type"</span> <span class="attr">content</span>=<span class="string">"text/html; charset=utf-8"</span> /&gt;</span><span class="comment">&lt;!-- XML文件 --&gt;</span><span class="meta">&lt;?xml version="1.0" encoding=" utf-8"?&gt;</span></code></pre><ol start="3"><li>调用样式表</li></ol><p>外部调用法：将样式表写在一个独立的.css文件中，然后在页面head区用类似以下代码调用。（推荐）</p><p>页面内嵌法：就是将样式表直接写在页面代码的head区。</p><p>4、选用恰当的元素</p><p>根据文档的结构来选择HTML元素，而不是根据HTML元素的样式来选择。例如，使用P元素来包含文字段落，而不是为了换行。</p><p>避免过渡使用div和span</p><p>尽可能少地使用标签和结构嵌套，这样不但可以使文档结构清晰，同时也可以保持文件的小巧，在提高用户下载速度的同时，也易于浏览器对文档的解释及呈视；</p><p>5、派生选择器</p><p>可以使用派生选择器给一个元素里的子元素定义样式，在简化命名的同时也使结构更加的清晰化</p><p>如：</p><pre><code class="highlight css"><span class="selector-class">.mainMenu</span> <span class="selector-tag">ul</span> <span class="selector-tag">li</span> { <span class="attribute">background</span>: <span class="built_in">url</span>(images/bg.gif;) }</code></pre><p>6、辅助图片用背影图处理  仅用于修饰、间隔、提醒的图片</p><p>7、结构与样式分离  在页面里只写入文档的结构，而将样式写于css文件中，通过外部调用CSS样式表来实现结构与样式的分离。</p><p>8、文档的结构化书写</p><p>页面CSS文档都应采用结构化的书写方式，逻辑清晰易于阅读。如：</p><pre><code class="highlight html"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"mainMenu"</span>&gt;</span><span class="tag">&lt;<span class="name">ul</span>&gt;</span><span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">ul</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></code></pre><pre><code class="highlight css"><span class="selector-id">#mainMenu</span> <span class="selector-tag">ul</span> <span class="selector-tag">li</span> { }</code></pre><p>9、鼠标手势</p><p>在XHTML标准中，hand只被IE识别，当需要将鼠标手势转换为“手形”时，则将“hand”换为“pointer”，即“cursor:pointer;”</p><h3 id="五、注释书写"><a href="#五、注释书写" class="headerlink" title="五、注释书写"></a>五、注释书写</h3><p>1、行间注释</p><p>直接写于属性值后面</p><pre><code class="highlight css"><span class="selector-tag">border</span>: 1<span class="selector-tag">px</span> <span class="selector-tag">solid</span> <span class="selector-id">#fff</span>; <span class="comment">/*定义搜索输入框边框*/</span></code></pre><p>2、整段注释</p><pre><code class="highlight css"><span class="comment">/*===== 搜索条开始 =====*/</span>   <span class="selector-class">.search</span> {    <span class="attribute">border</span>:<span class="number">1px</span> solid <span class="number">#fff</span>;       <span class="attribute">background</span>:<span class="built_in">url</span>(../images/icon.gif) no-repeat <span class="number">#333</span>;   }<span class="comment">/*===== 搜索条结束 =====*/</span></code></pre><h3 id="六、样式属性代码缩写"><a href="#六、样式属性代码缩写" class="headerlink" title="六、样式属性代码缩写"></a>六、样式属性代码缩写</h3><p>1、不同类有相同属性及属性值的缩写</p><p>对于两个不同的类，但是其中有部分相同甚至是全部相同的属性及属性值时，应对其加以合并缩写，特别是当有多个不同的类而有相同的属性及属性值时，合并缩写可以减少代码量并易于控制。</p><p>2、同一属性的缩写</p><p>background包含：background-color、background-image、background-repeat、background-position</p><p>同一属性根据它的属性值也可以进行简写</p><p>3、内外侧边框的缩写</p><p>margin、padding</p><p>top right bottom left</p><p>上边与下边、左边与右边的边框属性值相同时，则属性值可以直接缩写为两个(上下、左右)</p><p>上下左右四个边框的属性值都相同时，则可以直接缩写成一个</p><p>在CSS中关于内外侧边框的距离是按照上、右、下、左的顺序来排列的，当这四个属性值不同时也可直接缩写</p><p>4、颜色值的缩写</p><p>当RGB三个颜色值数值相同时，可缩写颜色值代码</p></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS布局模型详细介绍</title>
      <link href="2020/07/08/HTML&amp;CSS/CSSLayoutModel/"/>
      <url>2020/07/08/HTML&amp;CSS/CSSLayoutModel/</url>
      
        <content type="html"><![CDATA[<p>HTML中元素有三种布局模型：流动模型、浮动模型、层模型。</p><h4 id="流动模型（flow）"><a href="#流动模型（flow）" class="headerlink" title="流动模型（flow）"></a>流动模型（flow）</h4><p>HTML网页默认布局就是流动模型，布局如下：</p><p><strong>块级元素(block)</strong>自上而下垂直分布，因为块级元素默认宽度为浏览器窗口的<strong>100%</strong>，或者理解为每个块级元素默认<strong>占一行</strong>。常见块级元素有 <code>div</code>, <code>p</code>, <code>h</code> 等；</p><p><strong>内联元素(inline)</strong>从左到右水平分布，即不像块级元素那样每个独占一行。常见内联元素有 <code>a</code>, <code>span</code>, <code>em</code> 等。</p><h4 id="浮动模型（float）"><a href="#浮动模型（float）" class="headerlink" title="浮动模型（float）"></a>浮动模型（float）</h4><p>上面提到的块级元素是每个独占一行显示，但是定义css浮动模型后就能使两个块级元素<strong>并排一行</strong>显示。例如HTML代码：</p><pre><code class="highlight html"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span> = <span class="string">"div1"</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span> = <span class="string">"div2"</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span>World !<span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></code></pre><p>显示结果是这样：</p><pre><code>HelloWorld !</code></pre><p>但是设置浮动css后：</p><pre><code class="highlight css"><span class="selector-tag">div</span> {<span class="attribute">float</span>: left;}</code></pre><p>效果就是这样：</p><pre><code>HelloWorld !</code></pre><p>也可以设置元素一左一右显示：</p><pre><code class="highlight css"><span class="selector-id">#div1</span> {<span class="attribute">float</span>: left;}<span class="selector-id">#div2</span> {<span class="attribute">float</span>: right;}</code></pre><h4 id="层模型（layer）（position）"><a href="#层模型（layer）（position）" class="headerlink" title="层模型（layer）（position）"></a>层模型（layer）（position）</h4><p>类似于PS中的<strong>图层</strong>编辑，HTML中也存在层模型布局，对元素进行<strong>定位</strong>。层模型有三种：<strong>绝对定位</strong>(absolute)、<strong>相对定位</strong>(relative)、<strong>固定定位</strong>(fixed)。</p><h5 id="绝对定位"><a href="#绝对定位" class="headerlink" title="绝对定位"></a>绝对定位</h5><p>理解就是字面上的意思，简言之就是<strong>相对于上级设置了 position 属性的元素</strong>进行定位，如果没有这类上级就是相对于 <code>body</code> 标签，也是<strong>浏览器窗口</strong>。需要设置css：<code>position: absolute;</code>，然后就可以使用 <code>top</code>, <code>right</code>, <code>bottom</code>, <code>left</code> 这类属性进行定位。例如：</p><pre><code class="highlight css"><span class="selector-tag">div</span> {<span class="attribute">position</span>: absolute;<span class="attribute">top</span>: <span class="number">100px</span>;<span class="attribute">left</span>: <span class="number">150px</span>;}</code></pre><p>这样就使板块<strong>向下</strong>移动100像素，<strong>向右</strong>移动150像素。</p><h5 id="相对定位"><a href="#相对定位" class="headerlink" title="相对定位"></a>相对定位</h5><p>这里的<strong>相对</strong>较难理解，与数理中的“相对”不太一样，这里是<strong>“相对于自己原来应在的位置”</strong>，需要设置css：<code>position:  relative;</code>，重要的是不用关心<strong>上级是否设置了position属性</strong>，这样就很方便。例如：</p><pre><code class="highlight css"><span class="selector-tag">div</span> {<span class="attribute">position</span>: relative;<span class="attribute">top</span>: <span class="number">100px</span>;<span class="attribute">right</span>: <span class="number">100px</span>;}</code></pre><p>板块就相对于自己没设置样式前的位置，同时向左向下移动100px。</p><h5 id="固定定位"><a href="#固定定位" class="headerlink" title="固定定位"></a>固定定位</h5><p>这个就好理解了，所谓<strong>固定</strong>就是指固定于整个浏览器网页窗口不动，即使滚动网页内容也不改变位置，需要设置css：<code>position: fixed</code>，也可以设置 <code>top</code>, <code>right</code>等调整固定的位置。还记得浏览器某些网页右下角的小广告吗，是不是固定在那怎么浏览网页都不动 -_- .</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS选择符的权重</title>
      <link href="2020/07/06/HTML&amp;CSS/CSSSelector/"/>
      <url>2020/07/06/HTML&amp;CSS/CSSSelector/</url>
      
        <content type="html"><![CDATA[<h2 id="CSS选择符的权重"><a href="#CSS选择符的权重" class="headerlink" title="CSS选择符的权重 "></a>CSS选择符的权重 <span id="home"></span></h2><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><strong><a href="#1">css选择符权重 </a></strong><ul><li><strong><a href="#1.1">css选择器权重列表 </a></strong></li><li><strong><a href="#1.2">CSS选择符冲突处理 </a></strong></li></ul></li></ul><hr><h2 id="css选择符权重"><a href="#css选择符权重" class="headerlink" title="css选择符权重 "></a><code>css</code>选择符权重 <span id="1"></span></h2><h4 id="css选择器权重列表"><a href="#css选择器权重列表" class="headerlink" title="css选择器权重列表 "></a><code>css</code>选择器权重列表 <span id="1.1"></span></h4><pre><code>选择器        权重内联样式        1000ID            0100CLASS        0010属性选择符    0010TAG            0001伪元素        0001伪类            0001inhref        0000群组选择符    不变后代选择符    相加</code></pre><h4 id="CSS选择符冲突处理"><a href="#CSS选择符冲突处理" class="headerlink" title="CSS选择符冲突处理 "></a><code>CSS</code>选择符冲突处理 <span id="1.2"></span></h4><p>1、权重不同：选择符的<code>css</code>发生冲突时，拥有高权值的<code>css</code>选择符将会显示</p><p>2、权重相同：选择符权重一样，将会按照加载顺序进行覆盖（就近原则）</p><p>3、<code>a</code>和<code>a:link</code>同时存在时，以<code>a:link</code>优先，注：使用<code>a</code>的伪类时，需要四个伪类(<code>a:link</code>、<code>a:hover</code>、<code>a:active</code>、<code>a:visited</code>)同时使用</p><p>4、<code>!important</code>的权重为正无穷</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue的响应式原理</title>
      <link href="2020/03/25/Vue/VueBottomImplementation/"/>
      <url>2020/03/25/Vue/VueBottomImplementation/</url>
      
        <content type="html"><![CDATA[<h1 id="Vue的响应式原理"><a href="#Vue的响应式原理" class="headerlink" title="Vue的响应式原理"></a>Vue的响应式原理</h1><h2 id="一、响应式的底层实现"><a href="#一、响应式的底层实现" class="headerlink" title="一、响应式的底层实现"></a>一、响应式的底层实现</h2><h3 id="1、Vue与MVVM"><a href="#1、Vue与MVVM" class="headerlink" title="1、Vue与MVVM"></a>1、Vue与MVVM</h3><p>Vue是一个 <code>MVVM框架</code>，其各层的对应关系如下</p><ul><li><p><code>View层</code>：在Vue中是绑定dom对象的HTML</p></li><li><p><code>ViewModel层</code>：在Vue中是实例的vm对象</p></li><li><p><code>Model层</code>：在Vue中是data、computed、methods等中的数据</p></li></ul><p>在 <code>Model</code> 层的数据变化时，<code>View</code>层会在ViewModel的作用下，实现自动更新</p><h3 id="2、Vue的响应式原理"><a href="#2、Vue的响应式原理" class="headerlink" title="2、Vue的响应式原理"></a>2、Vue的响应式原理</h3><p>Vue响应式底层实现方法是 <code>Object.defineProperty()</code> 方法，该方法中存在一个getter和setter的可选项，可以对属性值的获取和设置造成影响</p><p>Vue中编写了一个wather来处理数据</p><p>在使用getter方法时，总会通知wather实例对view层渲染页面</p><p>同样的，在使用setter方法时，总会在变更值的同时，通知wather实例对view层进行更新</p><h3 id="3、响应式原理与兼容"><a href="#3、响应式原理与兼容" class="headerlink" title="3、响应式原理与兼容"></a>3、响应式原理与兼容</h3><p>由于 <code>Object.defineProperty()</code> 方法只部分支持IE9，所以Vue兼容IE版本最低为IE9，在IE9中，Vue的核心框架、vue-router、vuex是确保可以正常使用的</p><h3 id="4、响应式原理示意图"><a href="#4、响应式原理示意图" class="headerlink" title="4、响应式原理示意图"></a>4、响应式原理示意图</h3><p>![Vue的响应式原理示意图](<a href="https://hn-failte.github.io/assets/posts/vue-bottom-implementation.png#pic_center" target="_blank" rel="noopener">https://hn-failte.github.io/assets/posts/vue-bottom-implementation.png#pic_center</a> =30x30)</p><h2 id="二、响应式数据"><a href="#二、响应式数据" class="headerlink" title="二、响应式数据"></a>二、响应式数据</h2><h3 id="1、在实例前声明"><a href="#1、在实例前声明" class="headerlink" title="1、在实例前声明"></a>1、在实例前声明</h3><pre><code class="highlight js"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue({    data: {        name: <span class="string">"failte"</span>    }})</code></pre><p>在实例前声明的属性会在实例时添加 <code>getter()</code>、<code>setter()</code> 方法，因此此时的name是响应式的，每当name变化时，会自动更新视图</p><h3 id="2、在实例后添加"><a href="#2、在实例后添加" class="headerlink" title="2、在实例后添加"></a>2、在实例后添加</h3><pre><code class="highlight js">vm.name = <span class="string">"failte"</span></code></pre><p>由于data中没有该属性，因此实例后，此时的name是非响应式的，name变化时，不会更新视图</p><p>若需要转换为响应式数据，需要使用 <code>Vue.set()</code> 方法手动添加为响应式属性</p><pre><code class="highlight js">Vue.set(vm.data, <span class="string">"name"</span>, <span class="string">"ajaccio"</span>)<span class="comment">//Vue.$set是该方法的别名</span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实现call、apply、bind</title>
      <link href="2020/02/17/JavaScript/JavaScriptCall%E3%80%81apply%E3%80%81bindPolyfill2/"/>
      <url>2020/02/17/JavaScript/JavaScriptCall%E3%80%81apply%E3%80%81bindPolyfill2/</url>
      
        <content type="html"><![CDATA[<h1 id="面试题：实现call、apply、bind"><a href="#面试题：实现call、apply、bind" class="headerlink" title="面试题：实现call、apply、bind"></a>面试题：实现call、apply、bind</h1><h2 id="实现call"><a href="#实现call" class="headerlink" title="实现call"></a>实现call</h2><pre><code class="highlight js"><span class="built_in">Function</span>.prototype.myCall = <span class="function"><span class="keyword">function</span>(<span class="params">context</span>)</span>{    <span class="comment">// 首先判断调用者是不是函数</span>    <span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="keyword">this</span> !== <span class="string">'function'</span>){      <span class="keyword">return</span> <span class="built_in">console</span>.log(<span class="string">'type error'</span>)    }    <span class="comment">// 处理传入参数</span>    <span class="keyword">var</span> args = [...arguments].slice(<span class="number">1</span>)    <span class="keyword">var</span> result = <span class="literal">null</span>    <span class="comment">// 判断是否有传入上下文,未传入则设为全局上下文</span>    context = context || <span class="built_in">window</span>    <span class="comment">// 将调用函数设为context的方法</span>    context.fn = <span class="keyword">this</span>    <span class="comment">// 调用</span>    result = context.fn(...args)    <span class="keyword">return</span> result;}</code></pre><p>apply实现方法类似，只需要更改传入参数的形式即可</p><h2 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h2><pre><code class="highlight js"><span class="built_in">Function</span>.prototype.myBind = <span class="function"><span class="keyword">function</span>(<span class="params">context</span>)</span>{  <span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="keyword">this</span> !== <span class="string">'function'</span>){      <span class="keyword">return</span> <span class="built_in">console</span>.log(<span class="string">'type error'</span>)    }  context = context || <span class="built_in">window</span>;  <span class="keyword">var</span> args = [...arguments].slice(<span class="number">1</span>)  <span class="comment">// 保存当前调用函数</span>  fn = <span class="keyword">this</span>;  <span class="comment">// 创建一个函数返回</span>  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">Fn</span>(<span class="params"></span>)</span>{    <span class="comment">// 根据不同的方式，传入不同的绑定值</span>    <span class="keyword">return</span> fn.apply(      <span class="keyword">this</span> <span class="keyword">instanceof</span> Fn ? <span class="keyword">this</span> : context,      args.concat(...arguments)    )  }}</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Polyfill </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
