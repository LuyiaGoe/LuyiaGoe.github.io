<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>开发前端 CLI 脚手架思路解析</title>
      <link href="2022/03/23/JavaScript/%E5%BC%80%E5%8F%91%E5%89%8D%E7%AB%AF%20CLI%20%E8%84%9A%E6%89%8B%E6%9E%B6%E6%80%9D%E8%B7%AF%E8%A7%A3%E6%9E%90/"/>
      <url>2022/03/23/JavaScript/%E5%BC%80%E5%8F%91%E5%89%8D%E7%AB%AF%20CLI%20%E8%84%9A%E6%89%8B%E6%9E%B6%E6%80%9D%E8%B7%AF%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>作者：左撇峰子，原文链接：<a href="https://juejin.im/post/6879265583205089287" target="_blank" rel="noopener">https://juejin.im/post/6879265583205089287</a></p><h1 id="为什么要自己搞脚手架"><a href="#为什么要自己搞脚手架" class="headerlink" title="为什么要自己搞脚手架"></a><strong>为什么要自己搞脚手架</strong></h1><p>在实际的开发过程中，我们经常用别人开发的脚手架，以节约搭建项目的时间。但是，当 npm 没有自己中意的脚手架时，我们不得不自己动手，此时学会开发前端 CLI 脚手架的技能就显得非常重要。搭建一个符合大众化的脚手架能使自己在项目经验上加个分哦！</p><h1 id="什么时候需要脚手架"><a href="#什么时候需要脚手架" class="headerlink" title="什么时候需要脚手架"></a><strong>什么时候需要脚手架</strong></h1><p>其实很多时候从 0 开始搭建的项目都可以做成模板，而脚手架的主要核心功能就是利用模板来快速搭建一个完整的项目结构，后续我们只需在这上面进行开发就可以了。</p><h1 id="入门需知"><a href="#入门需知" class="headerlink" title="入门需知"></a><strong>入门需知</strong></h1><p>下面我们以创建 js 插件项目的脚手架来加深我们对前端脚手架的认知。在此之前，我们先把需要用到的依赖库熟悉一下（点击对应库名跳转到对应文档）：</p><ul><li><strong>chalk</strong>[1] （控制台字符样式）</li><li><strong>commander</strong>[2] （实现 NodeJS 命令行）</li><li><strong>download</strong>[3] （实现文件远程下载）</li><li><strong>fs-extra</strong>[4] （增强的基础文件操作库）</li><li><strong>handlebars</strong>[5] （实现模板字符替换）</li><li><strong>inquirer</strong>[6] （实现命令行之间的交互）</li><li><strong>log-symbols</strong>[7] （为各种日志级别提供着色符号）</li><li><strong>ora</strong>[8] （优雅终端 Spinner 等待动画）</li><li><strong>update-notifier</strong>[9] （npm 在线检查更新）</li></ul><h1 id="功能策划"><a href="#功能策划" class="headerlink" title="功能策划"></a><strong>功能策划</strong></h1><p>我们先用思维导图来策划一下我们的脚手架需要有哪些主要命令：init（初始化模板）、template（下载模板）、mirror（切换镜像）、upgrade（检查更新），相关导图如下：</p><p><img src="https://LuyiaGoe.github.io/assets/posts/cli-mind.png" alt=""></p><h1 id="开始动手"><a href="#开始动手" class="headerlink" title="开始动手"></a><strong>开始动手</strong></h1><p>新建一个名为 js-plugin-cli 的文件夹后打开，执行 <code>npm init -y</code> 快速初始化一个 <code>package.json</code>，然后根据下面创建对应的文件结构：</p><pre><code class="highlight js">js-plugin-cli├─ .gitignore├─ .npmignore├─ .prettierrc├─ LICENSE├─ README.md├─ bin│  └─ index.js├─ lib│  ├─ init.js│  ├─ config.js│  ├─ download.js│  ├─ mirror.js│  └─ update.js└─ package.json</code></pre><p>其中 .gitignore、.npmignore、.prettierrc、LICENSE、README.md 是额外附属文件（非必须），但这里推荐创建好它们，相关内容根据自己习惯设定就行。在项目里打开终端，先把需要的依赖装上，后续可以直接调用。</p><pre><code class="highlight js">yarn add -D chalk commander download fs-extra handlebars inquirer log-symbols ora update-notifier</code></pre><h1 id="注册指令"><a href="#注册指令" class="headerlink" title="注册指令"></a><strong>注册指令</strong></h1><p>当我们要运行调试脚手架时，通常执行 <code>node ./bin/index.js</code> 命令，但我还是习惯使用注册对应的指令，像 <code>vue init webpack demo</code> 的 <code>vue</code> 就是脚手架指令，其他命令行也要由它开头。打开 <code>package.json</code> 文件，先注册下指令：</p><pre><code class="highlight js"><span class="string">"main"</span>: <span class="string">"./bin/index.js"</span>,<span class="string">"bin"</span>: {  <span class="string">"js-plugin-cli"</span>: <span class="string">"./bin/index.js"</span>}</code></pre><p><code>main</code> 中指向入口文件 <code>bin/index.js</code>，而 <code>bin</code> 下的 <code>js-plugin-cli</code> 就是我们注册的指令，你可以设置你自己想要的名称（尽量简洁）。</p><h1 id="万物皆-v"><a href="#万物皆-v" class="headerlink" title="万物皆-v"></a><strong>万物皆-v</strong></h1><p>我们先编写基础代码，让 <code>js-plugin-cli -v</code> 这个命令能够在终端打印出来。打开 <code>bin/index.js</code> 文件，编写以下代码 ：</p><pre><code class="highlight js"><span class="meta">#!/usr/bin/env node</span><span class="comment">// 请求 commander 库</span><span class="keyword">const</span> program = <span class="built_in">require</span>(<span class="string">'commander'</span>)<span class="comment">// 从 package.json 文件中请求 version 字段的值，-v和--version是参数</span>program.version(<span class="built_in">require</span>(<span class="string">'../package.json'</span>).version, <span class="string">'-v, --version'</span>)<span class="comment">// 解析命令行参数</span>program.parse(process.argv)</code></pre><p>其中 <code>#!/usr/bin/env node</code> （固定第一行）必加，主要是让系统看到这一行的时候，会沿着对应路径查找 node 并执行。调试阶段时，为了保证 <code>js-plugin-cli</code> 指令可用，我们需要在项目下执行 <code>npm link</code>（不需要指令时用 <code>npm unlink</code> 断开），然后打开终端，输入以下命令并回车：</p><pre><code class="highlight js">js-plugin-cli -v</code></pre><p>接下来我们将开始写逻辑代码，为了维护方便，我们将在 <code>lib</code> 文件夹下分模块编写，然后在 <code>bin/index.js</code> 引用。</p><h1 id="upgrade-检查更新"><a href="#upgrade-检查更新" class="headerlink" title="upgrade 检查更新"></a><strong>upgrade 检查更新</strong></h1><p>打开 <code>lib/update.js</code> 文件，编写以下代码 ：</p><pre><code class="highlight js"><span class="comment">// 引用 update-notifier 库，用于检查更新</span><span class="keyword">const</span> updateNotifier = <span class="built_in">require</span>(<span class="string">'update-notifier'</span>)<span class="comment">// 引用 chalk 库，用于控制台字符样式</span><span class="keyword">const</span> chalk = <span class="built_in">require</span>(<span class="string">'chalk'</span>)<span class="comment">// 引入 package.json 文件，用于 update-notifier 库读取相关信息</span><span class="keyword">const</span> pkg = <span class="built_in">require</span>(<span class="string">'../package.json'</span>)<span class="comment">// updateNotifier 是 update-notifier 的方法，其他方法可到 npmjs 查看</span><span class="keyword">const</span> notifier = updateNotifier({  <span class="comment">// 从 package.json 获取 name 和 version 进行查询</span>  pkg,  <span class="comment">// 设定检查更新周期，默认为 1000 * 60 * 60 * 24（1 天）</span>  <span class="comment">// 这里设定为 1000 毫秒（1秒）</span>  updateCheckInterval: <span class="number">1000</span>,})<span class="function"><span class="keyword">function</span> <span class="title">updateChk</span>(<span class="params"></span>) </span>{  <span class="comment">// 当检测到版本时，notifier.update 会返回 Object</span>  <span class="comment">// 此时可以用 notifier.update.latest 获取最新版本号</span>  <span class="keyword">if</span> (notifier.update) {    <span class="built_in">console</span>.log(<span class="string">`New version available: <span class="subst">${chalk.cyan(notifier.update.latest)}</span>, it's recommended that you update before using.`</span>)    notifier.notify()  } <span class="keyword">else</span> {    <span class="built_in">console</span>.log(<span class="string">'No new version is available.'</span>)  }}<span class="comment">// 将上面的 updateChk() 方法导出</span><span class="built_in">module</span>.exports = updateChk</code></pre><p>这里需要说明两点：<code>updateCheckInterval</code> 默认是 <code>1</code> 天，也就意味着今天检测更新了一次，下一次能进行检测更新的时间点应该为明天同这个时间点之后，否则周期内检测更新都会转到 <code>No new version is available.</code>。举个栗子：我今天 10 点的时候检查更新了一次，提示有新版本可用，然后我下午 4 点再检查一次，此时将不会再提示有新版本可用，只能等到明天 10 点过后再检测更新才会重新提示新版本可用。因此，将 <code>updateCheckInterval</code> 设置为 <code>1000</code> 毫秒，就能使每次检测更新保持最新状态。另外，<code>update-notifier</code> 检测更新机制是通过 <code>package.json</code> 文件的 <code>name</code> 字段值和 <code>version</code> 字段值来进行校验：它通过 <code>name</code> 字段值从 npmjs 获取库的最新版本号，然后再跟本地库的 <code>version</code> 字段值进行比对，如果本地库的版本号低于 npmjs 上最新版本号，则会有相关的更新提示。当然，此时我们还需要把 <code>upgrade</code> 命令声明一下，打开 <code>bin/index.js</code> 文件，在合适的位置添加以下代码：</p><pre><code class="highlight js"><span class="comment">// 请求 lib/update.js</span><span class="keyword">const</span> updateChk = <span class="built_in">require</span>(<span class="string">'../lib/update'</span>)<span class="comment">// upgrade 检测更新</span>program  <span class="comment">// 声明的命令</span>  .command(<span class="string">'upgrade'</span>)  <span class="comment">// 描述信息，在帮助信息时显示</span>  .description(<span class="string">"Check the js-plugin-cli version."</span>)  .action(<span class="function"><span class="params">()</span> =&gt;</span> {    <span class="comment">// 执行 lib/update.js 里面的操作</span>    updateChk()  })</code></pre><p>添加后的代码应该如图所示：</p><p><img src="https://LuyiaGoe.github.io/assets/posts/cli-code.png" alt=""></p><p>记得把 <code>program.parse(process.argv)</code> 放到最后就行。添加好代码后，打开控制台，输入命令 <code>js-plugin-cli upgrade</code> 查看效果：</p><p><img src="https://LuyiaGoe.github.io/assets/posts/cli-code-1.png" alt=""></p><p>为了测试效果，我将本地库 <code>js-plugin-cli</code> 下 <code>package.json</code> 的 <code>name</code> 改为 <code>vuepress-creator</code>，<code>version</code> 默认为 <code>1.0.0</code>，而 npmjs 上 <code>vuepress-creator</code> 脚手架最新版本为 2.x，因此会有更新的提示。</p><h1 id="mirror-切换镜像链接"><a href="#mirror-切换镜像链接" class="headerlink" title="mirror 切换镜像链接"></a><strong>mirror 切换镜像链接</strong></h1><p>我们通常会把模板放 Github 上，但是在国内从 Github 下载模板不是一般的慢，所以我考虑将模板放 Vercel 上，但是为了避免一些地区的用户因网络问题不能正常下载模板的问题，我们需要将模板链接变成可定义的，然后用户就可以自定义模板链接，更改为他们自己觉得稳定的镜像托管平台上，甚至还可以把模板下载下来，放到他们自己服务器上维护。为了能够记录切换后的镜像链接，我们需要在本地创建 config.json 文件来保存相关信息，当然不是由我们手动创建，而是让脚手架来创建，整个逻辑过程如下：</p><p><img src="https://LuyiaGoe.github.io/assets/posts/cli-mind-1.png" alt=""></p><p>所以我们还需要在 <code>lib</code> 文件夹下创建 <code>config.js</code> 文件，用于生成默认配置文件。打开 <code>lib/config.js</code> 文件，添加以下代码：</p><pre><code class="highlight js"><span class="comment">// 请求 fs-extra 库</span><span class="keyword">const</span> fse = <span class="built_in">require</span>(<span class="string">'fs-extra'</span>)<span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)<span class="comment">// 声明配置文件内容</span><span class="keyword">const</span> jsonConfig = {  <span class="string">"name"</span>: <span class="string">"js-plugin-cli"</span>,  <span class="string">"mirror"</span>: <span class="string">"https://zpfz.vercel.app/download/files/frontend/tpl/js-plugin-cli/"</span>}<span class="comment">// 拼接 config.json 完整路径</span><span class="keyword">const</span> configPath = path.resolve(__dirname, <span class="string">'../config.json'</span>)<span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">defConfig</span>(<span class="params"></span>) </span>{  <span class="keyword">try</span> {    <span class="comment">// 利用 fs-extra 封装的方法，将 jsonConfig 内容保存成 json 文件</span>    <span class="keyword">await</span> fse.outputJson(configPath, jsonConfig)  } <span class="keyword">catch</span> (err) {    <span class="built_in">console</span>.error(err)    process.exit()  }}<span class="comment">// 将上面的 defConfig() 方法导出</span><span class="built_in">module</span>.exports = defConfig</code></pre><p>这里需要注意的是，我们不要再直接去用内置的 <code>fs</code> 库，推荐使用增强库 <code>fs-extra</code>，<code>fs-extra</code> 除了封装原有基础文件操作方法外，还有方便的 json 文件读写方法。打开 <code>lib/mirror.js</code> 文件，添加以下代码：</p><pre><code class="highlight js"><span class="comment">// 请求 log-symbols 库</span><span class="keyword">const</span> symbols = <span class="built_in">require</span>(<span class="string">'log-symbols'</span>)<span class="comment">// 请求 fs-extra 库</span><span class="keyword">const</span> fse = <span class="built_in">require</span>(<span class="string">'fs-extra'</span>)<span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)<span class="comment">// 请求 config.js 文件</span><span class="keyword">const</span> defConfig = <span class="built_in">require</span>(<span class="string">'./config'</span>)<span class="comment">// 拼接 config.json 完整路径</span><span class="keyword">const</span> cfgPath = path.resolve(__dirname, <span class="string">'../config.json'</span>)<span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">setMirror</span>(<span class="params">link</span>) </span>{  <span class="comment">// 判断 config.json 文件是否存在</span>  <span class="keyword">const</span> exists = <span class="keyword">await</span> fse.pathExists(cfgPath)  <span class="keyword">if</span> (exists) {    <span class="comment">// 存在时直接写入配置</span>    mirrorAction(link)  } <span class="keyword">else</span> {    <span class="comment">// 不存在时先初始化配置，然后再写入配置</span>    <span class="keyword">await</span> defConfig()    mirrorAction(link)  }}<span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">mirrorAction</span>(<span class="params">link</span>) </span>{  <span class="keyword">try</span> {    <span class="comment">// 读取 config.json 文件</span>    <span class="keyword">const</span> jsonConfig = <span class="keyword">await</span> fse.readJson(cfgPath)    <span class="comment">// 将传进来的参数 link 写入 config.json 文件</span>    jsonConfig.mirror = link    <span class="comment">// 再写入 config.json 文件</span>    <span class="keyword">await</span> fse.writeJson(cfgPath, jsonConfig)    <span class="comment">// 等待写入后再提示配置成功</span>    <span class="built_in">console</span>.log(symbols.success, <span class="string">'Set the mirror successful.'</span>)  } <span class="keyword">catch</span> (err) {    <span class="comment">// 如果出错，提示报错信息</span>    <span class="built_in">console</span>.log(symbols.error, chalk.red(<span class="string">`Set the mirror failed. <span class="subst">${err}</span>`</span>))    process.exit()  }}<span class="comment">// 将上面的 setMirror(link) 方法导出</span><span class="built_in">module</span>.exports = setMirror</code></pre><p>需要注意的是 <code>async</code> 和 <code>await</code>，这里用的是 Async/Await 的写法，其他相关写法可参照 <strong>fs-extra</strong>[10] 。<code>async</code> 一般默认放函数前面，而 <code>await</code> 看情况添加，举个例子：</p><pre><code class="highlight js">...<span class="keyword">const</span> jsonConfig = <span class="keyword">await</span> fse.readJson(cfgPath)jsonConfig.mirror = link<span class="keyword">await</span> fse.writeJson(cfgPath, jsonConfig)<span class="built_in">console</span>.log(symbols.success, <span class="string">'Set the mirror successful.'</span>)...</code></pre><p>我们需要等待 fs-extra 读取完，才可以进行下一步，如果不等待，就会继续执行 <code>jsonConfig.mirror = link</code> 语句，就会导致传入的 json 结构发生变化。再比如 <code>await fse.writeJson(cfgPath, jsonConfig)</code> 这句，如果去掉 <code>await</code>，将意味着还在写入 json 数据（假设写入数据需要花 1 分钟）时，就已经继续执行下一个语句，也就是提示 <code>Set the mirror successful.</code>，但实际上写入文件不会那么久，就算去掉 <code>await</code>，也不能明显看出先后执行关系。老规矩，我们还需要把 <code>mirror</code> 命令声明一下，打开 <code>bin/index.js</code> 文件，在合适的位置添加以下代码：</p><pre><code class="highlight js"><span class="comment">// 请求 lib/mirror.js</span><span class="keyword">const</span> setMirror = <span class="built_in">require</span>(<span class="string">'../lib/mirror'</span>)<span class="comment">// mirror 切换镜像链接</span>program  .command(<span class="string">'mirror &lt;template_mirror&gt;'</span>)  .description(<span class="string">"Set the template mirror."</span>)  .action(<span class="function">(<span class="params">tplMirror</span>) =&gt;</span> {    setMirror(tplMirror)  })</code></pre><p>打开控制台，输入命令 <code>js-plugin-cli mirror 你的镜像链接</code> 查看效果。此时，在项目下应该已经生成 config.json 文件，里面相关内容应该为：</p><pre><code class="highlight js">{  <span class="string">"name"</span>: <span class="string">"js-plugin-cli"</span>,  <span class="string">"mirror"</span>: <span class="string">"https://zpfz.vercel.app/download/files/frontend/tpl/js-plugin-cli/"</span>}</code></pre><h1 id="download-下载-更新模板"><a href="#download-下载-更新模板" class="headerlink" title="download 下载/更新模板"></a><strong>download 下载/更新模板</strong></h1><p>网络上很多教程在谈及脚手架下载模板时都会选择 <code>download-git-repo</code> 库，但是这里我选择 <code>download</code> 库，因为利用它可以实现更自由的下载方式，毕竟 <code>download-git-repo</code> 库主要还是针对 Github 等平台的下载，而 <code>download</code> 库可以下载任何链接的资源，甚至还有强大的解压功能（无需再安装其他解压库）。在此之前，我们得先明白 <code>lib/download.js</code> 需要执行哪些逻辑：下载/更新模板应属于强制机制，也就是说，不管用户本地是否有模板存在，<code>lib/download.js</code> 都会下载并覆盖原有文件，以保持模板的最新状态，相关逻辑图示如下：</p><p><img src="https://LuyiaGoe.github.io/assets/posts/cli-mind-2.png" alt=""></p><p>打开 <code>lib/download.js</code> 文件，添加以下代码：</p><pre><code class="highlight js"><span class="comment">// 请求 download 库，用于下载模板</span><span class="keyword">const</span> download = <span class="built_in">require</span>(<span class="string">'download'</span>)<span class="comment">// 请求 ora 库，用于实现等待动画</span><span class="keyword">const</span> ora = <span class="built_in">require</span>(<span class="string">'ora'</span>)<span class="comment">// 请求 chalk 库，用于实现控制台字符样式</span><span class="keyword">const</span> chalk = <span class="built_in">require</span>(<span class="string">'chalk'</span>)<span class="comment">// 请求 fs-extra 库，用于文件操作</span><span class="keyword">const</span> fse = <span class="built_in">require</span>(<span class="string">'fs-extra'</span>)<span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)<span class="comment">// 请求 config.js 文件</span><span class="keyword">const</span> defConfig = <span class="built_in">require</span>(<span class="string">'./config'</span>)<span class="comment">// 拼接 config.json 完整路径</span><span class="keyword">const</span> cfgPath = path.resolve(__dirname, <span class="string">'../config.json'</span>)<span class="comment">// 拼接 template 模板文件夹完整路径</span><span class="keyword">const</span> tplPath = path.resolve(__dirname, <span class="string">'../template'</span>)<span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">dlTemplate</span>(<span class="params"></span>) </span>{  <span class="comment">// 参考上方 mirror.js 主代码注释</span>  <span class="keyword">const</span> exists = <span class="keyword">await</span> fse.pathExists(cfgPath)  <span class="keyword">if</span> (exists) {    <span class="comment">// 这里记得加 await，在 init.js 调用时使用 async/await 生效</span>    <span class="keyword">await</span> dlAction()  } <span class="keyword">else</span> {    <span class="keyword">await</span> defConfig()    <span class="comment">// 同上</span>    <span class="keyword">await</span> dlAction()  }}<span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">dlAction</span>(<span class="params"></span>) </span>{  <span class="comment">// 清空模板文件夹的相关内容，用法见 fs-extra 的 README.md</span>  <span class="keyword">try</span> {    <span class="keyword">await</span> fse.remove(tplPath)  } <span class="keyword">catch</span> (err) {    <span class="built_in">console</span>.error(err)    process.exit()  }  <span class="comment">// 读取配置，用于获取镜像链接</span>  <span class="keyword">const</span> jsonConfig = <span class="keyword">await</span> fse.readJson(cfgPath)  <span class="comment">// Spinner 初始设置</span>  <span class="keyword">const</span> dlSpinner = ora(chalk.cyan(<span class="string">'Downloading template...'</span>))  <span class="comment">// 开始执行等待动画</span>  dlSpinner.start()  <span class="keyword">try</span> {    <span class="comment">// 下载模板后解压</span>    <span class="keyword">await</span> download(jsonConfig.mirror + <span class="string">'template.zip'</span>, path.resolve(__dirname, <span class="string">'../template/'</span>), {      extract: <span class="literal">true</span>    });  } <span class="keyword">catch</span> (err) {    <span class="comment">// 下载失败时提示</span>    dlSpinner.text = chalk.red(<span class="string">`Download template failed. <span class="subst">${err}</span>`</span>)    <span class="comment">// 终止等待动画并显示 X 标志</span>    dlSpinner.fail()    process.exit()  }  <span class="comment">// 下载成功时提示</span>  dlSpinner.text = <span class="string">'Download template successful.'</span>  <span class="comment">// 终止等待动画并显示 ✔ 标志</span>  dlSpinner.succeed()}<span class="comment">// 将上面的 dlTemplate() 方法导出</span><span class="built_in">module</span>.exports = dlTemplate</code></pre><p>我们先用 <code>fse.remove()</code> 清空模板文件夹的内容（不考虑模板文件夹存在与否，因为文件夹不存在不会报错），然后执行等待动画并请求下载，模板文件名固定为 <code>template.zip</code>，<code>download</code> 语句里的 <code>extract:true</code> 表示开启解压。上述代码有两处加了 <code>process.exit()</code>，意味着将强制进程尽快退出（有点类似 return 的作用，只不过 <code>process.exit()</code> 结束的是整个进程），哪怕还有未完全完成的异步操作。就比如说第二个 <code>process.exit()</code> 吧，当你镜像链接处于 404 或者其他状态，它会返回你相应的报错信息并退出进程，就不会继续执行下面 <code>dlSpinner.text</code> 语句了。我们还需要把 <code>template</code> 命令声明一下，打开 <code>bin/index.js</code> 文件，在合适的位置添加以下代码：</p><pre><code class="highlight js"><span class="comment">// 请求 lib/download.js</span><span class="keyword">const</span> dlTemplate = <span class="built_in">require</span>(<span class="string">'../lib/download'</span>)<span class="comment">// template 下载/更新模板</span>program  .command(<span class="string">'template'</span>)  .description(<span class="string">"Download template from mirror."</span>)  .action(<span class="function"><span class="params">()</span> =&gt;</span> {    dlTemplate()  })</code></pre><p>打开控制台，输入命令 <code>js-plugin-cli template</code>将直接报错返回，提示 404 Not Found，那是因为我还没把模板文件上传到服务器上。等把模板上传后就能正确显示了。</p><h1 id="init-初始化项目"><a href="#init-初始化项目" class="headerlink" title="init 初始化项目"></a><strong>init 初始化项目</strong></h1><p>接下来是咱们最主要的 init 命令，init 初始化项目涉及的逻辑比其他模板相对较多，所以放在最后解析。初始化项目的命令是 <code>js-plugin-cli init 项目名</code>，所以我们需要把 <code>项目名</code> 作为文件夹的名称，也是项目内 <code>package.json</code> 的 <code>name</code> 名称（只能小写，所以需要转换）。由于模板是用于开发 js 插件，也就需要抛出全局函数名称（比如 <code>import Antd from 'ant-design-vue'</code> 的 <code>Antd</code>），所以我们还需要把模板的全局函数名称抛给用户来定义，通过控制台之间的交互来实现。完成交互后，脚手架会把用户输入的内容替换到模板内容内，整个完整的逻辑导图如下：</p><p><img src="https://LuyiaGoe.github.io/assets/posts/cli-mind-3.png" alt=""></p><p>打开 <code>lib/init.js</code> 文件，添加以下代码：</p><pre><code class="highlight js"><span class="comment">// 请求 fs-extra 库，用于文件操作</span><span class="keyword">const</span> fse = <span class="built_in">require</span>(<span class="string">'fs-extra'</span>)<span class="comment">// 请求 ora 库，用于初始化项目时等待动画</span><span class="keyword">const</span> ora = <span class="built_in">require</span>(<span class="string">'ora'</span>)<span class="comment">// 请求 chalk 库</span><span class="keyword">const</span> chalk = <span class="built_in">require</span>(<span class="string">'chalk'</span>)<span class="comment">// 请求 log-symbols 库</span><span class="keyword">const</span> symbols = <span class="built_in">require</span>(<span class="string">'log-symbols'</span>)<span class="comment">// 请求 inquirer 库，用于控制台交互</span><span class="keyword">const</span> inquirer = <span class="built_in">require</span>(<span class="string">'inquirer'</span>)<span class="comment">// 请求 handlebars 库，用于替换模板字符</span><span class="keyword">const</span> handlebars = <span class="built_in">require</span>(<span class="string">'handlebars'</span>)<span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)<span class="comment">// 请求 download.js 文件，模板不在本地时执行该操作</span><span class="keyword">const</span> dlTemplate = <span class="built_in">require</span>(<span class="string">'./download'</span>)<span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">initProject</span>(<span class="params">projectName</span>) </span>{  <span class="keyword">try</span> {    <span class="keyword">const</span> exists = <span class="keyword">await</span> fse.pathExists(projectName)    <span class="keyword">if</span> (exists) {      <span class="comment">// 项目重名时提醒用户</span>      <span class="built_in">console</span>.log(symbols.error, chalk.red(<span class="string">'The project already exists.'</span>))    } <span class="keyword">else</span> {      <span class="comment">// 执行控制台交互</span>      inquirer        .prompt([{          type: <span class="string">'input'</span>, <span class="comment">// 类型，其他类型看官方文档</span>          name: <span class="string">'name'</span>, <span class="comment">// 名称，用来索引当前 name 的值</span>          message: <span class="string">'Set a global name for javascript plugin?'</span>,          <span class="keyword">default</span>: <span class="string">'Default'</span>, <span class="comment">// 默认值，用户不输入时用此值</span>        }, ])        .then(<span class="keyword">async</span> (answers) =&gt; {          <span class="comment">// Spinner 初始设置</span>          <span class="keyword">const</span> initSpinner = ora(chalk.cyan(<span class="string">'Initializing project...'</span>))          <span class="comment">// 开始执行等待动画</span>          initSpinner.start()          <span class="comment">// 拼接 template 文件夹路径</span>          <span class="keyword">const</span> templatePath = path.resolve(__dirname, <span class="string">'../template/'</span>)          <span class="comment">// 返回 Node.js 进程的当前工作目录</span>          <span class="keyword">const</span> processPath = process.cwd()          <span class="comment">// 把项目名转小写</span>          <span class="keyword">const</span> LCProjectName = projectName.toLowerCase()          <span class="comment">// 拼接项目完整路径</span>          <span class="keyword">const</span> targetPath = <span class="string">`<span class="subst">${processPath}</span>/<span class="subst">${LCProjectName}</span>`</span>          <span class="comment">// 先判断模板路径是否存在</span>          <span class="keyword">const</span> exists = <span class="keyword">await</span> fse.pathExists(templatePath)          <span class="keyword">if</span> (!exists) {            <span class="comment">// 不存在时，就先等待下载模板，下载完再执行下面的语句</span>            <span class="keyword">await</span> dlTemplate()          }          <span class="comment">// 等待复制好模板文件到对应路径去</span>          <span class="keyword">try</span> {            <span class="keyword">await</span> fse.copy(templatePath, targetPath)          } <span class="keyword">catch</span> (err) {            <span class="built_in">console</span>.log(symbols.error, chalk.red(<span class="string">`Copy template failed. <span class="subst">${err}</span>`</span>))            process.exit()          }          <span class="comment">// 把要替换的模板字符准备好</span>          <span class="keyword">const</span> multiMeta = {            project_name: LCProjectName,            global_name: answers.name          }          <span class="comment">// 把要替换的文件准备好</span>          <span class="keyword">const</span> multiFiles = [            <span class="string">`<span class="subst">${targetPath}</span>/package.json`</span>,            <span class="string">`<span class="subst">${targetPath}</span>/gulpfile.js`</span>,            <span class="string">`<span class="subst">${targetPath}</span>/test/index.html`</span>,            <span class="string">`<span class="subst">${targetPath}</span>/src/index.js`</span>          ]          <span class="comment">// 用条件循环把模板字符替换到文件去</span>          <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; multiFiles.length; i++) {            <span class="comment">// 这里记得 try {} catch {} 哦，以便出错时可以终止掉 Spinner</span>            <span class="keyword">try</span> {              <span class="comment">// 等待读取文件</span>              <span class="keyword">const</span> multiFilesContent = <span class="keyword">await</span> fse.readFile(multiFiles[i], <span class="string">'utf8'</span>)              <span class="comment">// 等待替换文件，handlebars.compile(原文件内容)(模板字符)</span>              <span class="keyword">const</span> multiFilesResult = <span class="keyword">await</span> handlebars.compile(multiFilesContent)(multiMeta)              <span class="comment">// 等待输出文件</span>              <span class="keyword">await</span> fse.outputFile(multiFiles[i], multiFilesResult)            } <span class="keyword">catch</span> (err) {              <span class="comment">// 如果出错，Spinner 就改变文字信息</span>              initSpinner.text = chalk.red(<span class="string">`Initialize project failed. <span class="subst">${err}</span>`</span>)              <span class="comment">// 终止等待动画并显示 X 标志</span>              initSpinner.fail()              <span class="comment">// 退出进程</span>              process.exit()            }          }          <span class="comment">// 如果成功，Spinner 就改变文字信息</span>          initSpinner.text = <span class="string">'Initialize project successful.'</span>          <span class="comment">// 终止等待动画并显示 ✔ 标志</span>          initSpinner.succeed()          <span class="built_in">console</span>.log(<span class="string">`</span><span class="string">            To get started:</span><span class="string"></span><span class="string">              cd <span class="subst">${chalk.yellow(LCProjectName)}</span></span><span class="string">              <span class="subst">${chalk.yellow(<span class="string">'npm install'</span>)}</span> or <span class="subst">${chalk.yellow(<span class="string">'yarn install'</span>)}</span></span><span class="string">              <span class="subst">${chalk.yellow(<span class="string">'npm run dev'</span>)}</span> or <span class="subst">${chalk.yellow(<span class="string">'yarn run dev'</span>)}</span></span><span class="string">          `</span>)        })        .catch(<span class="function">(<span class="params">error</span>) =&gt;</span> {          <span class="keyword">if</span> (error.isTtyError) {            <span class="built_in">console</span>.log(symbols.error, chalk.red(<span class="string">"Prompt couldn't be rendered in the current environment."</span>))          } <span class="keyword">else</span> {            <span class="built_in">console</span>.log(symbols.error, chalk.red(error))          }        })    }  } <span class="keyword">catch</span> (err) {    <span class="built_in">console</span>.error(err)    process.exit()  }}<span class="comment">// 将上面的 initProject(projectName) 方法导出</span><span class="built_in">module</span>.exports = initProject</code></pre><p><code>lib/init.js</code> 的代码相对较长，建议先熟悉上述的逻辑示意图，了解这么写的意图后就能明白上述的代码啦！抽主要的片段解析：<strong>inquirer 取值说明</strong><code>inquirer.prompt</code> 中的字段 <code>name</code> 类似 key，当你需要获取该值时，应以 <code>answers.key对应值</code> 形式获取（<code>answers</code> 命名取决于 <code>.then(answers =&gt; {})</code>），例：</p><pre><code class="highlight js">inquirer.prompt([{  type: <span class="string">'input'</span>, <span class="comment">// 类型，其他类型看官方文档</span>  name: <span class="string">'theme'</span>, <span class="comment">// 名称，用来索引当前 name 的值</span>  message: <span class="string">'Pick a theme?'</span>,  <span class="keyword">default</span>: <span class="string">'Default'</span>, <span class="comment">// 默认值，用户不输入时用此值</span>}, ]).then(<span class="function"><span class="params">answers</span> =&gt;</span> {})</code></pre><p>上述要获取对应值应该为 <code>answers.theme</code>。<strong>handlebars 模板字符设置说明</strong>我们事先需要把模板文件内要修改的字符串改成 <code></code> 形式，然后才能用 <code>handlebars.compile</code> 进行替换，为了保证代码可读性，我们把模板字符整成 <code>{ key:value }</code> 形式，然后 <code>key</code> 对应定义名称，<code>value</code> 对应要替换的模板字符，例：</p><pre><code class="highlight js"><span class="keyword">const</span> multiMeta = {  project_name: LCProjectName,  global_name: answers.name}</code></pre><p>上述代码意味着模板文件内要修改的字符串改成 <code></code> 或者 <code></code> 形式，当被替换时，将改成后面对应的模板字符。下图是模板文件：</p><p><img src="https://LuyiaGoe.github.io/assets/posts/cli-model.png" alt=""></p><p>接下来我们把 <code>init</code> 命令声明一下，打开 <code>bin/index.js</code> 文件，在合适的位置添加以下代码：</p><pre><code class="highlight js"><span class="comment">// 请求 lib/init.js</span><span class="keyword">const</span> initProject = <span class="built_in">require</span>(<span class="string">'../lib/init'</span>)<span class="comment">// init 初始化项目</span>program  .name(<span class="string">'js-plugin-cli'</span>)  .usage(<span class="string">'&lt;commands&gt; [options]'</span>)  .command(<span class="string">'init &lt;project_name&gt;'</span>)  .description(<span class="string">'Create a javascript plugin project.'</span>)  .action(<span class="function"><span class="params">project</span> =&gt;</span> {    initProject(project)  })</code></pre><p>这样就完成整个脚手架的搭建了~然后可以发布到 npm，以全局安装方式进行安装（记得 <code>npm unlink</code> 解除连接哦）。</p><h1 id="写在最最最后"><a href="#写在最最最后" class="headerlink" title="写在最最最后"></a><strong>写在最最最后</strong></h1><p>这篇文章花了几天时间（含写脚手架 demo 的时间）编辑的，时间比较匆赶，若在语句上表达不够明白或者错误，欢迎掘友指出哦~最后附上项目源码：<strong>js-plugin-cli</strong>[11] ，脚手架已经发布到 npm，欢迎小伙伴试用哦！</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a><strong>参考资料</strong></h3><p>[1]chalk: <em><a href="https://www.npmjs.com/package/chalk" target="_blank" rel="noopener">https://www.npmjs.com/package/chalk</a></em></p><p>[2]commander: <em><a href="https://www.npmjs.com/package/commander" target="_blank" rel="noopener">https://www.npmjs.com/package/commander</a></em></p><p>[3]download: <em><a href="https://www.npmjs.com/package/download" target="_blank" rel="noopener">https://www.npmjs.com/package/download</a></em></p><p>[4]fs-extra: <em><a href="https://www.npmjs.com/package/fs-extra" target="_blank" rel="noopener">https://www.npmjs.com/package/fs-extra</a></em></p><p>[5]handlebars: <em><a href="https://www.npmjs.com/package/handlebars" target="_blank" rel="noopener">https://www.npmjs.com/package/handlebars</a></em></p><p>[6]inquirer: <em><a href="https://www.npmjs.com/package/inquirer" target="_blank" rel="noopener">https://www.npmjs.com/package/inquirer</a></em></p><p>[7]log-symbols: <em><a href="https://www.npmjs.com/package/log-symbols" target="_blank" rel="noopener">https://www.npmjs.com/package/log-symbols</a></em></p><p>[8]ora: <em><a href="https://www.npmjs.com/package/ora" target="_blank" rel="noopener">https://www.npmjs.com/package/ora</a></em></p><p>[9]update-notifier: <em><a href="https://www.npmjs.com/package/update-notifier" target="_blank" rel="noopener">https://www.npmjs.com/package/update-notifier</a></em></p><p>[10]fs-extra: <em><a href="https://www.npmjs.com/package/fs-extra" target="_blank" rel="noopener">https://www.npmjs.com/package/fs-extra</a></em></p><p>[11]js-plugin-cli: <em><a href="https://github.com/zpfz/js-plugin-cli/" target="_blank" rel="noopener">https://github.com/zpfz/js-plugin-cli/</a></em></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Front-End </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Front-End </tag>
            
            <tag> Cli </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Web Component</title>
      <link href="2021/11/22/%E5%BE%85%E5%88%B6%E4%BD%9C/Web-Component/"/>
      <url>2021/11/22/%E5%BE%85%E5%88%B6%E4%BD%9C/Web-Component/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>​        我们在不断地进行前端开发时，总会碰到需要用到之前做到的一些组件，此时直接找原来的代码整段复制粘贴效率并不是很理想——毕竟我们也不想在一大堆代码中找那么几行，还要理清样式，甚至更大可能做完上述工作后，还要再找它的方法进行修修改改。如此下来效率低下是个问题，万一这个组件某些部分跟项目其他冲突了又是个令人烦躁的事情，比如样式污染，原组件的方法与项目耦合度高等等。</p><p>​        此时，组件化开发的思想便能很好地解决上述问题，正好也有这么一套原生的技术提供给我们进行组件化开发，那便是<code>Web Components</code>：</p><blockquote><p>利用这种技术，我们可以描述一个可重用的且带有自己方法、属性和事件等的类来创建自定义HTML元素，如此便能像使用内置标签一样使用自定义元素</p></blockquote><h1 id="使用简介"><a href="#使用简介" class="headerlink" title="使用简介"></a>使用简介</h1><p>自定义元素（<code>Custom Element</code>）有两种</p><blockquote><p><strong>Autonomous custom elements （自主自定义标签）</strong> —— “全新的” 元素, 继承自 <code>HTMLElement</code> 抽象类</p></blockquote><blockquote><p><strong>Customized built-in elements （自定义内置元素）</strong> —— 继承内置的 HTML 元素，比如自定义 <code>HTMLButtonElement</code> 等</p></blockquote><h2 id="Autonomous-custom-elements"><a href="#Autonomous-custom-elements" class="headerlink" title="Autonomous custom elements"></a>Autonomous custom elements</h2><p>​        其中基本方法包括：</p><pre><code class="highlight js"><span class="class"><span class="keyword">class</span> <span class="title">MyElement</span> <span class="keyword">extends</span> <span class="title">HTMLElement</span> </span>{  <span class="keyword">constructor</span>() {    <span class="keyword">super</span>();    <span class="comment">// 元素在这里创建</span>  }  connectedCallback() {    <span class="comment">// 在元素被添加到文档之后，浏览器会调用这个方法，因此渲染也最好是放在这里</span>    <span class="comment">// 但是在这里并不能用同步的方法访问到自定义元素的子元素（因为子元素还没连上DOM）</span>    <span class="comment">//（如果一个元素被反复添加到文档／移除文档，那么这个方法会被多次调用）</span>  }  disconnectedCallback() {    <span class="comment">// 在元素从文档移除的时候，浏览器会调用这个方法</span>    <span class="comment">// （如果一个元素被反复添加到文档／移除文档，那么这个方法会被多次调用）</span>  }  <span class="keyword">static</span> <span class="keyword">get</span> observedAttributes() {    <span class="keyword">return</span> [<span class="comment">/* 属性数组，这些属性的变化会被监视 */</span>];  }  attributeChangedCallback(name, oldValue, newValue) {    <span class="comment">// 当上面数组中的属性发生变化的时候，这个方法会被调用</span>  }  adoptedCallback() {    <span class="comment">// 在元素被移动到新的文档的时候，这个方法会被调用</span>    <span class="comment">// （document.adoptNode 会用到, 非常少见）</span>  }  <span class="comment">// 还可以添加更多的元素方法和属性</span>}</code></pre><p>​        在申明上述方法后，需要进行组件注册：</p><pre><code class="highlight js"><span class="comment">// 让浏览器知道我们新定义的类是为 &lt;my-element&gt; 服务的</span>customElements.define(<span class="string">"my-element"</span>, MyElement);</code></pre><p>​        如此每当页面中添加了一个<code>&lt;my-element&gt;</code>，<code>MyElement</code>类便会实例化一遍，如果没有注册组件，页面中的自定义元素将会被识别为一个未知元素，并且，<strong>自定义元素必须包含一个短横线‘-’</strong>。</p><h3 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h3><blockquote><p><code>:not(:defined)</code> CSS 选择器可以对「未定义」的元素加上样式。</p></blockquote><h2 id="Customized-built-in-elements"><a href="#Customized-built-in-elements" class="headerlink" title="Customized built-in elements"></a>Customized built-in elements</h2><p>​        <code>Autonomous custom elements</code>创建的标签并不带语义，搜索引擎不会识别，同时无障碍设备也无法处理。因此为了解决以上问题我们可以通过继承<code>HTML</code>已有的元素来进行自定义拓展来解决。</p><p>​        其基本方法与<code>Autonomous custom elements</code>类似：</p><pre><code class="highlight html"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="actionscript"><span class="class"><span class="keyword">class</span> <span class="title">HelloButton</span> <span class="keyword">extends</span> <span class="title">HTMLButtonElement</span> </span>{ <span class="comment">/* custom element 方法 */</span> }</span><span class="actionscript">customElements.define(<span class="string">'hello-button'</span>, HelloButton, {<span class="keyword">extends</span>: <span class="string">'button'</span>});</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span><span class="tag">&lt;<span class="name">button</span> <span class="attr">is</span>=<span class="string">"hello-button"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">button</span>&gt;</span></code></pre><p>​        </p><h1 id="影子DOM"><a href="#影子DOM" class="headerlink" title="影子DOM"></a>影子DOM</h1><p>​        当我们采用封装的形式，就不想它会被项目其他的样式或者方法所影响，这时候我们需要将其隔离起来，就能用到影子<code>DOM</code>，</p><blockquote><p>Shadow DOM 为封装而生。它可以让一个组件拥有自己的「影子」DOM 树，这个 DOM 树不能在主文档中被任意访问，可能拥有局部样式规则，还有其他特性。</p></blockquote><h2 id="内建shadow-DOM"><a href="#内建shadow-DOM" class="headerlink" title="内建shadow DOM"></a>内建shadow DOM</h2><p>​        我们可以在一个页面上放入<code>&lt;input type="range"&gt;</code>，接着在开发者工具中打开「Show user agent shadow DOM」选项，我们就可以在文档树中看到如下结构：</p><p><img src="https://LuyiaGoe.github.io/assets/posts/input.range.png" alt=""></p><p>​        这之中<code>#shadow-root</code> 下看到的就是被称为「shadow DOM」的东西。</p><h2 id="Shadow-tree"><a href="#Shadow-tree" class="headerlink" title="Shadow tree"></a>Shadow tree</h2><p>​        一个DOM元素可以拥有两种DOM子树：</p><blockquote><p>Light tree（光明树） —— 一个常规 DOM 子树，由 HTML 子元素组成。我们在之前章节看到的所有子树都是「光明的」</p></blockquote><blockquote><p>Shadow tree（影子树） —— 一个隐藏的 DOM 子树，不在 HTML 中反映，无法被察觉</p></blockquote><p>​        如果一个元素同时有以上两种子树，那么浏览器只渲染 shadow tree，但是可以通过插槽结合两种树。影子树可以在自定义元素中被使用，其作用是<strong>隐藏组件内部结构</strong>和<strong>添加只在组件内有效的样式</strong>。</p><p>​        影子树的构建方式如下：</p><pre><code class="highlight html"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="actionscript">customElements.define(<span class="string">'show-hello'</span>, <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">HTMLElement</span> </span>{</span>  connectedCallback() {<span class="actionscript">    <span class="keyword">const</span> shadow = <span class="keyword">this</span>.attachShadow({mode: <span class="string">'open'</span>});  <span class="comment">// 创建一个shadow tree</span></span><span class="handlebars"><span class="xml">    shadow.innerHTML = `<span class="tag">&lt;<span class="name">p</span>&gt;</span></span></span><span class="actionscript">      Hello, ${<span class="keyword">this</span>.getAttribute(<span class="string">'name'</span>)}</span><span class="handlebars"><span class="xml">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span>`;</span></span>  }});<span class="tag">&lt;/<span class="name">script</span>&gt;</span><span class="tag">&lt;<span class="name">show-hello</span> <span class="attr">name</span>=<span class="string">"John"</span>&gt;</span><span class="tag">&lt;/<span class="name">show-hello</span>&gt;</span></code></pre><p>其中：</p><ol><li><p>在每个元素中，我们只能创建一个 shadow root</p></li><li><p><code>elem</code>  必须是自定义元素，或者是以下元素的其中一个：「article」、「aside」、「blockquote」、「body」、「div」、「footer」、「h1…h6」、「header」、「main」、「nav」、「p」、「section」或者「span」。其他元素，比如 <code>&lt;img&gt;</code>，不能容纳 shadow tree</p></li><li><p><code>mode</code> 选项可以设定封装层级。他必须是以下两个值之一：</p><ul><li><code>「open」</code> —— shadow root 可以通过 <code>elem.shadowRoot</code> 访问</li><li><code>「closed」</code> —— <code>elem.shadowRoot</code> 永远是 `null</li></ul></li><li><p><code>attachShadow</code> 返回的 <code>shadow root</code>，和任何元素一样：我们可以使用 <code>innerHTML</code> 或者 DOM 方法，比如 <code>append</code> 来扩展它</p></li><li><p>拥有<code>shadow root</code>的元素叫做「shadow tree host」，可以通过<code>shadow root</code>的<code>host</code>属性访问到</p></li><li><p>影子树外的主文档的<code>JS</code>选择器无法获取它的<code>DOM</code>，样式同样也无法被影响到</p></li></ol><h1 id="Shadow-DOM插槽"><a href="#Shadow-DOM插槽" class="headerlink" title="Shadow DOM插槽"></a>Shadow DOM插槽</h1><p>​        当我们采用影子树时，外部文档将无法控制影子DOM，那怎么做到定制化使用组件呢？此时我们可以用光明树结合影子树做到控制组件，两者的关键便在于插槽。</p><h2 id="具名插槽"><a href="#具名插槽" class="headerlink" title="具名插槽"></a>具名插槽</h2><p>举例：</p><pre><code class="highlight html"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="actionscript">customElements.define(<span class="string">'user-card'</span>, <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">HTMLElement</span> </span>{</span>  connectedCallback() {<span class="actionscript">    <span class="keyword">this</span>.attachShadow({mode: <span class="string">'open'</span>});</span><span class="actionscript">    <span class="keyword">this</span>.shadowRoot.innerHTML = `</span><span class="handlebars"><span class="xml">      <span class="tag">&lt;<span class="name">div</span>&gt;</span>Name:</span></span><span class="handlebars"><span class="xml">        <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">"username"</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span></span><span class="handlebars"><span class="xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><span class="handlebars"><span class="xml">      <span class="tag">&lt;<span class="name">div</span>&gt;</span>Birthday:</span></span><span class="handlebars"><span class="xml">        <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">"birthday"</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span></span><span class="handlebars"><span class="xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span>    `;  }});<span class="tag">&lt;/<span class="name">script</span>&gt;</span><span class="tag">&lt;<span class="name">user-card</span>&gt;</span>  <span class="tag">&lt;<span class="name">span</span> <span class="attr">slot</span>=<span class="string">"username"</span>&gt;</span>John Smith<span class="tag">&lt;/<span class="name">span</span>&gt;</span>  <span class="tag">&lt;<span class="name">span</span> <span class="attr">slot</span>=<span class="string">"birthday"</span>&gt;</span>01.01.2001<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">user-card</span>&gt;</span></code></pre><p>​        在 shadow DOM 中，<code>&lt;slot name="X"&gt;</code> 定义了一个“插入点”，一个带有 <code>slot="X"</code> 的元素被渲染的地方。</p><p>​        然后浏览器执行”组合”：它从 light DOM 中获取元素并且渲染到 shadow DOM 中的对应插槽中。最后，正是我们想要的 —— 一个能被填充数据的通用组件。</p><p>​        这是编译后，不考虑组合的 DOM 结构：</p><pre><code class="highlight html"><span class="tag">&lt;<span class="name">user-card</span>&gt;</span>  #shadow-root    <span class="tag">&lt;<span class="name">div</span>&gt;</span>Name:     <span class="comment">&lt;!-- 位置一 --&gt;</span>      <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">"username"</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span>     <span class="tag">&lt;/<span class="name">div</span>&gt;</span>    <span class="tag">&lt;<span class="name">div</span>&gt;</span>Birthday:      <span class="comment">&lt;!-- 位置二 --&gt;</span>      <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">"birthday"</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span>    <span class="tag">&lt;/<span class="name">div</span>&gt;</span>  <span class="comment">&lt;!-- 会被填充入位置一 --&gt;</span>  <span class="tag">&lt;<span class="name">span</span> <span class="attr">slot</span>=<span class="string">"username"</span>&gt;</span>John Smith<span class="tag">&lt;/<span class="name">span</span>&gt;</span>  <span class="comment">&lt;!-- 会被填充入位置二 --&gt;</span>  <span class="tag">&lt;<span class="name">span</span> <span class="attr">slot</span>=<span class="string">"birthday"</span>&gt;</span>01.01.2001<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">user-card</span>&gt;</span></code></pre><p>​        渲染后，在开发者工具中我们可以看到：</p><pre><code class="highlight HTML"><span class="tag">&lt;<span class="name">user-card</span>&gt;</span>  #shadow-root    <span class="tag">&lt;<span class="name">div</span>&gt;</span>Name:      <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">"username"</span>&gt;</span>        <span class="comment">&lt;!-- slotted element is inserted into the slot --&gt;</span>        <span class="tag">&lt;<span class="name">span</span> <span class="attr">slot</span>=<span class="string">"username"</span>&gt;</span>John Smith<span class="tag">&lt;/<span class="name">span</span>&gt;</span>      <span class="tag">&lt;/<span class="name">slot</span>&gt;</span>    <span class="tag">&lt;/<span class="name">div</span>&gt;</span>    <span class="tag">&lt;<span class="name">div</span>&gt;</span>Birthday:      <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">"birthday"</span>&gt;</span>        <span class="tag">&lt;<span class="name">span</span> <span class="attr">slot</span>=<span class="string">"birthday"</span>&gt;</span>01.01.2001<span class="tag">&lt;/<span class="name">span</span>&gt;</span>      <span class="tag">&lt;/<span class="name">slot</span>&gt;</span>    <span class="tag">&lt;/<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">user-card</span>&gt;</span></code></pre><blockquote><p>但是！这种扁平化DOM仅仅用作渲染和事件传播，是虚拟的，实际上的节点并没有被移动，可以通过<code>document.querySelector</code>验证。</p></blockquote><blockquote></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Front-End </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> Front-End </tag>
            
            <tag> Gaia </tag>
            
            <tag> Component </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>随手记项目小结</title>
      <link href="2021/06/01/React/%E9%9A%8F%E6%89%8B%E8%AE%B0%E9%A1%B9%E7%9B%AE%E5%B0%8F%E7%BB%93/"/>
      <url>2021/06/01/React/%E9%9A%8F%E6%89%8B%E8%AE%B0%E9%A1%B9%E7%9B%AE%E5%B0%8F%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h2 id="项目描述"><a href="#项目描述" class="headerlink" title="项目描述"></a>项目描述</h2><blockquote><p>这是一个具备记录、保存、编辑账单的记账本应用，你可以在里面看到日周月年的流水记录，可以看到本月支出分类前三数据，还能看到自己资产金额，也可以根据不同的条件查询账单流水，还可以通过设置本月预算来辅助进行开销规划。</p></blockquote><p><a href="https://luyiagoe.github.io/account-books" target="_blank" rel="noopener">展示页</a></p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ol><li>准备UI界面</li><li>准备项目搭建，项目用到：<ul><li><code>react</code></li><li><code>react-redux</code></li><li><code>react-router</code></li><li><code>Ant-design</code></li><li>其他小插件，如随机数插件<code>number-random</code>、部署项目插件<code>gh-pages</code></li></ul></li></ol><h2 id="项目亮点"><a href="#项目亮点" class="headerlink" title="项目亮点"></a>项目亮点</h2><h2 id="级联组件的制作封装"><a href="#级联组件的制作封装" class="headerlink" title="级联组件的制作封装"></a>级联组件的制作封装</h2><blockquote><p>考虑做一个类似数字密码锁样式的滚筒UI，做法如下：</p></blockquote><ol><li>视窗确定：<ul><li>使用<code>card</code>作为视图窗口，定位两根横线，横线中间的信息为选择项</li><li>视窗分为两侧，左侧为一级选择器，右侧为二级选择器</li></ul></li><li>3D视图参数<ul><li><code>perspective</code>取400px，滚筒设定为最多显示5个数据，每个数据的角度差值为<code>30deg</code>，因此角度区间取值为<code>[-60°,60°]</code></li><li>每次滚动时，滚动角度为30°</li></ul></li><li>传入传出数据<ul><li>传入API为：obj</li><li>传入数据考虑为对象，键名为一级选择器选项，值为一个数组，为二级选择器选项</li><li>收到传入数据时，首先遍历数据对象，取出键并放入一个数组中，该数组前端有两个空元素，该数组用于填充选择器的左端</li><li>考虑用两个<code>selected</code>开头的标识，也可以视为指针，来辅助指向选中的一、二级信息位于数组的位置，同时为选择器指出渲染的起始位置</li><li>传出数据用数组形式，第一个元素为一级选择器内容，第二个为二级选择器内容</li></ul></li><li>动画实现，采用纯css实现<ul><li>因为用纯CSS实现的滚动效果，因此该版本无拖动滚动事件，考虑之后添加</li><li>目前选择器有四个区域可以点击，分别控制一二级选择器进行上下滑动选择</li><li>事件通过传入一个<code>ref</code>和<code>滚动事件</code>(上滚、下滚)，为目标选择器添加一个带动画的<code>className</code>，在动画结束后删除类名、更新选择器并渲染，<strong>且为了防止同组件间的相互干扰</strong>，<strong>因此需要将selected选中项放到state中</strong></li><li>因为采用css动画，为了能在动画结束并删除后，正确显示选中的选项，需要进行更新<code>state</code>，设定一个函数<code>edit</code>，用于更新<code>selected</code>指针，更新完后并用副作用函数提供的方法<code>setState({...state})</code>更新一下组件</li><li>然后就出现了<strong>无限循环渲染</strong>问题，因为<code>edit</code>还有个作用是更新完<code>selected</code>后，会将新的渲染数组包装成h5标签并给组件<code>render</code>，因此我在组件的初始化中便调用了该函数，于是乎初始化→更新→更新……停不下来</li><li>在<code>edit</code>中加入一个条件，当传入第一个参数为0时，跳过更新渲染，直接返回当前指针指定的数组标签族，当为1时，对应选择器的<code>selected+1</code>、选择器上翻并且渲染更新，于是跳出了无限循环渲染</li></ul></li><li>数据处理<ul><li>对传入的<code>props</code>设置为该组件的<code>state</code>，并且给予对应的<code>setState</code>，取出键名作为一级选择器选项</li><li>初次渲染和每次更新渲染时，用<code>useEffect</code>将选择器选中项，以数组的形式传给父组件<ul><li>然后，又出现了死循环，原因是通过<code>useEffect</code>向父组件传值，父组件更新连带着该组件<code>useEffect</code>被触发，从而陷入了循环</li></ul></li></ul></li></ol><h2 id="计算器封装"><a href="#计算器封装" class="headerlink" title="计算器封装"></a>计算器封装</h2><ol><li>UI考虑<ul><li>考虑到是iPad端，需要有按键反馈提升用户体验，按钮不能“一按不起”，用3d摁下动作复杂、风格不符且性价比低，因此通过摁下抬起时的阴影变化提升反馈体验</li><li>按钮最好不要颜色单一，功能键颜色需要突出，且单一按键最好加上渐变色</li></ul></li><li>实现<ul><li>通过组件最外层放一个事件委托，获取点击的按钮的目标值</li><li>用一个数组接到目标值，设置一个<strong>扳手</strong><ul><li>扳手的作用是每当数组中有一个运算符，便+1，或数组中传入了一个<code>=</code>时，便变成2</li><li><strong>一旦扳手的值为2时，计算器运行计算</strong></li><li>同时扳手也是判断计算器显示=（运算）或ok（退出计算器）的标识，所以扳手放在组件state中</li></ul></li></ul></li><li>功能细节<ul><li>不止可以通过<code>=</code>进行计算，两个<code>+</code>或两个<code>-</code>或一样一个都可以进行运算，不过此时将会根据第一个运算符号，进行自加/自减</li><li>小数点不能在一个数字中出现两次，因此需要一个标记flag控制，当进入下一个数字的输入时，才再次放开控制，下一次输入数字的情况有：<ul><li>点击<code>C + - =</code></li></ul></li><li>因为开启了严格模式，这个组件也是通过eval形式进行运算的，所以<strong>要防止0开头的数字被认为是八进制</strong>，从而报错，所以要在每一个运算数字输入前对<code>0</code>的输入进行控制</li><li><code>OK</code>不仅承担了关闭计算器的功能，还需要调用函数向父组件传值</li></ul></li><li>接口API: initialNum={state.count} closeCalcu={closeCalcu} outPut={outPut}<ul><li><code>initialNum</code>负责从父组件获得一个初始值并作为初始值展示，不传值默认为0，类型： Number</li><li><code>closeCalcu</code>点击<code>ok</code>后调用的函数，类型： Function</li><li><code>outPut</code>每次运算获得数值后调用的函数，函数携带结果，用于向父组件传值，类型： Function</li></ul></li></ol><h2 id="流水页面"><a href="#流水页面" class="headerlink" title="流水页面"></a>流水页面</h2><ol><li>从今日流水开始，对dayStream传入今日时间利用查询reducer获取相应数据展示</li><li>接着获取weekStream时间，在组件中对时间进行拆分传入dayStream</li><li>以此类推完成monthStream和yearStream</li><li>再辅以一些小细节，如年流水不显示周收支合计，月年流水需要在展开头中显示收支结余进度条等等</li><li>资产流水则从月单位出发，查询今年的收支</li></ol><h2 id="查询页面"><a href="#查询页面" class="headerlink" title="查询页面"></a>查询页面</h2><ol><li>查询则不以今年为限制，可以查询符合相应条件的所有账单</li><li>首页没有数据所以要展示一个大图标，辅助用户添加筛选条件</li><li>筛选选项用一个弹出气泡显示，这样用户不占空间也可以在显示页面也能切换查询条件</li></ol><h2 id="传值记录"><a href="#传值记录" class="headerlink" title="传值记录"></a>传值记录</h2><ol><li><p><code>useContext</code>传值：</p><ul><li>单纯用于传值和传递动画函数（Pay页面和IndexPage页面），不用<code>action reducer</code>修改的值</li><li>设置了全局context，在<code>src</code>中生成了一个<code>globalContext</code>文件</li><li>文件中从<code>react</code>中导入<code>createContext</code>并默认导出</li><li>在需要传出值的父级页面引入改文件并创建相应的<code>Provider</code></li><li>将数据放入<code>Provider</code>组件的value中，并用组件包裹子组件</li><li>子孙组件引入context文件并与<code>useContext</code>一同创建<code>Consumer</code></li><li>如此，可以用方法和属性的形式调用父组件传入的值</li><li>注意，<code>Consumer</code>会采用最近的父组件<code>Provider</code>传入的值</li></ul></li><li><p><code>react-redux</code>传值：</p><ul><li>用于创建、保存、编辑、删除、查询、分类、排名等用</li><li>文件分为store、constant、actions、reducers</li><li>constant最简单，用于存名，标记每个名作用是干什么</li><li>store用于分发组件的actions到reducers进行处理，以及将处理完的数据返还给组件</li><li>actions分为type和data，每一次dispatch都要传递一个type（告诉store交给哪个reducer处理）和一个data（处理啥数据）</li><li>所有的reducers都会收到store的分发，但是它们会根据type决定是不是自己需要处理的数据，不是则返回上一次处理的数据（preState）或干脆返回一个null</li><li>reducers必须返回一个值</li><li>组件分为容器组件和UI组件，容器组件从actions拿到操作方法，负责和store交互，包括操作数据、传收值，再将数据传给UI组件</li><li>在根组件用Provider包裹，并传入store</li></ul></li></ol><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><ol><li>项目色调为橘色和暗黄色</li><li>风格偏向于卡片化+横条化，记账清晰明了，这样也有利于组件封装与复用的实现</li><li>记账的数据应进行分类，考虑有：<ul><li>收入支出分类，属性为<code>pay: true(支出)/false(收入)</code>，<strong>必需属性</strong></li><li>账户分类，属性为<code>account: String</code>，<strong>必需属性</strong></li><li>日期分类，属性为<code>date: Number</code>，<strong>必需属性</strong></li><li>id分类，属性为<code>id: Number</code>，用于查具体某一单，<strong>必需属性</strong></li><li>项目分类，属性为<code>category: ['一级选择器','二级选择器']</code>，<strong>必需属性</strong></li><li>金额分类，属性为<code>count: Number</code>，<strong>必需属性</strong></li><li>备注，属性为<code>remark: String</code></li><li>成员，属性为<code>member: String</code></li></ul></li><li>根据分类，在查询<code>countData</code>时应做提交相应查询条件对象，每个分类的键值对结构应为：<ul><li>收入支出分类<code>pay:Boolean</code></li><li>账户分类<code>account: String</code></li><li>日期分类<code>date:[Number,Number]</code></li><li>id分类<code>id:Number</code></li><li>项目分类<code>category:['一级选择器'[,'二级选择器']]</code></li><li>金额分类<code>count: [Number,Number]</code></li><li>成员<code>member:String</code></li></ul></li><li>发起查询动作时，一并要提供一个查询对象，其中包含两个值，一是查询范围<code>list(component可以提供String、Array类型数据，但在reducer逻辑中时，数据结构为Array)</code>，一是查询条件<code>demand(从始至终数据结构为Object)</code></li><li>查询reducer接收到action时，会根据条件的键值对中，值的数据类型进行分类查询：<ul><li>比如<code>category count date</code>是引用数据类型，其他的是基本数据类型</li><li>基本数据类型要求是精准匹配，匹配逻辑是一样的，所以不用做区分，符合<code>demand[key]=list[key]</code>就通过</li><li>数组结构的条件，是范围查询用的，当两端取值一样时，便成了精准查值了</li><li>数组结构中也分两类，一类是<code>category</code>可以查一级选择器或查到二级选择器，一类是<code>date count</code>用于范围查找的，尤其是date，基本不能查到具体时间点的账单</li><li><blockquote><p>综上，按照查询条件中的数据结构，将查询逻辑分三类:精准查找<code>pay id member account</code>、分级查找<code>category</code>、范围查找<code>date count</code></p></blockquote></li></ul></li><li><code>list</code>查询范围可以根据传入的信息，找出相关范围的数组交给reducer按demand进行查找<ul><li><code>list</code>的值可以为<code>all today week month</code>关键字，分别是以<code>所有 今天 这周 这月</code>的账单为范围</li><li>也可以传入一个带着date数据的数组，以数组中时间内的账单为范围</li></ul></li><li>排名reducer需求数据同上，接收到需要排名的<code>list demand</code>,返回一个符合需求的数组，数组符合<code>demand</code>要求<ul><li><code>demand</code>中自带一个<code>order</code>属性，为空或者为<code>false</code>默认为降序</li><li>如果出现多个数据同级，则再按照时间顺序，从近到远排序</li></ul></li><li>修改账单与添加账单同reducer<h2 id="问题记录"><a href="#问题记录" class="headerlink" title="问题记录"></a>问题记录</h2></li><li>在antd的card组件中设置一个浮动组件，会出现被外面的组件占掉位置的情况<ul><li>推测是提供的组件没有触发BFC，通过给card组件设置overflow:hidden解决问题</li></ul></li><li>key值的设置不能为<code>Math.random()</code>，引入随机数小插件解决问题</li><li>设置BrowserRouter在github上刷新动作会出现404，因为域名是博客页面，因此用HashRouter<ul><li>当前页面只有一个params值，因此想要在同一个页面，通过params进入不同路由，需要go（-1）返回第一次通过params跳转的页面，有个不能省略的注释标记在代码中</li></ul></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Front-End </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Front-End </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>仿网易云项目</title>
      <link href="2021/04/16/Vue/%E4%BB%BF%E7%BD%91%E6%98%93%E4%BA%91%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/"/>
      <url>2021/04/16/Vue/%E4%BB%BF%E7%BD%91%E6%98%93%E4%BA%91%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h2 id="项目介绍"><a href="#项目介绍" class="headerlink" title="项目介绍"></a>项目介绍</h2><p>本项目采用Vue全家桶，与ElementUI搭配搭建而成，展示链接：<a href="https://luyiagoe.gitee.io/imitating-netease-cloud" target="_blank" rel="noopener">仿网易云展示页</a><img src="https://LuyiaGoe.github.io/assets/posts/wangyi_project_index.png" alt=""><img src="https://LuyiaGoe.github.io/assets/posts/wangyi_project_songlistpage.png" alt=""><img src="https://LuyiaGoe.github.io/assets/posts/wangyi_project_play.png" alt=""><img src="https://LuyiaGoe.github.io/assets/posts/wangyi_project_videopage.png" alt=""><img src="https://LuyiaGoe.github.io/assets/posts/wangyi_project_videoplay.png" alt=""></p><h2 id="核心内容"><a href="#核心内容" class="headerlink" title="核心内容"></a>核心内容</h2><ol><li>页面搭建<ul><li>Vue-cli快速搭建</li><li>采用ElementUI搭建页面</li><li>通过Vue-Router和组件构建前端路由</li><li>采用axios请求开源API：<a href="https://neteasecloudmusicapi.vercel.app" target="_blank" rel="noopener">网易云音乐 NodeJS 版 API</a></li></ul></li><li>播放组件</li><li>播放列表<ul><li>利用VueX管理播放数据（如正在播放歌曲信息、待播放歌曲列表、添加或切换的播放歌曲信息）</li></ul></li><li>播放事件<ul><li>通过组件中触发相应事件调用VueX的mutations达到切换、添加歌曲及切换播放列表等等的播放事件</li></ul></li></ol><h2 id="创建项目的细节（部分）"><a href="#创建项目的细节（部分）" class="headerlink" title="创建项目的细节（部分）"></a>创建项目的细节（部分）</h2><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><ol><li>图片</li><li>后端api <a href="https://neteasecloudmusicapi.vercel.app" target="_blank" rel="noopener">https://neteasecloudmusicapi.vercel.app</a></li><li>创建相应文件夹</li><li>插件下载及导入</li><li>main.js</li></ol><h3 id="首页制作"><a href="#首页制作" class="headerlink" title="首页制作"></a>首页制作</h3><ol><li>采用elementui的Container 布局容器</li><li>侧边栏采用NavMenu 导航菜单组件<ul><li>使用 vue-router 的模式 即：:router=”true”</li><li>取消选中高亮，使高亮跟普通字体颜色一样 active-text-color=”black”</li><li>设置路由index</li></ul></li><li>设置登录<ul><li>dialog组件 弹出登录框</li><li>带验证的 Form表单组件 输入登录信息</li><li>配置vecel后端api，并设置axios根路径，vue.config.js配置跨域问题</li><li>向api的/login/cellphone发送请求进行登录操作，登陆成功会返回res.data.coda=200</li><li>存储登录后的cookie信息到 localStorage ，命名为musicCookie</li><li>设置头像，头像图片URL存在res.data.profile.avatarUrl中</li></ul></li><li>设置退出登录</li><li>获取用户歌单并循环放入侧边栏<ul><li>向/user/playlist请求，歌单在res.data.playlist中，存入currentUserPlayList</li><li>侧边栏v-for循环currentUserPlayList,通过其中的subscribed判断是用户创建的还是收藏的歌单</li><li>v-if与v-for不能在同一个标签中使用，通过外包一层div将v-for与key扔到里面避免该问题</li></ul></li><li>主体部分路由设置</li><li>脚部播放组件<ul><li>通过slider组件实现</li><li>左边放置歌曲图片、名、歌手，中间放滑动条、前后首、暂停播放按钮，右边放音量、歌单</li><li>设置全局过滤器，将播放时间过滤成mm:ss的形式，并将过滤后的时间放到滑动条两侧</li></ul></li></ol><h3 id="发现音乐页制作"><a href="#发现音乐页制作" class="headerlink" title="发现音乐页制作"></a>发现音乐页制作</h3><ol><li>tab标签页制作<ul><li>tab页签头更换样式</li><li>tab内容中放入router-view，并根据不同的页签配置不同的路由</li></ul></li><li>个性推荐页制作<ul><li>轮播图采用Carousel 走马灯形式</li><li>轮播图api为‘bannner’</li><li>推荐歌单区域采用Divider 分割线</li><li>歌单内容列表采用layout布局，一行4个单元通过获取列表清单后循环渲染上去（此处出现空白渲染bug  通过对el-row更改flex布局并设置flex-wrap换行解决</li><li>独家放送页同上</li><li>最新歌曲采用el-row+el-table方式布局</li></ul></li><li>歌单页面制作<ul><li>添加分类按钮，根据分类获取不同的歌单</li><li>制作歌单列表</li></ul></li><li>排行榜页面制作</li><li>歌手页面制作</li><li>最新音乐制作</li></ol><h3 id="音乐播放列表页面制作"><a href="#音乐播放列表页面制作" class="headerlink" title="音乐播放列表页面制作"></a>音乐播放列表页面制作</h3><ol><li>创建文件及相应路由</li><li>根据route传来的params获取相应歌单的清单</li><li>制作歌单页面上部信息</li><li>制作内容区域<ul><li>放入路由占位符，出现请求头部信息</li><li>制作歌曲列表页</li><li>制作评论页</li><li>制作收藏者页</li></ul></li></ol><h3 id="视频页面制作"><a href="#视频页面制作" class="headerlink" title="视频页面制作"></a>视频页面制作</h3><ol><li>视频和mv清单页面制作</li><li>视频播放页面制作</li><li>mv播放页面制作<ul><li>与视频播放页面一致，但仅是采用的api不同，因此进行了合并</li></ul></li></ol><h3 id="播放功能制作"><a href="#播放功能制作" class="headerlink" title="播放功能制作"></a>播放功能制作</h3><ol><li>采用vuex，想法是<ul><li>将  正在播放的歌单、正播放的歌曲信息  放入状态管理</li><li>将  切换歌曲、切换歌单、添加歌曲入播放列表  放入mutations属性</li><li>因为请求用的api和传回的参数不尽相同，因此其他组件调用上述mutations属性时，需自行请求完数据，再进行调用并传递处理好的参数，而不是在vuex中进行请求</li></ul></li><li>实现<ul><li>从$store中调出当前即将播放的歌曲id，请求得到URL送入audio标签播放</li><li>获取audio的dom，为dom贴上timeupdate事件，以获取已播放时长以及歌曲时长，并绑定到拖动条上</li></ul></li></ol><h3 id="碰到的问题"><a href="#碰到的问题" class="headerlink" title="碰到的问题"></a>碰到的问题</h3><ol><li>有些样式在当前页面内无法更改，甚至添加！important也没用，如何区分，如何变更<ul><li>有些样式可以在global.css中定义并更改，并在HTML文件中引入，原因尚需思考,如圆角按钮和方角按钮，一个需要！impotant才能改padding，一个不需要</li></ul></li><li>出现相同path，不同query的路由请求，却不触发跳转的情况<ul><li>在标签内添加：key属性，<router-view :key="$route.path"></router-view>，原因是添加key后，vue会强制不复用这个router-view，只要key发生一点变化，都强制执行created和mounted钩子</li><li>音乐播放列表出现子路由变换，父组件却重新渲染的问题，原因在于上一条的：key属性，只要key值发生变动，父组件就会重新渲染，此时path中已经换了，导致无法根据path中的params按需（如，根据id找到歌单信息）请求静态资源，导致父组件渲染失败，之前的解决方法是让子路由带上父组件的params，之后通过导入单独组件而不用路由的方式解决</li></ul></li><li>音乐清单页面需要优化的点是切换内容区域的不同模块时，都只需要加载一边，不要切一次加载一次，因此需要父子组件传值，或者用vuex</li><li>出现全局污染</li><li>添加歌单按钮出现不同浏览器不同显示效果问题</li><li>el-input键入事件无法生效，通过在事件后添加.native可以解决<ul><li>.native是vue用于监听组件根元素的原生事件，用于自定义组件</li></ul></li><li>在搜索页面搜索时会不刷新页面，通过在路由跳转时加上一串随机数字或者关键字，配合路由占位符中:key强制刷新</li><li>父子组件传值时，父组件还在获取数据中，给子组件传递了空值或默认值，即使后面更新了，子组件却已经渲染出了空值并不再渲染后面传来的真数据，可以通过watch监视解决此问题</li><li>打包过程中出现No module factory available for dependency type: CssDependency，之前并未出现该错误，目前没有发现原因<ul><li>将vue.config.js中的css.extract设置为false，禁止打包过程中抽取css到单独的css文件中，而是内联到js中并动态注入，一般开发环境中默认的就是false，因为设置为true与css热重载不兼容</li><li>所以第二种方法就是vue-cli中的build那一栏，将参数的环境设置为development</li></ul></li></ol><h3 id="想法"><a href="#想法" class="headerlink" title="想法"></a>想法</h3><ol><li>为了减少请求次数，父组件一次性在请求完自身页面数据并显示完后，再一次性请求完子组件数据，并通过父子组件传值传递数据，如歌单页面与其子路由清单页面利用父子组件传值</li><li>vuex中存储正在播放的歌单，以及正在播放的歌曲id，为保证歌单中不出现重复的歌曲，利用同一首歌不能有同样的id的特点，采用set对象创建歌单</li><li>home页面的播放组件从vuex中获取正在播放的歌曲，播放并展示相关歌曲信息图片</li><li>切换歌曲时，将set对象Array.from()转换为数组，通过在这个数组中查找正在播放的歌曲id所在位置，按需（传入的步长，如-1是上一首，1是下一首）切换歌曲</li><li>往歌单中添加歌曲时，同上，先转换为数组，再找当前播放，然后用splice(index+1,0,addsong)在当前播放的歌曲后面插入要添加的歌曲</li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> Project </tag>
            
            <tag> VueX </tag>
            
            <tag> Vue-Router </tag>
            
            <tag> ElementUI </tag>
            
            <tag> axios </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React学习笔记</title>
      <link href="2021/04/16/React/React/"/>
      <url>2021/04/16/React/React/</url>
      
        <content type="html"><![CDATA[<h2 id="React-js-第1天"><a href="#React-js-第1天" class="headerlink" title="React.js - 第1天"></a>React.js - 第1天</h2><h3 id="1-React简介"><a href="#1-React简介" class="headerlink" title="1. React简介"></a>1. React简介</h3><ul><li>React 起源于 Facebook 的内部项目，因为该公司对市场上所有 JavaScript MVC 框架，都不满意，就决定自己写一套，用来架设 Instagram（照片交友） 的网站。做出来以后，发现这套东西很好用，<strong>就在2013年5月开源了</strong>。</li><li>Angular1 2009 年  谷歌    MVC  不支持 组件化开发</li><li>由于 React 的<strong>设计思想极其独特</strong>，属于革命性创新，性能出众，代码逻辑却非常简单。所以，越来越多的人开始关注和使用，认为它可能是将来 Web 开发的主流工具。</li><li>清楚两个概念：<ul><li>library（库）：小而巧的库，只提供了特定的API；优点就是 船小好掉头，可以很方便的从一个库切换到另外的库；但是代码几乎不会改变；</li><li>Framework（框架）：大而全的是框架；框架提供了一整套的解决方案；所以，如果在项目中间，想切换到另外的框架，是比较困难的；</li></ul></li></ul><h3 id="2-前端三大主流框架"><a href="#2-前端三大主流框架" class="headerlink" title="2. 前端三大主流框架"></a>2. 前端三大主流框架</h3><blockquote><p>三大框架一大抄</p></blockquote><ul><li>Angular.js：出来<strong>较早</strong>的前端框架，学习曲线比较陡，NG1学起来比较麻烦，NG2 ~ NG5开始，进行了一系列的改革，也提供了组件化开发的概念；从NG2开始，也支持使用TS（TypeScript）进行编程；</li><li>Vue.js：<strong>最火</strong>（关注的人比较多）的一门前端框架，它是中国人开发的，对我我们来说，文档要友好一些；</li><li>React.js：<strong>最流行</strong>（用的人比较多）的一门框架，因为它的设计很优秀；</li></ul><h3 id="3-React与vue的对比"><a href="#3-React与vue的对比" class="headerlink" title="3. React与vue的对比"></a>3. React与vue的对比</h3><h4 id="组件化方面"><a href="#组件化方面" class="headerlink" title="组件化方面"></a>组件化方面</h4><ol><li><strong>什么是模块化：</strong>是从<strong>代码</strong>的角度来进行分析的；把一些可复用的代码，抽离为单个的模块；便于项目的维护和开发；</li><li><strong>什么是组件化：</strong> 是从 <strong>UI 界面</strong>的角度 来进行分析的；把一些可服用的UI元素，抽离为单独的组件；便于项目的维护和开发；</li><li><strong>组件化的好处：</strong>随着项目规模的增大，手里的组件越来越多；很方便就能把现有的组件，拼接为一个完整的页面；</li><li><strong>Vue是如何实现组件化的：</strong> 通过 <code>.vue</code> 文件，来创建对应的组件；<ul><li>template  结构</li><li>script        行为</li><li>style           样式</li></ul></li></ol><ol start="5"><li><strong>React如何实现组件化</strong>：大家注意，React中有组件化的概念，但是，并没有像vue这样的组件模板文件；React中，一切都是以JS来表现的；因此要学习React，JS要合格；ES6 和 ES7 （async  和 await） 要会用；<h4 id="开发团队方面"><a href="#开发团队方面" class="headerlink" title="开发团队方面"></a>开发团队方面</h4></li></ol><ul><li>React是由FaceBook前端官方团队进行维护和更新的；因此，React的维护开发团队，技术实力比较雄厚；</li><li>Vue：第一版，主要是有作者 尤雨溪 专门进行维护的，当 Vue更新到 2.x 版本后，也有了一个以 尤雨溪 为主导的开源小团队，进行相关的开发和维护；</li></ul><h4 id="社区方面"><a href="#社区方面" class="headerlink" title="社区方面"></a>社区方面</h4><ul><li>在社区方面，React由于诞生的较早，所以社区比较强大，一些常见的问题、坑、最优解决方案，文档、博客在社区中都是可以很方便就能找到的；</li><li>Vue是近两年才火起来的，所以，它的社区相对于React来说，要小一些，可能有的一些坑，没人踩过；</li></ul><h4 id="移动APP开发体验方面"><a href="#移动APP开发体验方面" class="headerlink" title="移动APP开发体验方面"></a>移动APP开发体验方面</h4><ul><li>Vue，结合 Weex 这门技术，提供了 迁移到 移动端App开发的体验（Weex，目前只是一个 小的玩具， 并没有很成功的 大案例；）</li><li>React，结合 ReactNative，也提供了无缝迁移到 移动App的开发体验（RN用的最多，也是最火最流行的）；</li></ul><h3 id="4-为什么要学习React"><a href="#4-为什么要学习React" class="headerlink" title="4. 为什么要学习React"></a>4. 为什么要学习React</h3><ol><li>和Angular1相比，React设计很优秀，一切基于JS并且实现了组件化开发的思想；</li><li>开发团队实力强悍，不必担心断更的情况；</li><li>社区强大，很多问题都能找到对应的解决方案；</li><li>提供了无缝转到 ReactNative 上的开发体验，让我们技术能力得到了拓展；增强了我们的核心竞争力；</li><li>很多企业中，前端项目的技术选型采用的是React.js；</li></ol><h3 id="5-React中几个核心的概念"><a href="#5-React中几个核心的概念" class="headerlink" title="5. React中几个核心的概念"></a>5. React中几个核心的概念</h3><h4 id="虚拟DOM（Virtual-Document-Object-Model）"><a href="#虚拟DOM（Virtual-Document-Object-Model）" class="headerlink" title="虚拟DOM（Virtual Document Object Model）"></a>虚拟DOM（Virtual Document Object Model）</h4><ul><li><p><strong>DOM的本质是什么</strong>：浏览器中的概念，用JS对象来表示 页面上的元素，并提供了操作 DOM 对象的API；</p></li><li><p><strong>什么是React中的虚拟DOM</strong>：是框架中的概念，是程序员 用JS对象来模拟 页面上的 DOM 和 DOM嵌套；</p></li><li><p><strong>为什么要实现虚拟DOM（虚拟DOM的目的）：</strong>为了实现页面中， DOM 元素的高效更新</p></li><li><p><strong>DOM和虚拟DOM的区别</strong>：</p><ul><li><p><strong>DOM：</strong>浏览器中，提供的概念；用JS对象，表示页面上的元素，并提供了操作元素的API；</p></li><li><p><strong>虚拟DOM：</strong>是框架中的概念；而是开发框架的程序员，手动用JS对象来模拟DOM元素和嵌套关系；</p><ul><li>本质： 用JS对象，来模拟DOM元素和嵌套关系；</li><li>目的：就是为了实现页面元素的高效更新；</li></ul></li></ul></li></ul><h4 id="Diff算法"><a href="#Diff算法" class="headerlink" title="Diff算法"></a>Diff算法</h4><ul><li><p><strong>tree diff:</strong>新旧两棵DOM树，逐层对比的过程，就是 Tree Diff； 当整颗DOM逐层对比完毕，则所有需要被按需更新的元素，必然能够找到；</p></li><li><p><strong>component diff：</strong>在进行Tree Diff的时候，每一层中，组件级别的对比，叫做 Component Diff；</p><ul><li>如果对比前后，组件的类型相同，则<strong>暂时</strong>认为此组件不需要被更新；</li><li>如果对比前后，组件类型不同，则需要移除旧组件，创建新组件，并追加到页面上；</li></ul></li><li><p><strong>element diff:</strong>在进行组件对比的时候，如果两个组件类型相同，则需要进行 元素级别的对比，这叫做 Element Diff；</p><p><img src="https://LuyiaGoe.github.io/assets/posts/react_diff.png" alt="Diff算法图"></p></li></ul><h3 id="6-创建基本的webpack4-x项目"><a href="#6-创建基本的webpack4-x项目" class="headerlink" title="6. 创建基本的webpack4.x项目"></a>6. 创建基本的webpack4.x项目</h3><ol><li>运行<code>npm init -y</code> 快速初始化项目</li><li>在项目根目录创建<code>src</code>源代码目录和<code>dist</code>产品目录</li><li>在 src 目录下创建 <code>index.html</code></li><li>使用 cnpm 安装 webpack ，运行<code>cnpm i webpack webpack-cli -D</code><ul><li>如何安装 <code>cnpm</code>: 全局运行 <code>npm i cnpm -g</code></li></ul></li><li>注意：webpack 4.x 提供了 约定大于配置的概念；目的是为了尽量减少 配置文件的体积；<ul><li>默认约定了：</li><li>打包的入口是<code>src</code> -&gt; <code>index.js</code></li><li>打包的输出文件是<code>dist</code> -&gt; <code>main.js</code></li><li>4.x 中 新增了 <code>mode</code> 选项(为必选项)，可选的值为：<code>development</code> 和 <code>production</code>;</li></ul></li></ol><h3 id="7-在项目中使用-react"><a href="#7-在项目中使用-react" class="headerlink" title="7. 在项目中使用 react"></a>7. 在项目中使用 react</h3><ol><li><p>运行 <code>cnpm i react react-dom -S</code> 安装包</p><ul><li>react： 专门用于创建组件和虚拟DOM的，同时组件的生命周期都在这个包中</li><li>react-dom： 专门进行DOM操作的，最主要的应用场景，就是<code>ReactDOM.render()</code></li></ul></li><li><p>在<code>index.html</code>页面中，创建容器：</p><pre><code class="highlight html"><span class="comment">&lt;!-- 容器，将来，使用 React 创建的虚拟DOM元素，都会被渲染到这个指定的容器中 --&gt;</span><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></code></pre></li><li><p>导入 包：</p><pre><code class="highlight js"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span></code></pre></li><li><p>创建虚拟DOM元素：</p><pre><code class="highlight jsx"><span class="comment">// 这是 创建虚拟DOM元素的 API    &lt;h1 title="啊，五环" id="myh1"&gt;你比四环多一环&lt;/h1&gt;</span><span class="comment">//  第一个参数： 字符串类型的参数，表示要创建的标签的名称</span><span class="comment">//  第二个参数：对象类型的参数， 表示 创建的元素的属性节点</span><span class="comment">//  第三个参数： 子节点</span><span class="keyword">const</span> myh1 = React.createElement(<span class="string">'h1'</span>, { <span class="attr">title</span>: <span class="string">'啊，五环'</span>, <span class="attr">id</span>: <span class="string">'myh1'</span> }, <span class="string">'你比四环多一环'</span>)</code></pre></li></ol><ol start="5"><li><p>渲染：</p><pre><code class="highlight js"><span class="comment">// 3. 渲染虚拟DOM元素</span><span class="comment">// 参数1： 表示要渲染的虚拟DOM对象</span><span class="comment">// 参数2： 指定容器,注意：这里不能直接放 容器元素的Id字符串，需要放一个容器的DOM对象</span>ReactDOM.render(myh1, <span class="built_in">document</span>.getElementById(<span class="string">'app'</span>))</code></pre><p>​</p></li></ol><h3 id="8-JSX语法"><a href="#8-JSX语法" class="headerlink" title="8. JSX语法"></a>8. JSX语法</h3><blockquote><p>什么是JSX语法：就是符合 xml 规范的 JS 语法；（语法格式相对来说，要比HTML严谨很多）</p></blockquote><ol><li><p><strong>如何启用 jsx 语法？</strong></p><ul><li><p>安装 <code>babel</code> 插件</p><ul><li>运行<code>cnpm i @babel-core babel-loader @babel-plugin-transform-runtime -D</code></li><li>运行<code>cnpm i @babel-preset-env  -D</code></li></ul></li><li><p>安装能够识别转换jsx语法的包 <code>babel-preset-react</code> </p><ul><li>运行<code>cnpm i @babel-preset-react -D</code></li></ul></li><li><p>添加 <code>.babelrc</code> 配置文件</p><pre><code class="highlight json">     {    <span class="attr">"presets"</span>: [<span class="string">"@babel/preset-env"</span>, <span class="string">"@babel/preset-react"</span>, <span class="string">"mobx"</span>],    <span class="attr">"plugins"</span>: [        <span class="string">"@babel/plugin-proposal-object-rest-spread"</span>,        <span class="string">"@babel/plugin-transform-runtime"</span>    ]}</code></pre></li><li><p>添加babel-loader配置项：</p><pre><code class="highlight js"><span class="built_in">module</span>: { <span class="comment">//要打包的第三方模块</span>    rules: [      { <span class="attr">test</span>: <span class="regexp">/\.js|jsx$/</span>, <span class="attr">use</span>: <span class="string">'babel-loader'</span>, <span class="attr">exclude</span>: <span class="regexp">/node_modules/</span> }    ]}</code></pre><p>​</p></li></ul></li><li><p><strong>jsx 语法的本质：</strong>并不是直接把 jsx 渲染到页面上，而是 内部先转换成了 createElement 形式，再渲染的；</p></li><li><p><strong>在 jsx 中混合写入 js 表达式</strong>：在 jsx 语法中，要把 JS代码写到 <code>{ }</code> 中</p><ul><li>渲染数字</li><li>渲染字符串</li><li>渲染布尔值</li><li>为属性绑定值</li><li>渲染jsx元素</li><li>渲染jsx元素数组</li><li>将普通字符串数组，转为jsx数组并渲染到页面上【两种方案】</li></ul></li><li><p><strong>在 jsx 中 写注释</strong>：推荐使用<code>{ /* 这是注释 */ }</code></p></li><li><p><strong>为 jsx 中的元素添加class类名</strong>：需要使用<code>className</code> 来替代 <code>class</code>；<code>htmlFor</code>替换label的<code>for</code>属性</p></li><li><p>在JSX创建DOM的时候，所有的节点，必须有唯一的根元素进行包裹；</p></li><li><p>在 jsx 语法中，标签必须 成对出现，如果是单标签，则必须自闭和！</p></li></ol><blockquote><p>当 编译引擎，在编译JSX代码的时候，如果遇到了<code>&lt;</code>那么就把它当作 HTML代码去编译，如果遇到了 <code>{}</code> 就把 花括号内部的代码当作 普通JS代码去编译；</p></blockquote><h3 id="9-React中创建组件"><a href="#9-React中创建组件" class="headerlink" title="9. React中创建组件"></a>9. React中创建组件</h3><h4 id="第1种-创建组件的方式"><a href="#第1种-创建组件的方式" class="headerlink" title="第1种 - 创建组件的方式"></a>第1种 - 创建组件的方式</h4><blockquote><p><strong>使用构造函数来创建组件</strong>，如果要接收外界传递的数据，需要在 构造函数的参数列表中使用<code>props</code>来接收；</p><p>必须要向外return一个合法的JSX创建的虚拟DOM；</p></blockquote><ul><li><p>创建组件：</p><pre><code class="highlight jsx"><span class="function"><span class="keyword">function</span> <span class="title">Hello</span> (<span class="params"></span>) </span>{ <span class="comment">// return null </span><span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Hello 组件<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>}</code></pre></li><li><p>为组件传递数据：</p><pre><code class="highlight jsx"><span class="comment">// 使用组件并 为组件传递 props 数据</span>&lt;Hello name={dog.name} age={dog.age} gender={dog.gender}&gt;&lt;<span class="regexp">/Hello&gt;</span><span class="regexp"></span><span class="regexp">/</span><span class="regexp">/ 在构造函数中，使用 props 形参，接收外界 传递过来的数据</span><span class="regexp">function Hello(props) {</span><span class="regexp">  /</span><span class="regexp">/ props.name = 'zs'</span><span class="regexp">  console.log(props)</span><span class="regexp">  /</span><span class="regexp">/ 结论：不论是 Vue 还是 React，组件中的 props 永远都是只读的；不能被重新赋值；</span><span class="regexp"></span><span class="regexp">  return &lt;div&gt;这是 Hello 组件 --- {props.name} --- {props.age} --- {props.gender}&lt;/</span>div&gt;}</code></pre><p>​</p></li></ul><ol><li><p>父组件向子组件传递数据</p></li><li><p>使用{…obj}属性扩散传递数据</p></li><li><p>将组件封装到单独的文件中</p></li><li><p>注意：组件的名称首字母必须是大写</p></li><li><p>在导入组件的时候，如何省略组件的<code>.jsx</code>后缀名：</p><pre><code class="highlight js"><span class="comment">// 打开 webpack.config.js ，并在导出的配置对象中，新增 如下节点：</span>resolve: {    extensions: [<span class="string">'.js'</span>, <span class="string">'.jsx'</span>, <span class="string">'.json'</span>], <span class="comment">// 表示，这几个文件的后缀名，可以省略不写</span>    alias: {        <span class="string">'@'</span>: path.join(__dirname, <span class="string">'./src'</span>)    }  }</code></pre></li><li><p>在导入组件的时候，配置和使用<code>@</code>路径符号</p></li></ol><h4 id="第2种-创建组件的方式"><a href="#第2种-创建组件的方式" class="headerlink" title="第2种 - 创建组件的方式"></a>第2种 - 创建组件的方式</h4><blockquote><p>使用 class 关键字来创建组件</p><p>ES6 中 class 关键字，是实现面向对象编程的新形式；</p></blockquote><h5 id="了解ES6中-class-关键字的使用"><a href="#了解ES6中-class-关键字的使用" class="headerlink" title="了解ES6中 class 关键字的使用"></a>了解ES6中 class 关键字的使用</h5><ol><li>class 中 <code>constructor</code> 的基本使用</li><li>实例属性和实例方法</li><li>静态属性和静态方法</li><li>使用 <code>extends</code> 关键字实现继承</li></ol><h5 id="基于class关键字创建组件"><a href="#基于class关键字创建组件" class="headerlink" title="基于class关键字创建组件"></a>基于class关键字创建组件</h5><ol><li><p>最基本的组件结构：</p><pre><code class="highlight jsx"><span class="class"><span class="keyword">class</span> 组件名称 <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>{    render(){        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>这是 class 创建的组件<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>    }}</code></pre></li></ol><h3 id="10-两种创建组件方式的对比"><a href="#10-两种创建组件方式的对比" class="headerlink" title="10. 两种创建组件方式的对比"></a>10. 两种创建组件方式的对比</h3><ol><li>用<strong>构造函数</strong>创建出来的组件：叫做“无状态组件”</li><li>用<strong>class关键字</strong>创建出来的组件：叫做“有状态组件”</li></ol><blockquote><p>有状态组件和无状态组件之间的<strong>本质区别</strong>就是：有无state属性！</p></blockquote><h3 id="11-一个小案例，巩固有状态组件和无状态组件的使用"><a href="#11-一个小案例，巩固有状态组件和无状态组件的使用" class="headerlink" title="11. 一个小案例，巩固有状态组件和无状态组件的使用"></a>11. 一个小案例，巩固有状态组件和无状态组件的使用</h3><h4 id="通过for循环生成多个组件"><a href="#通过for循环生成多个组件" class="headerlink" title="通过for循环生成多个组件"></a>通过for循环生成多个组件</h4><ol><li>数据：<pre><code class="highlight js">CommentList: [    { <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">user</span>: <span class="string">'张三'</span>, <span class="attr">content</span>: <span class="string">'哈哈，沙发'</span> },    { <span class="attr">id</span>: <span class="number">2</span>, <span class="attr">user</span>: <span class="string">'李四'</span>, <span class="attr">content</span>: <span class="string">'哈哈，板凳'</span> },    { <span class="attr">id</span>: <span class="number">3</span>, <span class="attr">user</span>: <span class="string">'王五'</span>, <span class="attr">content</span>: <span class="string">'哈哈，凉席'</span> },    { <span class="attr">id</span>: <span class="number">4</span>, <span class="attr">user</span>: <span class="string">'赵六'</span>, <span class="attr">content</span>: <span class="string">'哈哈，砖头'</span> },    { <span class="attr">id</span>: <span class="number">5</span>, <span class="attr">user</span>: <span class="string">'田七'</span>, <span class="attr">content</span>: <span class="string">'哈哈，楼下山炮'</span> }]</code></pre></li></ol><h4 id="设置样式"><a href="#设置样式" class="headerlink" title="设置样式"></a>设置样式</h4><ol><li>使用普通的 <code>style</code> 样式</li><li>启用 css-modules</li><li>使用<code>localIdentName</code>设置生成的类名称，可选的参数有：<ul><li>[path]  表示样式表所在路径</li><li>[name]  表示 样式表文件名</li><li>[local]  表示样式的定义名称</li><li>[hash:length]  表示32位的hash值</li></ul></li><li>使用 <code>:local()</code> 和 <code>:global()</code></li></ol><h3 id="安装-React-Developer-Tools-调试工具"><a href="#安装-React-Developer-Tools-调试工具" class="headerlink" title="安装 React Developer Tools 调试工具"></a>安装 React Developer Tools 调试工具</h3><p><a href="https://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi?hl=zh-CN" target="_blank" rel="noopener">React Developer Tools - Chrome 扩展下载安装地址</a></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>理解React中虚拟DOM的概念理解React中三种Diff算法的概念使用JS中createElement的方式创建虚拟DOM使用ReactDOM.render方法使用JSX语法并理解其本质掌握创建组件的两种方式理解有状态组件和无状态组件的本质区别理解props和state的区别</p><h3 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h3><ul><li><a href="http://www.cnblogs.com/tim100/p/6050514.html" target="_blank" rel="noopener">React数据流和组件间的沟通总结</a></li><li><a href="https://segmentfault.com/q/1010000005876655/a-1020000005876751" target="_blank" rel="noopener">单向数据流和双向绑定各有什么优缺点？</a></li><li><a href="https://www.zhihu.com/question/29504639?sort=created" target="_blank" rel="noopener">怎么更好的理解虚拟DOM?</a></li><li><a href="http://blog.csdn.net/yczz/article/details/49886061" target="_blank" rel="noopener">React 源码剖析系列 － 不可思议的 react diff</a></li><li><a href="http://www.infoq.com/cn/articles/react-dom-diff?from=timeline&amp;isappinstalled=0" target="_blank" rel="noopener">深入浅出React（四）：虚拟DOM Diff算法解析</a></li><li><a href="http://www.cocoachina.com/webapp/20150721/12692.html" target="_blank" rel="noopener">一看就懂的ReactJs入门教程（精华版）</a></li><li><a href="http://www.ruanyifeng.com/blog/2016/06/css_modules.html" target="_blank" rel="noopener">CSS Modules 用法教程</a><h2 id="React-js-第2天"><a href="#React-js-第2天" class="headerlink" title="React.js - 第2天"></a>React.js - 第2天</h2></li></ul><h3 id="0-安装-React-Developer-Tools-调试工具"><a href="#0-安装-React-Developer-Tools-调试工具" class="headerlink" title="0. 安装 React Developer Tools 调试工具"></a>0. 安装 React Developer Tools 调试工具</h3><p><a href="https://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi?hl=zh-CN" target="_blank" rel="noopener">React Developer Tools - Chrome 扩展下载安装地址</a></p><h3 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h3><ol><li>学习 创建组件的第二种方式</li><li>美化React组件的样式</li><li>小Demo穿起来之前学习的知识点</li><li>React中绑定事件</li><li>React组件的生命周期</li></ol><h3 id="1-React中创建组件"><a href="#1-React中创建组件" class="headerlink" title="1. React中创建组件"></a>1. React中创建组件</h3><h4 id="第1种-创建组件的方式-1"><a href="#第1种-创建组件的方式-1" class="headerlink" title="第1种 - 创建组件的方式"></a>第1种 - 创建组件的方式</h4><blockquote><p><strong>使用构造函数来创建组件</strong>，如果要接收外界传递的数据，需要在 构造函数的参数列表中使用<code>props</code>来接收；</p><p>必须要向外return一个合法的JSX创建的虚拟DOM；</p></blockquote><ul><li><p>创建组件：</p><pre><code class="highlight jsx"><span class="function"><span class="keyword">function</span> <span class="title">Hello</span> (<span class="params"></span>) </span>{ <span class="comment">// return null </span><span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Hello 组件<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>}</code></pre></li><li><p>为组件传递数据：</p><pre><code class="highlight jsx"><span class="comment">// 使用组件并 为组件传递 props 数据</span>&lt;Hello name={dog.name} age={dog.age} gender={dog.gender}&gt;&lt;<span class="regexp">/Hello&gt;</span><span class="regexp"></span><span class="regexp">/</span><span class="regexp">/ 在构造函数中，使用 props 形参，接收外界 传递过来的数据</span><span class="regexp">function Hello(props) {</span><span class="regexp">  /</span><span class="regexp">/ props.name = 'zs'</span><span class="regexp">  console.log(props)</span><span class="regexp">  /</span><span class="regexp">/ 结论：不论是 Vue 还是 React，组件中的 props 永远都是只读的；不能被重新赋值；</span><span class="regexp"></span><span class="regexp">  return &lt;div&gt;这是 Hello 组件 --- {props.name} --- {props.age} --- {props.gender}&lt;/</span>div&gt;}</code></pre><p>​</p></li></ul><ol><li><p>父组件向子组件传递数据</p></li><li><p>使用{…obj}属性扩散传递数据</p></li><li><p>将组件封装到单独的文件中</p></li><li><p>注意：组件的名称首字母必须是大写</p></li><li><p>在导入组件的时候，如何省略组件的<code>.jsx</code>后缀名：</p><pre><code class="highlight js"><span class="comment">// 打开 webpack.config.js ，并在导出的配置对象中，新增 如下节点：</span>resolve: {    extensions: [<span class="string">'.js'</span>, <span class="string">'.jsx'</span>, <span class="string">'.json'</span>], <span class="comment">// 表示，这几个文件的后缀名，可以省略不写</span>    alias: {        <span class="string">'@'</span>: path.join(__dirname, <span class="string">'./src'</span>)    }  }</code></pre></li><li><p>在导入组件的时候，配置和使用<code>@</code>路径符号</p></li></ol><h4 id="第2种-创建组件的方式-1"><a href="#第2种-创建组件的方式-1" class="headerlink" title="第2种 - 创建组件的方式"></a>第2种 - 创建组件的方式</h4><blockquote><p>使用 class 关键字来创建组件</p><p>ES6 中 class 关键字，是实现面向对象编程的新形式；</p></blockquote><h5 id="了解ES6中-class-关键字的使用-1"><a href="#了解ES6中-class-关键字的使用-1" class="headerlink" title="了解ES6中 class 关键字的使用"></a>了解ES6中 class 关键字的使用</h5><ol><li>class 中 <code>constructor</code> 的基本使用</li><li>实例属性和实例方法</li><li>静态属性和静态方法</li><li>使用 <code>extends</code> 关键字实现继承</li></ol><h5 id="基于class关键字创建组件-1"><a href="#基于class关键字创建组件-1" class="headerlink" title="基于class关键字创建组件"></a>基于class关键字创建组件</h5><ol><li><p>最基本的组件结构：</p><pre><code class="highlight jsx"><span class="comment">// 如果要使用 class 定义组件，必须 让自己的组件，继承自 React.Component</span><span class="class"><span class="keyword">class</span> 组件名称 <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>{    <span class="comment">// 在 组件内部，必须有 render 函数,作用：渲染当前组件对应的 虚拟DOM结构</span>    render(){        <span class="comment">// render 函数中，必须 返回合法的 JSX 虚拟DOM结构</span>        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>这是 class 创建的组件<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>    }}</code></pre></li></ol><h3 id="2-两种创建组件方式的对比"><a href="#2-两种创建组件方式的对比" class="headerlink" title="2. 两种创建组件方式的对比"></a>2. 两种创建组件方式的对比</h3><blockquote><p>注意：使用 class 关键字创建的组件，有自己的私有数据（this.state） 和 生命周期函数；</p><p>注意：使用 function 创建的组件，只有props，没有自己的私有数据和 生命周期函数；</p></blockquote><ol><li>用<strong>构造函数</strong>创建出来的组件：叫做“无状态组件”【无状态组件今后用的不多】</li><li>用<strong>class关键字</strong>创建出来的组件：叫做“有状态组件”【今后用的最多】</li><li>什么情况下使用有状态组件？什么情况下使用无状态组件？<ul><li>如果一个组件需要有自己的私有数据，则推荐使用：class创建的有状态组件；</li><li>如果一个组件不需要有私有的数据，则推荐使用：无状态组件；</li><li>React官方说：无状态组件，由于没有自己的state和生命周期函数，所以运行效率会比 有状态组件稍微高一些；</li></ul></li></ol><blockquote><p>有状态组件和无状态组件之间的<strong>本质区别</strong>就是：有无state属性、和 有无生命周期函数；</p></blockquote><ol start="4"><li>组件中的 <code>props</code> 和 <code>state/data</code> 之间的区别<ul><li>props 中的数据都是外界传递过来的；</li><li>state/data 中的数据，都是组件私有的；（通过 Ajax 获取回来的数据，一般都是私有数据）；</li><li>props  中的数据都是只读的；不能重新赋值；</li><li>state/data 中的数据，都是可读可写的；</li></ul></li></ol><h3 id="3-渲染评论列表"><a href="#3-渲染评论列表" class="headerlink" title="3. 渲染评论列表"></a>3. 渲染评论列表</h3><p><img src="https://LuyiaGoe.github.io/assets/posts/cmtlist.png" alt="效果"></p><h4 id="通过for循环生成多个组件-1"><a href="#通过for循环生成多个组件-1" class="headerlink" title="通过for循环生成多个组件"></a>通过for循环生成多个组件</h4><ol><li>数据：</li></ol><pre><code class="highlight js">CommentList: [    { <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">user</span>: <span class="string">'张三'</span>, <span class="attr">content</span>: <span class="string">'哈哈，沙发'</span> },    { <span class="attr">id</span>: <span class="number">2</span>, <span class="attr">user</span>: <span class="string">'李四'</span>, <span class="attr">content</span>: <span class="string">'哈哈，板凳'</span> },    { <span class="attr">id</span>: <span class="number">3</span>, <span class="attr">user</span>: <span class="string">'王五'</span>, <span class="attr">content</span>: <span class="string">'哈哈，凉席'</span> },    { <span class="attr">id</span>: <span class="number">4</span>, <span class="attr">user</span>: <span class="string">'赵六'</span>, <span class="attr">content</span>: <span class="string">'哈哈，砖头'</span> },    { <span class="attr">id</span>: <span class="number">5</span>, <span class="attr">user</span>: <span class="string">'田七'</span>, <span class="attr">content</span>: <span class="string">'哈哈，楼下山炮'</span> }]</code></pre><h3 id="4-设置样式"><a href="#4-设置样式" class="headerlink" title="4. 设置样式"></a>4. 设置样式</h3><ol><li><p>使用普通的 <code>style</code> 样式</p><pre><code class="highlight jsx">&lt;h1 style={ {<span class="attr">color</span>: <span class="string">'red'</span>, <span class="attr">fontWeight</span>: <span class="number">200</span>} }&gt;&lt;<span class="regexp">/h1&gt;</span></code></pre></li><li><p>启用 css-modules</p><ol><li><p>修改 <code>webpack.config.js</code>这个配置文件，为 <code>css-loader</code> 添加参数：</p><pre><code class="highlight js">{ <span class="attr">test</span>: <span class="regexp">/\.css$/</span>, <span class="attr">use</span>: [<span class="string">'style-loader'</span>, <span class="string">'css-loader?modules'</span>] } <span class="comment">// 为 .css 后缀名的样式表  启用 CSS 模块化</span></code></pre></li><li><p>在需要的组件中，<code>import</code>导入样式表，并接收模块化的 CSS 样式对象：</p><pre><code class="highlight js"><span class="keyword">import</span> cssObj <span class="keyword">from</span> <span class="string">'../css/CmtList.css'</span></code></pre></li><li><p>在需要的HTML标签上，使用<code>className</code>指定模块化的样式：</p><pre><code class="highlight jsx">&lt;h1 className={cssObj.title}&gt;评论列表组件&lt;<span class="regexp">/h1&gt;</span></code></pre></li></ol></li><li><p>使用<code>localIdentName</code>自定义生成的类名格式，可选的参数有：</p><ul><li>[path]  表示样式表 <code>相对于项目根目录</code> 所在路径</li><li>[name]  表示 样式表文件名称</li><li>[local]  表示样式的类名定义名称</li><li>[hash:length]  表示32位的hash值</li><li>例子：<code>{ test: /\.css$/, use: ['style-loader', 'css-loader?modules&amp;localIdentName=[path][name]-[local]-[hash:5]'] }</code></li></ul></li><li><p>使用 <code>:local()</code> 和 <code>:global()</code></p><ul><li><p><code>:local()</code>包裹的类名，是被模块化的类名，只能通过<code>className={cssObj.类名}</code>来使用</p><p>同时，<code>:local</code>默认可以不写，这样，默认在样式表中定义的类名，都是被模块化的类名；</p></li><li><p><code>:global()</code>包裹的类名，是全局生效的，不会被 <code>css-modules</code> 控制，定义的类名是什么，就是使用定义的类名<code>className="类名"</code></p></li></ul></li><li><p>注意：只有<code>.title</code>这样的类样式选择器，才会被模块化控制，类似于<code>body</code>这样的标签选择器，不会被模块化控制；</p></li></ol><h4 id="在项目中启用模块化并同时使用bootstrap"><a href="#在项目中启用模块化并同时使用bootstrap" class="headerlink" title="在项目中启用模块化并同时使用bootstrap"></a>在项目中启用模块化并同时使用bootstrap</h4><ol><li><p>把 自己的样式表，定义为 <code>.scss</code>  文件</p></li><li><p>第三方的 样式表，还是 以 <code>.css</code> 结尾</p></li><li><p>我们只需要为自己的 <code>.scss</code> 文件，启用模块化即可；</p></li><li><p>运行<code>cnpm i sass-loader node-sass -D</code> 安装能够解析<code>scss</code>文件的loader</p></li><li><p>添加loader规则：</p><pre><code class="highlight json">{ test: /\.scss$/, use: ['style-loader', 'css-loader?modules&amp;localIdentName=[path][name]-[local]-[hash:5]', 'sass-loader'] } // 打包处理 scss 文件的 loader</code></pre><p>​</p></li></ol><h3 id="5-React-中绑定事件的注意点"><a href="#5-React-中绑定事件的注意点" class="headerlink" title="5. React 中绑定事件的注意点"></a>5. React 中绑定事件的注意点</h3><ol><li><p>事件的名称都是React的提供的，因此名称的首字母必须大写<code>onClick</code>、<code>onMouseOver</code></p></li><li><p>为事件提供的处理函数，必须是如下格式</p><pre><code class="highlight plain">onClick= { function }</code></pre></li><li><p>用的最多的事件绑定形式为：</p><pre><code class="highlight jsx">&lt;button onClick={ () =&gt; <span class="keyword">this</span>.show(<span class="string">'传参'</span>) }&gt;按钮&lt;<span class="regexp">/button&gt;</span><span class="regexp"></span><span class="regexp">/</span><span class="regexp">/ 事件的处理函数，需要定义为 一个箭头函数，然后赋值给 函数名称</span><span class="regexp">show = (arg1) =&gt; {</span><span class="regexp">    console.log('show方法' + arg1)</span><span class="regexp">}</span></code></pre></li><li><p>在React中，如果想要修改 state 中的数据，推荐使用 <code>this.setState({ })</code></p></li></ol><h3 id="6-绑定文本框与state中的值（单向数据流）"><a href="#6-绑定文本框与state中的值（单向数据流）" class="headerlink" title="6. 绑定文本框与state中的值（单向数据流）"></a>6. 绑定文本框与state中的值（单向数据流）</h3><ol><li><p>在 Vue 中，默认提供了<code>v-model</code>指令，可以很方便的实现 <code>数据的双向绑定</code>；</p></li><li><p>但是，在 React 中，默认只是<code>单向数据流</code>，也就是 只能把 state 上的数据绑定到 页面，无法把 页面中数据的变化，自动同步回 state ； 如果需要把 页面上数据的变化，保存到 state，则需要程序员手动监听<code>onChange</code>事件，拿到最新的数据，手动调用<code>this.setState({  })</code> 更改回去；</p></li><li><p>案例：</p><pre><code class="highlight jsx">&lt;input type=<span class="string">"text"</span> style={{ <span class="attr">width</span>: <span class="string">'100%'</span> }} value={<span class="keyword">this</span>.state.msg} onChange={() =&gt; <span class="keyword">this</span>.textChanged()} ref=<span class="string">"mytxt"</span> /&gt; <span class="comment">// 响应 文本框 内容改变的处理函数</span>  textChanged = <span class="function"><span class="params">()</span> =&gt;</span> {    <span class="comment">// console.log(this);</span>    <span class="comment">// console.log(this.refs.mytxt.value);</span>    <span class="keyword">this</span>.setState({      msg: <span class="keyword">this</span>.refs.mytxt.value    })  }</code></pre><p>​</p></li></ol><h3 id="7-使用ref获取DOM元素引用"><a href="#7-使用ref获取DOM元素引用" class="headerlink" title="7. 使用ref获取DOM元素引用"></a>7. 使用ref获取DOM元素引用</h3><p>和 Vue 中差不多，vue 为页面上的元素提供了 <code>ref</code> 的属性，如果想要获取 元素引用，则需要使用<code>this.$refs.引用名称</code></p><p>在 React 中，也有 <code>ref</code>, 如果要获取元素的引用<code>this.refs.引用名称</code></p><h3 id="8-组件的生命周期"><a href="#8-组件的生命周期" class="headerlink" title="8. 组件的生命周期"></a>8. 组件的生命周期</h3><ul><li><p>生命周期的概念：每个组件的实例，从 创建、到运行、直到销毁，在这个过程中，会出发一些列 事件，这些事件就叫做组件的生命周期函数；</p></li><li><p>React组件生命周期分为三部分：</p><ul><li><strong>组件创建阶段</strong>：特点：一辈子只执行一次</li></ul><blockquote><p><code>componentWillMount:</code> <code>render：</code><code>componentDidMount:</code> </p></blockquote><ul><li><strong>组件运行阶段</strong>：按需，根据 props 属性 或 state 状态的改变，有选择性的 执行 0 到多次</li></ul><blockquote><p><code>componentWillReceiveProps:</code><code>shouldComponentUpdate:</code><code>componentWillUpdate:</code> <code>render:</code> <code>componentDidUpdate:</code> </p></blockquote><ul><li><strong>组件销毁阶段</strong>：一辈子只执行一次</li></ul><blockquote><p><code>componentWillUnmount:</code> </p></blockquote></li></ul><p><a href="https://cn.vuejs.org/v2/guide/instance.html#生命周期图示" target="_blank" rel="noopener">vue中的生命周期图</a></p><p><img src="https://LuyiaGoe.github.io/assets/posts/react%E6%97%A7%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" alt="React中组件的生命周期(旧)"></p><h4 id="defaultProps"><a href="#defaultProps" class="headerlink" title="defaultProps"></a>defaultProps</h4><blockquote><p>在组件创建之前，会先初始化默认的props属性，这是全局调用一次，严格地来说，这不是组件的生命周期的一部分。在组件被创建并加载候，首先调用 constructor 构造器中的 this.state = {}，来初始化组件的状态。</p></blockquote><p>组件生命周期的执行顺序：</p><pre><code class="highlight js"><span class="number">1.</span> Mounting：   - <span class="keyword">constructor</span>()   - componentWillMount()   - render()   - componentDidMount()2. Updating：   - componentWillReceiveProps(nextProps)   - shouldComponentUpdate(nextProps, nextState)   - componentWillUpdate(nextProps, nextState)   - render()   - componentDidUpdate(prevProps, prevState)3. Unmounting：   - componentWillUnmount()</code></pre><h4 id="新生命周期"><a href="#新生命周期" class="headerlink" title="新生命周期"></a>新生命周期</h4><blockquote><p>在16.4之后的新生命周期中，react不推荐用三个钩子，并有在之后的版本中禁用的打算，在现版本中需要加上<code>UNSAFE_</code>前缀才可使用，具体钩子如下</p></blockquote><pre><code class="highlight js"><span class="number">1.</span>componentWillMount()<span class="number">2.</span>componentWillReceiveProps()<span class="number">3.</span>componentWillUpdate()</code></pre><blockquote><p>并且新加了两个钩子：</p></blockquote><pre><code class="highlight js"><span class="comment">// 若state的值在任何时候都取决于props，那么可以使用getDerivedStateFromProps，是一个静态函数</span><span class="comment">// 如果props传入的内容不需要影响到你的state，那么就需要返回一个null</span><span class="number">1.</span> getDerivedStateFromProps(props,state) <span class="comment">// 在更新之前获取快照 需要有一个return，return的值会被传入 componentDidMount()</span><span class="number">2.</span> getSnapshotBeforeUpdate()</code></pre><p><img src="https://LuyiaGoe.github.io/assets/posts/react%E6%96%B0%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" alt="React中组件的生命周期(新)"></p><h3 id="9-通过Counter计数器的小案例-了解生命周期函数"><a href="#9-通过Counter计数器的小案例-了解生命周期函数" class="headerlink" title="9. 通过Counter计数器的小案例 - 了解生命周期函数"></a>9. 通过Counter计数器的小案例 - 了解生命周期函数</h3><ol><li><p>给 <code>props</code> 属性提供默认值 和 进行类型校验，需要先运行<code>cnpm i prop-types --save</code></p></li><li><p>给组件的 <code>props</code> 提供默认值</p><pre><code class="highlight js"><span class="comment">// 为组件提供 默认的 props 属性值</span><span class="keyword">static</span> defaultProps = {  initcount: <span class="number">0</span> <span class="comment">// 默认值为0    如果用户没有传递 ，则 默认就是0； 如果用户传递了，则 以用户传递的为准</span>}</code></pre></li><li><p>给组件的 <code>props</code> 进行类型校验</p><pre><code class="highlight js"><span class="comment">// 3. 进行 props 属性的类型校验,   static propTypes = {}  是固定写法</span><span class="keyword">static</span> propTypes = {  initcount: PropTypes.number.isRequired <span class="comment">// 规定 外界在传递 initcount 的时候，必须是 number 值类型，否则 ，会在终端报警告</span>  <span class="comment">// isRequired 表示 这个 props 属性值 是必须要传递的</span>}</code></pre><p>​</p></li></ol><h3 id="10-使用React中的事件，绑定count自增"><a href="#10-使用React中的事件，绑定count自增" class="headerlink" title="10. 使用React中的事件，绑定count自增"></a>10. 使用React中的事件，绑定count自增</h3><h3 id="11-发表评论案例"><a href="#11-发表评论案例" class="headerlink" title="11. 发表评论案例"></a>11. 发表评论案例</h3><h3 id="相关文章-1"><a href="#相关文章-1" class="headerlink" title="相关文章"></a>相关文章</h3><p><a href="https://zh-hans.reactjs.org/docs/typechecking-with-proptypes.html#proptypes" target="_blank" rel="noopener">类型校验</a><a href="https://reactjs.org/docs/animation.html#high-level-api-reactcsstransitiongroup" target="_blank" rel="noopener">Animation Add-Ons</a></p><h2 id="React-js-day3"><a href="#React-js-day3" class="headerlink" title="React.js - day3"></a>React.js - day3</h2><h3 id="1-在-render-函数中不能使用-setState"><a href="#1-在-render-函数中不能使用-setState" class="headerlink" title="1. 在 render 函数中不能使用 setState"></a>1. 在 render 函数中不能使用 setState</h3><blockquote><p>因为：setState 会触发 render 函数的执行，如果在 render 函数中，又调用了 setState ，则会进入死循环！</p></blockquote><h3 id="2-react结合axios发起ajax请求"><a href="#2-react结合axios发起ajax请求" class="headerlink" title="2. react结合axios发起ajax请求"></a>2. react结合axios发起ajax请求</h3><ol><li><p>用于测试的API地址：</p><pre><code class="highlight plain">get 请求地址： http://39.106.32.91:3000/api/getlunbopost请求地址： http://39.106.32.91:3000/api/post</code></pre></li><li><p>全局配置<code>axios</code>从而让每个组件都能直接调用<code>axios</code>发起Ajax请求</p><pre><code class="highlight js"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">'axios'</span><span class="comment">// class 关键字 底层 也是由 普通 function 构造函数来实现的，因此 class 只是个语法糖</span>React.Component.prototype.$http = axios<span class="comment">// 在每个 用 class 关键字 创建的 组件，都可以直接调用`this.$http`来发起Ajax请求</span></code></pre></li><li><p>全局配置请求的<code>baseURL</code>地址</p><pre><code class="highlight js"><span class="comment">// 全局配置请求的URL根路径</span>axios.defaults.baseURL = <span class="string">'http://39.106.32.91:3000'</span>;</code></pre><p>​</p></li></ol><h3 id="3-品牌列表案例"><a href="#3-品牌列表案例" class="headerlink" title="3. 品牌列表案例"></a>3. 品牌列表案例</h3><h4 id="获取品牌列表数据"><a href="#获取品牌列表数据" class="headerlink" title="获取品牌列表数据"></a>获取品牌列表数据</h4><h4 id="渲染品牌列表数据"><a href="#渲染品牌列表数据" class="headerlink" title="渲染品牌列表数据"></a>渲染品牌列表数据</h4><h4 id="自定义全局时间过滤器"><a href="#自定义全局时间过滤器" class="headerlink" title="自定义全局时间过滤器"></a>自定义全局时间过滤器</h4><ol><li><p>定义全局过滤器，需要在 <code>main.js</code> 中把过滤器函数挂载给 <code>React.Component.prototype</code></p><pre><code class="highlight js"><span class="comment">// 模拟全局过滤器</span><span class="keyword">import</span> moment <span class="keyword">from</span> <span class="string">'moment'</span>React.Component.prototype.dateFormat = <span class="function"><span class="keyword">function</span> (<span class="params">dt</span>) </span>{  <span class="keyword">return</span> moment(dt).format(<span class="string">'YYYY-MM-DD HH:mm:ss'</span>)}</code></pre></li><li><p>定义私有过滤器，直接在每个组件中，定一个过滤器函数就好了：</p><pre><code class="highlight js"><span class="comment">// 模拟的是私有过滤器</span>dateFormat = <span class="function">(<span class="params">dt</span>) =&gt;</span> {  <span class="comment">// 做一系列格式化操作</span>  <span class="keyword">return</span> dt + <span class="string">'~~~~~~'</span> <span class="comment">// moment</span>}</code></pre><p>​</p></li></ol><h4 id="抽离全局配置文件globalConfig-js"><a href="#抽离全局配置文件globalConfig-js" class="headerlink" title="抽离全局配置文件globalConfig.js"></a>抽离全局配置文件<code>globalConfig.js</code></h4><h4 id="实现根据Id删除品牌数据功能"><a href="#实现根据Id删除品牌数据功能" class="headerlink" title="实现根据Id删除品牌数据功能"></a>实现根据Id删除品牌数据功能</h4><h4 id="实现添加品牌数据功能"><a href="#实现添加品牌数据功能" class="headerlink" title="实现添加品牌数据功能"></a>实现添加品牌数据功能</h4><h3 id="4-路由"><a href="#4-路由" class="headerlink" title="4. 路由"></a>4. 路由</h3><blockquote><p>什么是路由：路由就是对应关系；</p><p>后端路由：URL地址到后端处理函数之间的对应关系；</p><p>前端路由：hash地址到组件之间的对应关系；  监听<code>window.onhashchange</code>事件，并拿到最新的hash值，然后对应展示不同的组件即可；</p></blockquote><h4 id="配置路由"><a href="#配置路由" class="headerlink" title="配置路由"></a>配置路由</h4><ol><li><p>运行<code>cnpm i react-router-dom -S</code>安装依赖项</p></li><li><p>创建一个<code>App.jsx</code>根组件，并在根组件中，按需导入路由需要的三个组件：</p><pre><code class="highlight js"><span class="keyword">import</span> { HashRouter, Route, Link } <span class="keyword">from</span> <span class="string">'react-router-dom'</span></code></pre></li><li><p>在<code>App.jsx</code>中，render 函数中，最外层使用<code>HashRouter</code>进行包裹：</p><pre><code class="highlight jsx">render(){    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">HashRouter</span>&gt;</span></span>    &lt;div&gt;        &lt;h1&gt;大标题&lt;/h1&gt;<span class="xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><span class="xml">    <span class="tag">&lt;/<span class="name">HashRouter</span>&gt;</span></span>}</code></pre></li><li><p>在 需要的地方，使用<code>Link</code>组件创建路由链接，其中，通过<code>to</code>属性指定路由地址：</p><pre><code class="highlight jsx">&lt;Link to=<span class="string">"/home"</span>&gt;首页&lt;<span class="regexp">/Link&gt;</span></code></pre></li><li><p>使用<code>Route</code>组件创建路由规则，同时注意：Route组件有两重身份：1. 路由规则（path   component）；2. 占位符（用来显示匹配到的组件）</p><pre><code class="highlight js"><span class="comment">// 导入 Home 组件</span><span class="keyword">import</span> Home <span class="keyword">from</span> <span class="string">'./components/Home.jsx'</span>&lt;Route path=<span class="string">"/home"</span> component={Home}&gt;&lt;<span class="regexp">/Route&gt;</span></code></pre><p>​</p></li></ol><h4 id="路由嵌套"><a href="#路由嵌套" class="headerlink" title="路由嵌套"></a>路由嵌套</h4><h4 id="路由传参"><a href="#路由传参" class="headerlink" title="路由传参"></a>路由传参</h4><h3 id="5-使用AntDesign组件库"><a href="#5-使用AntDesign组件库" class="headerlink" title="5. 使用AntDesign组件库"></a>5. 使用AntDesign组件库</h3><h3 id="相关文章-2"><a href="#相关文章-2" class="headerlink" title="相关文章"></a>相关文章</h3><ul><li><a href="http://react-guide.github.io/react-router-cn/docs/API.html" target="_blank" rel="noopener">react-router官方文档</a><h2 id="React-js-day4-豆瓣电影"><a href="#React-js-day4-豆瓣电影" class="headerlink" title="React.js - day4 - 豆瓣电影"></a>React.js - day4 - 豆瓣电影</h2></li></ul><h3 id="1-路由"><a href="#1-路由" class="headerlink" title="1. 路由"></a>1. 路由</h3><blockquote><p>什么是路由：路由就是对应关系；</p><p>后端路由：URL地址到后端处理函数之间的对应关系；</p><p>前端路由：hash地址到组件之间的对应关系；  监听<code>window.onhashchange</code>事件，并拿到最新的hash值，然后对应展示不同的组件即可；</p></blockquote><h4 id="配置路由-1"><a href="#配置路由-1" class="headerlink" title="配置路由"></a>配置路由</h4><blockquote><p>Vue中的路由怎么使用；</p><ol><li>cnpm i <code>vue-router</code> -S</li><li>创建路由的实例对象   const router = new VueRouter({ routes: [] })    【创建路由规则】</li><li>将 new 出来的 路由实例对象，挂载到 VM 的 router 属性上；</li><li>在 对应的组件中，使用<code>&lt;router-link to="路由地址"&gt;&lt;/router-link&gt;</code>创建路由连接；</li><li>在页面上放一个 <code>&lt;router-view&gt;&lt;/router-view&gt;</code> 【路由组件的容器】</li></ol></blockquote><p>总结：如果在框架中，要使用路由，一定要有 【路由规则、路由链接、呈现路由组件的容器】</p><ol><li><p>运行<code>cnpm i react-router-dom -S</code>安装依赖项</p></li><li><p>创建一个<code>App.jsx</code>根组件，并在根组件中，按需导入路由需要的三个组件：</p><pre><code class="highlight js"><span class="comment">// Link 是路由链接</span><span class="comment">// Route是路由的规则，同时，也是路由的容器</span><span class="comment">// HashRouter 表示路由的包裹容器；在一个项目中，只需要使用唯一的一次！！！</span><span class="keyword">import</span> { HashRouter, Route, Link } <span class="keyword">from</span> <span class="string">'react-router-dom'</span></code></pre></li><li><p>在<code>App.jsx</code>中，render 函数中，最外层使用<code>HashRouter</code>进行包裹：</p><pre><code class="highlight jsx">render(){    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">HashRouter</span>&gt;</span></span>    &lt;div&gt;        &lt;h1&gt;大标题&lt;/h1&gt;<span class="xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><span class="xml">    <span class="tag">&lt;/<span class="name">HashRouter</span>&gt;</span></span>}</code></pre></li><li><p>在 需要的地方，使用<code>Link</code>组件创建路由链接，其中，通过<code>to</code>属性指定路由地址：</p><pre><code class="highlight jsx">&lt;Link to=<span class="string">"/home"</span>&gt;首页&lt;<span class="regexp">/Link&gt;</span></code></pre></li><li><p>使用<code>Route</code>组件创建路由规则，同时注意：Route组件有两重身份：1. 路由规则（path   component）；2. 占位符（用来显示匹配到的组件）</p><pre><code class="highlight js"><span class="comment">// 导入 Home 组件</span><span class="keyword">import</span> Home <span class="keyword">from</span> <span class="string">'./components/Home.jsx'</span>&lt;Route path=<span class="string">"/home"</span> component={Home}&gt;&lt;<span class="regexp">/Route&gt;</span></code></pre><p>​</p></li></ol><h4 id="路由重定向"><a href="#路由重定向" class="headerlink" title="路由重定向"></a>路由重定向</h4><ol><li><p>需要按需导入<code>Redirect</code>组件：</p><pre><code class="highlight js"><span class="keyword">import</span> { HashRouter, Route, Link, Redirect } <span class="keyword">from</span> <span class="string">'react-router-dom'</span></code></pre></li><li><p>新建一个路由规则</p><pre><code class="highlight jsx">&lt;Route exact path=<span class="string">"/"</span> render={() =&gt; <span class="xml"><span class="tag">&lt;<span class="name">Redirect</span> <span class="attr">to</span>=<span class="string">"/home"</span> /&gt;</span></span>}&gt;&lt;<span class="regexp">/Route&gt;</span><span class="regexp">/</span><span class="regexp">/ 其中  exact 属性表示 精确匹配</span><span class="regexp">/</span><span class="regexp">/ path 表示 重定向之前的 路由规则</span><span class="regexp">/</span><span class="regexp">/ render 是一个函数，必须 为 render 属性绑定一个 function，因此最佳实践是提供一个 箭头函数</span><span class="regexp">/</span><span class="regexp">/        在 提供的 箭头函数中，需要return 一个 &lt;Redirect&gt; 组件，其中， to 属性为 重定向的路由</span></code></pre><p>​</p></li></ol><h4 id="路由嵌套-1"><a href="#路由嵌套-1" class="headerlink" title="路由嵌套"></a>路由嵌套</h4><ol><li><p>react中如何实现路由嵌套：直接在需要的组件页面中，创建属于当前页面的 <code>Link</code>和<code>Route</code>，那么，这些创建的 <code>Route</code>和<code>Link</code>都属于子路由；</p></li><li><p>导入需要的路由组件:</p><pre><code class="highlight js"><span class="keyword">import</span> { Link, Route, Redirect } <span class="keyword">from</span> <span class="string">'react-router-dom'</span></code></pre></li><li><p>导入需要的子路由组件：</p><pre><code class="highlight js"><span class="comment">// 导入 子路由组件</span><span class="keyword">import</span> Tab1 <span class="keyword">from</span> <span class="string">'./Tabs/Tab1'</span><span class="keyword">import</span> Tab2 <span class="keyword">from</span> <span class="string">'./Tabs/Tab2'</span></code></pre></li><li><p>在指定页面中，创建独属于当前页面的子路由链接：</p><pre><code class="highlight jsx">&lt;Link to=<span class="string">"/about/tab1"</span>&gt;Tab1&lt;<span class="regexp">/Link&gt;&amp;nbsp;&amp;nbsp;</span><span class="regexp">&lt;Link to="/</span>about/tab2<span class="string">"&gt;Tab2&lt;/Link&gt;</span></code></pre></li><li><p>在指定页面中，创建独属于当前页面的子路由规则：</p><pre><code class="highlight jsx">{<span class="comment">/* 应该对应放置两个 Route 占位符，分别用来显示 匹配到的 路由组件 */</span>}{<span class="comment">/* 重定向的路由规则 */</span>}&lt;Route exact path=<span class="string">"/about"</span> render={() =&gt; <span class="xml"><span class="tag">&lt;<span class="name">Redirect</span> <span class="attr">to</span>=<span class="string">"/about/tab1"</span> /&gt;</span></span>}&gt;&lt;<span class="regexp">/Route&gt;</span><span class="regexp">&lt;Route path="/</span>about/tab1<span class="string">" component={Tab1}&gt;&lt;/Route&gt;</span><span class="string">&lt;Route path="</span>/about/tab2<span class="string">" component={Tab2}&gt;&lt;/Route&gt;</span></code></pre><p>​</p></li></ol><h4 id="路由传参-1"><a href="#路由传参-1" class="headerlink" title="路由传参"></a>路由传参</h4><ol><li><p>需要把路由规则中，对应参数的片段区域，使用<code>:</code>指定为参数：</p><pre><code class="highlight jsx">&lt;Route exact path=<span class="string">"/movie/:type/:id"</span> component={Movie}&gt;&lt;<span class="regexp">/Route&gt;</span></code></pre></li><li><p>获取 路由规则中匹配到的参数：</p><pre><code class="highlight js"><span class="keyword">this</span>.props.match.params</code></pre></li></ol><h4 id="编程式导航"><a href="#编程式导航" class="headerlink" title="编程式导航"></a>编程式导航</h4><p>通过 <code>this.props.history</code>对象提供的方法， 可以实现编程式导航：</p><ol><li><code>this.props.history.go(n)</code> 前进或后退N个历史记录</li><li><code>this.props.history.goBack()</code>后退1个历史记录</li><li><code>this.props.history.goForward()</code>前进1个历史记录</li><li><code>this.props.history.push('url地址')</code>跳转到哪个路由超链接中去</li></ol><h3 id="2-使用AntDesign组件库"><a href="#2-使用AntDesign组件库" class="headerlink" title="2. 使用AntDesign组件库"></a>2. 使用<a href="https://ant.design/index-cn" target="_blank" rel="noopener">AntDesign</a>组件库</h3><h4 id="完整导入和使用Ant-Design的步骤"><a href="#完整导入和使用Ant-Design的步骤" class="headerlink" title="完整导入和使用Ant Design的步骤"></a>完整导入和使用Ant Design的步骤</h4><ol><li><p>安装包<code>cnpm i antd -S</code></p></li><li><p>导入完整的样式表：</p><pre><code class="highlight js"><span class="comment">// 导入 Antd 的 样式表</span><span class="keyword">import</span> <span class="string">'antd/dist/antd.css'</span>;</code></pre></li><li><p>按需导入需要的组件：</p><pre><code class="highlight js"><span class="comment">// 按需导入 DatePicker 组件</span><span class="keyword">import</span> { DatePicker } <span class="keyword">from</span> <span class="string">'antd'</span>;</code></pre></li><li><p>把导入的组件，以标签形式引用到页面上：</p><pre><code class="highlight jsx">&lt;DatePicker /&gt;</code></pre></li><li><p>注意：由于 antd 有自己的css样式表，所以，大家需要包装提前在项目中，配置好了打包<code>.css</code>样式表的相关loader;</p></li></ol><h4 id="按需导入和使用-Ant-Design-的步骤"><a href="#按需导入和使用-Ant-Design-的步骤" class="headerlink" title="按需导入和使用 Ant Design 的步骤"></a>按需导入和使用 Ant Design 的步骤</h4><ol><li><p>运行<code>cnpm i babel-plugin-import -D</code>安装按需导入的babel插件</p></li><li><p>修改项目中的<code>.babelrc</code>文件如下,新增节点被 <code>+</code>标识：</p><pre><code class="highlight json">{  <span class="attr">"presets"</span>: [<span class="string">"env"</span>, <span class="string">"stage-0"</span>, <span class="string">"react"</span>],  <span class="attr">"plugins"</span>: [    <span class="string">"transform-runtime"</span>,+    [<span class="string">"import"</span>, { <span class="attr">"libraryName"</span>: <span class="string">"antd"</span>, <span class="attr">"libraryDirectory"</span>: <span class="string">"es"</span>, <span class="attr">"style"</span>: <span class="string">"css"</span> }]  ]}</code></pre></li><li><p>当实现了前两步以后，我们在<code>main.js</code>中，就不需要再引入样式表了；</p><p>​</p></li></ol><h3 id="3-基于Promise规范的fetch-API的使用"><a href="#3-基于Promise规范的fetch-API的使用" class="headerlink" title="3. 基于Promise规范的fetch API的使用"></a>3. 基于Promise规范的fetch API的使用</h3><h4 id="fetch的使用"><a href="#fetch的使用" class="headerlink" title="fetch的使用"></a>fetch的使用</h4><ol><li><p>作用：fetch 这个API，是专门用来发起Ajax请求的；</p></li><li><p>fetch 是由原生 JS 提供的 API ，专门用来取代 XHR 这个对象的；</p><pre><code class="highlight js">fetch(<span class="string">'请求的url地址'</span>).then(<span class="function"><span class="params">response</span> =&gt;</span> res.json()).then(data= &gt; <span class="built_in">console</span>.log(data))<span class="comment">// 注意： 第一个.then 中获取到的不是最终的数据，而是一个中间的数据流对象；</span><span class="comment">// 注意： 第一个 .then 中获取到的数据，是 一个 Response 类型的对象；</span><span class="comment">// 第二个 .then 中，获取到的才是真正的 数据；</span></code></pre></li><li><p>发起 Get 请求：</p><pre><code class="highlight js"><span class="comment">// 默认 fetch('url') 的话，发起的是 Get 请求</span>  fetch(<span class="string">'http://39.106.32.91:3000/api/getlunbo'</span>)    .then(<span class="function"><span class="params">response</span> =&gt;</span> {      <span class="comment">// 这个 response 就是 服务器返回的可读数据流，内部存储的是二进制数据；</span>      <span class="comment">// .json() 的作用，就是 读取 response 这个二进制数据流，并把 读取到的数据，转为 JSON 格式的 Promise对象</span>      <span class="keyword">return</span> response.json()    })    .then(<span class="function"><span class="params">data</span> =&gt;</span> {      <span class="comment">// 这里，第二个.then 中，拿到的 data，就是最终的数据</span>      <span class="built_in">console</span>.log(data)    })</code></pre><p>​</p></li><li><p>发起 Post 请求：</p><pre><code class="highlight js"><span class="comment">// 这是 查询参数   name=zs&amp;age=20</span>  <span class="keyword">var</span> sendData = <span class="keyword">new</span> URLSearchParams()  sendData.append(<span class="string">'name'</span>, <span class="string">'ls'</span>)  sendData.append(<span class="string">'age'</span>, <span class="number">30</span>)  fetch(<span class="string">'http://39.106.32.91:3000/api/post'</span>, {    method: <span class="string">'POST'</span>,    body: sendData <span class="comment">// 要发送给服务器的数据</span>  })    .then(<span class="function"><span class="params">response</span> =&gt;</span> response.json())    .then(<span class="function"><span class="params">data</span> =&gt;</span> <span class="built_in">console</span>.log(data))</code></pre></li><li><p>注意： fetch 无法 发起 JSONP 请求</p></li></ol><h4 id="fetch-jsonp的使用"><a href="#fetch-jsonp的使用" class="headerlink" title="fetch-jsonp的使用"></a>fetch-jsonp的使用</h4><ol><li><p><code>fetch-jsonp</code>最基本的用法：</p><pre><code class="highlight js">fetchJsonp(<span class="string">'https://api.douban.com/v2/movie/in_theaters'</span>)  .then(<span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>{    <span class="comment">// response.json()   当我们为 response 对象调用了它的 .json() 方法以后，返回的是新的 promise 实例对象</span>    <span class="keyword">return</span> response.json()  })  .then(<span class="function"><span class="keyword">function</span> (<span class="params">result</span>) </span>{    <span class="built_in">console</span>.log(result)  })</code></pre></li><li><p>注意事项：</p><ol><li>在调用 fetchJsonp 的时候，小括号中写的就是 你请求的 API 地址</li><li>当调用 fetchJsonp  以后，得到的是一个 Promise  实例对象，需要为 这个 Promise 实例对象，通过<code>.then</code>指定成功的回调函数，在第一个 <code>.then()</code>中无法拿到最终的数据，拿到的是一个 <code>Response</code> 类型的对象；</li><li>在 第一个 <code>.then</code>中，需要<code>return response.json()</code>从而返回一个新的Promise 实例；</li><li>为 第一个 <code>.then()</code>中返回的promise实例，再次通过.then指定成功回调，拿到的才是最终的数据；</li></ol><blockquote><p>总结: 第一个.then拿到的是中间数据;  第二个.then中拿到的才是最终的数据;</p></blockquote></li></ol><h3 id="4-项目结构搭建和布局"><a href="#4-项目结构搭建和布局" class="headerlink" title="4. 项目结构搭建和布局"></a>4. 项目结构搭建和布局</h3><h3 id="5-this-prop和Route的关系"><a href="#5-this-prop和Route的关系" class="headerlink" title="5. this.prop和Route的关系"></a>5. this.prop和Route的关系</h3><h3 id="6-项目API接口地址"><a href="#6-项目API接口地址" class="headerlink" title="6. 项目API接口地址"></a>6. 项目API接口地址</h3><blockquote><p>开发环境 - 请求根地址：<code>http://39.106.32.91:3005</code></p><p>上线环境 - 请求根地址：<code>https://api.douban.com</code></p></blockquote><ol><li>正在热映：<code>/v2/movie/in_theaters?start=0&amp;count=1</code></li><li>即将上映：<code>/v2/movie/coming_soon?start=0&amp;count=1</code></li><li>Top250：  <code>/v2/movie/top250?start=0&amp;count=1</code></li><li>电影详情：<code>/v2/movie/subject/26861685</code></li></ol><h3 id="相关文章-3"><a href="#相关文章-3" class="headerlink" title="相关文章"></a>相关文章</h3><ul><li><p><a href="https://reacttraining.com/react-router/web/guides/quick-start" target="_blank" rel="noopener">react-router-dom</a></p></li><li><p><a href="http://www.ruanyifeng.com/blog/2016/04/cors.html" target="_blank" rel="noopener">跨域资源共享 CORS 详解 - 阮一峰</a></p></li><li><p><a href="https://github.com/request/request" target="_blank" rel="noopener">Request - Simplified HTTP client</a></p></li><li><p><a href="http://www.w3school.com.cn/cssref/pr_transform.asp" target="_blank" rel="noopener">CSS3 transform 属性</a></p></li><li><p><a href="http://es6.ruanyifeng.com/#docs/promise" target="_blank" rel="noopener">ES6 - Promise规范 - 阮一峰</a></p></li><li><p><a href="http://www.jianshu.com/p/063f7e490e9a" target="_blank" rel="noopener">Javascript 中的神器——Promise</a></p></li><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API" target="_blank" rel="noopener">MDN - Fetch API</a></p></li><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Response" target="_blank" rel="noopener">MDN - Response</a></p></li><li><p><a href="https://www.npmjs.com/package/fetch-jsonp" target="_blank" rel="noopener">fetch-jsonp - 支持JSONP的Fetch实现</a></p></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> React React-Route </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue组件化开发</title>
      <link href="2021/03/26/Vue/VueComponentDevelopment/"/>
      <url>2021/03/26/Vue/VueComponentDevelopment/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="Vue组件化开发"><a href="#Vue组件化开发" class="headerlink" title="Vue组件化开发"></a>Vue组件化开发</h1><p>Vue很多人都会，而组件化也是近年来比较热的一个话题，那么你对Vue中的组件化了解多少呢？</p><h2 id="组件化开发："><a href="#组件化开发：" class="headerlink" title="组件化开发："></a>组件化开发：</h2><p>1、组件化开发指的是将复杂的业务拆分为一个有一个的组件2、组件化开发的组件一般来说要灵活3、组件化开发涉及到了Vue的js组件封装，需要掌握Vue基础、Vue实例方法与属性、Vue.extend、Vue插件等知识</p><h2 id="Vue实例方法与属性"><a href="#Vue实例方法与属性" class="headerlink" title="Vue实例方法与属性"></a>Vue实例方法与属性</h2><p><strong>vm.$mount(el)</strong>会将当前的组件挂载el元素上，该操作会替换当前的元素若$mount中接收的el为空，则会挂载到当前的vue实例以外的地方当vm对象中存在el时，会挂载到el上</p><p><strong>vm.$el</strong>返回当前挂载的元素</p><h2 id="Vue-extend与Vue-Component"><a href="#Vue-extend与Vue-Component" class="headerlink" title="Vue.extend与Vue.Component"></a>Vue.extend与Vue.Component</h2><p>1、Vue.Component</p><p>定义了一个在Vue的挂载点下的一个全局组件</p><p>2、Vue.extend</p><p>定义了一个未挂载的组件类</p><p>可以接收一个组件作为当前组件类的模板</p><p>使用关键字new实例组件，可以接收参数，这个组件需要手动挂载</p><p>3、插件</p><p><strong>Vue.use(Plugin, options)</strong></p><p>Plugin：若为对象时，会查找并执行对象下的install方法，若为函数，会直接执行</p><p>options：传递到insntall函数中的参数</p><blockquote><p>install函数的第一个参数是Vue，第二个参数为options</p></blockquote><h2 id="全局指定、组件、方法"><a href="#全局指定、组件、方法" class="headerlink" title="全局指定、组件、方法"></a>全局指定、组件、方法</h2><pre><code class="highlight js"><span class="keyword">import</span> MyPlugin <span class="keyword">from</span> <span class="string">""</span>MyPlugin.install=<span class="function">(<span class="params">Vue, options</span>)=&gt;</span>{    <span class="comment">// 添加全局组件</span>    Vue.component(MyPlugin.name, MyPlugin)    <span class="comment">// 挂载原型方法</span>    <span class="keyword">var</span> Plugin = Vue.extend(MyPlugin)    Vue.prototype.doPlugin = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{        <span class="keyword">var</span> plugin = <span class="keyword">new</span> Plugin({})        <span class="built_in">document</span>.body.appendChild(plugin.$mount().$el)    }    <span class="comment">// 添加全局方法或属性</span>    Vue.myGlobalMethod = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{        <span class="comment">// code</span>    }    Vue.myGlobalProperty = <span class="string">'property'</span>    <span class="comment">// 添加全局资源</span>    Vue.directive(<span class="string">'my-directive'</span>, {        bind (el, binding, vnode, oldVnode) {            <span class="comment">// code</span>        }        <span class="comment">// code</span>    })    <span class="comment">// 注入组件选项</span>    Vue.mixin({        created: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{            <span class="comment">// code</span>        } ...    })}<span class="keyword">export</span> <span class="keyword">default</span> MyPlugin</code></pre><h2 id="实例：Popup插件的封装"><a href="#实例：Popup插件的封装" class="headerlink" title="实例：Popup插件的封装"></a>实例：Popup插件的封装</h2><p>编写：<strong>src/components/Popup/Popup.vue</strong></p><pre><code class="highlight vue">&lt;template&gt;&lt;div class='popup-container' v-if="status"&gt;&lt;div class="popup-content"&gt;&lt;div class="popup-title"&gt;{{title}}&lt;/div&gt;&lt;div class="popup-msg"&gt;{{msg}}&lt;/div&gt;&lt;a class="popup-btn" href="javascript: void(0)" @click="hidePopup"&gt;x&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default {    name: 'popup'}&lt;/script&gt;&lt;style lang="scss"&gt;    div.popup-container{        position: fixed;        top: 0;        left: 0;        width: 100vw;        height: 100vh;        background: rgba(33, 33, 33, .5);        box-sizing: content-box;        div.popup-content{        position: absolute;        top: 50%;        left: 50%;        margin: -150px -300px;        background: #fff;        width: 600px;        height: 300px;    }    div.popup-title{        width: 590px;        height: 20px;        padding: 5px;        line-height: 20px;        text-align: center;        background: #3498db;    }    div.popup-msg{        width: 588px;        height: 239px;        text-align: center;        border: 1px solid #999;        border-top: none;        padding: 15px 5px;    }    a.popup-btn{        position: absolute;        top: 5px;        right: 5px;        display: block;        width: 20px;        height: 20px;        line-height: 20px;        font-size: 16px;        text-align: center;        text-decoration: none;        color: #666;        background: #f00;    }}&lt;/style&gt;</code></pre><p><strong>src/components/Popup/index.js</strong></p><pre><code class="highlight js"><span class="keyword">import</span> Popup <span class="keyword">from</span> <span class="string">'./Popup.vue'</span><span class="keyword">const</span> defaultData = {    status: <span class="literal">false</span>,    title: <span class="string">'Popup'</span>,    msg: <span class="string">'Message'</span>}Popup.install = <span class="function">(<span class="params">Vue</span>) =&gt;</span> {    <span class="keyword">let</span> PopupCom = Vue.extend(Popup)    <span class="built_in">console</span>.log(<span class="string">'PopupCom'</span>, PopupCom)    Vue.prototype.$popup = <span class="function"><span class="keyword">function</span>(<span class="params">params</span>) </span>{        <span class="keyword">let</span> popup = <span class="keyword">new</span> PopupCom({            el: <span class="built_in">document</span>.createElement(<span class="string">'div'</span>),            data() {                <span class="keyword">for</span>(<span class="keyword">let</span> item <span class="keyword">in</span> params){                    defaultData[item] = params[item]                }                <span class="keyword">return</span> defaultData            },            methods: {                hidePopup() {                    <span class="keyword">this</span>.status = <span class="literal">false</span>;                },            },        })        <span class="built_in">console</span>.log(<span class="string">'popup'</span>, popup);        <span class="built_in">console</span>.log(<span class="string">'popup.$mount()'</span>, popup.$mount());        <span class="built_in">document</span>.body.appendChild(popup.$mount().$el)    }}<span class="keyword">export</span> <span class="keyword">default</span> Popup</code></pre><p>使用：<strong>src/main.js</strong></p><pre><code class="highlight js"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./App.vue'</span><span class="comment">//引用并使用插件</span><span class="keyword">import</span> Popup <span class="keyword">from</span> <span class="string">'./components/Popup'</span>Vue.use(Popup)<span class="keyword">new</span> Vue({    render: <span class="function"><span class="params">h</span> =&gt;</span> h(App),}).$mount(<span class="string">'#app'</span>)</code></pre><p><strong>src/main.js</strong></p><pre><code class="highlight vue">&lt;template&gt;&lt;div id="app"&gt;&lt;img alt="Vue logo" src="./assets/logo.png"&gt;&lt;button @click="doit"&gt;do&lt;/button&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default {    name: 'app',    methods: {        //调用方法进行弹窗        doit() {            this.$popup({                status: true            })        }    },}&lt;/script&gt;&lt;style lang="scss"&gt;#app {    text-align: center;}&lt;/style&gt;</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unable to preventDefault inside passive event listener due to target being treated as passive</title>
      <link href="2021/03/14/Webpack/Unable%20to%20preventDefault%20inside%20passive%20event%20listener%20due%20to%20target%20being%20treated%20as%20passive/"/>
      <url>2021/03/14/Webpack/Unable%20to%20preventDefault%20inside%20passive%20event%20listener%20due%20to%20target%20being%20treated%20as%20passive/</url>
      
        <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>翻译：chrome 监听touch类事件报错：无法被动侦听事件preventDefault<br><br>这是chrome浏览器报错，目的是为了最快速地相应touch事件而做出的改变<br><br>因为preventDefault()是取消默认事件的，如果这个函数起作用的话，比如默认的表单提交，a链接的点击跳转，就不好用了<br><br>历史：当浏览器首先对默认的事件进行响应的时候，要检查一下是否进行了默认事件的取消。这样就在响应滑动操作之前有那么一丝丝的耽误时间<br><br>现在：google就决定默认取消了对这个事件的检查，默认时间就取消了。直接执行滑动操作。这样就更加的顺滑了。但是浏览器的控制台就会进行错误提醒了<br><br>具体情况：从 chrome56 开始，在 window、document 和 body 上注册的 touchstart 和 touchmove 事件处理函数，会默认为是 passive: true。浏览器忽略 preventDefault() 就可以第一时间滚动了<br><br>导致下面的效果一致：</p><pre><code class="highlight javascript">wnidow.addEventListener(<span class="string">'touchmove'</span>, func) 效果和下面一句一样wnidow.addEventListener(<span class="string">'touchmove'</span>, func, { <span class="attr">passive</span>: <span class="literal">true</span> })</code></pre><p>这样会出现新的问题:<br>如果在以上这 3 个元素的 touchstart 和 touchmove 事件处理函数中调用 e.preventDefault() ，会被浏览器忽略掉，并不会阻止默认行为</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><ol><li>注册处理函数时，用如下方式，明确声明为不是被动的<br>window.addEventListener(‘touchmove’, func, { passive: false })</li><li>应用 CSS 属性 touch-action: none; 这样任何触摸事件都不会产生默认行为，但是 touch 事件照样触发</li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Webpack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>webpack 中 使用 url-loader 后图片src=&quot;[object Module]&quot; 导致图片无法显示</title>
      <link href="2021/03/12/Webpack/webpack-URL-rules/"/>
      <url>2021/03/12/Webpack/webpack-URL-rules/</url>
      
        <content type="html"><![CDATA[<h1 id="webpack-中-使用-url-loader-后图片src-”-object-Module-”-导致图片无法显示"><a href="#webpack-中-使用-url-loader-后图片src-”-object-Module-”-导致图片无法显示" class="headerlink" title="webpack 中 使用 url-loader 后图片src=”[object Module]” 导致图片无法显示"></a>webpack 中 使用 url-loader 后图片src=”[object Module]” 导致图片无法显示</h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>在webpack.config.js文件中,对图片的匹配规则如下：</p><pre><code class="highlight javascript"><span class="built_in">module</span>.exports={  <span class="built_in">module</span>:{    rules:[      { <span class="attr">test</span>: <span class="regexp">/\.jpg|png|gif|bmp|jpeg$/</span>, <span class="attr">use</span>: <span class="string">'url-loader?limit=7630&amp;name=[hash:8]-[name].[ext]'</span> }    ]  }}</code></pre><p>打包后网页中显示图片为：<img src="https://LuyiaGoe.github.io/assets/posts/object-Module1.png" alt=""></p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>在webpack.config.js文件中,对匹配规则修改如下：</p><pre><code class="highlight javascript"><span class="built_in">module</span>.exports={  <span class="built_in">module</span>:{    rules:[      { <span class="attr">test</span>: <span class="regexp">/\.jpg|png|gif|bmp|jpeg$/</span>, <span class="attr">use</span>: <span class="string">'url-loader?limit=7630&amp;name=[hash:8]-[name].[ext]&amp;esModule=false'</span> }    ]  }}</code></pre><p>修改完成后，显示为：<img src="https://LuyiaGoe.github.io/assets/posts/object-Module2.png" alt=""></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Webpack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue 给UI库添加按需加载时启动项目时 babel-preset-es2015 报错</title>
      <link href="2021/03/11/Vue/vue%20%E7%BB%99UI%E5%BA%93%E6%B7%BB%E5%8A%A0%E6%8C%89%E9%9C%80%E5%8A%A0%E8%BD%BD%E6%97%B6%E5%90%AF%E5%8A%A8%E9%A1%B9%E7%9B%AE%E6%97%B6%20babel-preset-es2015%20%E6%8A%A5%E9%94%99/"/>
      <url>2021/03/11/Vue/vue%20%E7%BB%99UI%E5%BA%93%E6%B7%BB%E5%8A%A0%E6%8C%89%E9%9C%80%E5%8A%A0%E8%BD%BD%E6%97%B6%E5%90%AF%E5%8A%A8%E9%A1%B9%E7%9B%AE%E6%97%B6%20babel-preset-es2015%20%E6%8A%A5%E9%94%99/</url>
      
        <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>项目使用vue cli3脚手架工具构建按照element 官方文档中所示</p><p><code>npm install babel-plugin-component -D</code></p><p>然后添加.babelrc文件</p><pre><code class="highlight javascript">{  <span class="string">"presets"</span>: [[<span class="string">"es2015"</span>, { <span class="string">"modules"</span>: <span class="literal">false</span> }]],  <span class="string">"plugins"</span>: [    [      <span class="string">"component"</span>,      {        <span class="string">"libraryName"</span>: <span class="string">"element-ui"</span>,        <span class="string">"styleLibraryName"</span>: <span class="string">"theme-chalk"</span>      }    ]  ]}</code></pre><p>报如下错误：</p><pre><code class="highlight javascript"><span class="built_in">Error</span>: Cannot find <span class="built_in">module</span> <span class="string">'babel-preset-es2015'</span> <span class="keyword">from</span> <span class="string">'C:\Users\Administrator\Des</span><span class="string">ktop\vueProject\vuedemo'</span></code></pre><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><h3 id="1-此时应该安装-babel-preset-env"><a href="#1-此时应该安装-babel-preset-env" class="headerlink" title="1.此时应该安装@babel/preset-env"></a>1.此时应该安装@babel/preset-env</h3><p><code>npm i @babel/preset-env -D</code></p><h3 id="2-并且修改-babelrc文件中的’presets’属性"><a href="#2-并且修改-babelrc文件中的’presets’属性" class="headerlink" title="2.并且修改.babelrc文件中的’presets’属性"></a>2.并且修改.babelrc文件中的’presets’属性</h3><pre><code class="highlight javascript">{  <span class="string">"presets"</span>: [[<span class="string">"@babel/preset-env"</span>, { <span class="string">"modules"</span>: <span class="literal">false</span> }]],  <span class="string">"plugins"</span>: [    [      <span class="string">"component"</span>,      {        <span class="string">"libraryName"</span>: <span class="string">"element-ui"</span>,        <span class="string">"styleLibraryName"</span>: <span class="string">"theme-chalk"</span>      }    ]  ]}</code></pre><p>解决问题</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript变量转换</title>
      <link href="2021/03/09/JavaScript/JavaScriptValueChange/"/>
      <url>2021/03/09/JavaScript/JavaScriptValueChange/</url>
      
        <content type="html"><![CDATA[<h2 id="JavaScript变量转换"><a href="#JavaScript变量转换" class="headerlink" title="JavaScript变量转换 "></a>JavaScript变量转换 <span id="home"></span></h2><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><strong><a href="#1">自动转换 </a></strong><ul><li><strong><a href="#1.1">(1)Number与Boolean</a></strong></li><li><strong><a href="#1.2">(2)Number与String</a></strong></li><li><strong><a href="#1.3">(3)String与Boolean</a></strong></li><li><strong><a href="#1.4">(4)null的自动转换</a></strong></li><li><strong><a href="#1.5">(5)undefined的自动转换</a></strong></li></ul></li><li><strong><a href="#2">强制转换 </a></strong><ul><li><strong><a href="#2.1">运算强制转换 </a></strong><ul><li><strong><a href="#2.1.1">(1)Number与Boolean</a></strong></li><li><strong><a href="#2.1.2">(2)Number与String</a></strong></li><li><strong><a href="#2.1.3">(3)String与Boolean</a></strong></li><li><strong><a href="#2.1.4">(4)null</a></strong></li><li><strong><a href="#2.1.5">(5)undefined</a></strong></li></ul></li><li><strong><a href="#2.2">类型强制转换 </a></strong><ul><li><strong><a href="#2.2.1">(1)Number</a></strong></li><li><strong><a href="#2.2.2">(2)String</a></strong></li><li><strong><a href="#2.2.3">(3)Boolean</a></strong></li><li><strong><a href="#2.2.4">(4)null</a></strong></li><li><strong><a href="#2.2.5">(5)undefined</a></strong></li></ul></li></ul></li></ul><hr><h2 id="一、自动转换"><a href="#一、自动转换" class="headerlink" title="一、自动转换 "></a>一、自动转换 <span id="1"></span></h2><p>“==”的自动转换</p><p>自动转换优先级：number&gt;boolean&gt;String，越小越先转换</p><h3 id="1-Number与Boolean"><a href="#1-Number与Boolean" class="headerlink" title="(1)Number与Boolean: "></a>(1)Number与Boolean: <span id="1.1"></span></h3><pre><code>console.log(0==false); //trueconsole.log(1==true);  //trueconsole.log(2==true);  //flase//这个过程其实是Boolean类型转换为数字的过程</code></pre><h3 id="2-Number与String"><a href="#2-Number与String" class="headerlink" title="(2)Number与String: "></a>(2)Number与String: <span id="1.2"></span></h3><pre><code>console.log(""==0);  //trueconsole.log("12"==12);  //trueconsole.log("12a"==12);  //false//String自动转换时只能转换纯数字的字符串</code></pre><h3 id="3-String与Boolean"><a href="#3-String与Boolean" class="headerlink" title="(3)String与Boolean "></a>(3)String与Boolean <span id="1.3"></span></h3><pre><code>console.log(""==false);  //trueconsole.log("s"==true);  //true//字符串转换为boolean均为true</code></pre><h3 id="4-null的自动转换"><a href="#4-null的自动转换" class="headerlink" title="(4)null的自动转换 "></a>(4)null的自动转换 <span id="1.4"></span></h3><p>null的本质是空对象，自动转换时会处理空对象的引用地址，转换为数字与其他对象的处理</p><pre><code>console.log(null==0);  //false//地址是数字，且肯定不是0console.log(null==false);  //falseconsole.log(null==true);  //false//地址是数字，比较时会将boolean转换为数字console.log(null=="null");  //falseconsole.log(null=="");  //false//地址为数字，比较时会将String转换为数字</code></pre><h3 id="5-undefined的自动转换"><a href="#5-undefined的自动转换" class="headerlink" title="(5)undefined的自动转换 "></a>(5)undefined的自动转换 <span id="1.5"></span></h3><p>undefined表示未定义，不带任何东西，大家可以理解为老顽固(偷笑)</p><pre><code>console.log(undefined==0);  //false//无法自动转换数字console.log(undefined==false);  //falseconsole.log(undefined==true);  //false//无法自动转换booleanconsole.log(undefined=="");  //falseconsole.log(undefined=="undefined");  //false//无法自动转换为Stringconsole.log(undefined==null);  //trueconsole.log(undefined===null);  //false//null是空对象，会被认为是undefined，但严格的来说两者是不相等的</code></pre><h2 id="二、强制转换"><a href="#二、强制转换" class="headerlink" title="二、强制转换 "></a>二、强制转换 <span id="2"></span></h2><h3 id="1、运算强制转换"><a href="#1、运算强制转换" class="headerlink" title="1、运算强制转换 "></a>1、运算强制转换 <span id="2.1"></span></h3><p>“+”会尝试将两端的值尝试转换为字符串或数字。优先级：String&gt;Number</p><h4 id="1-Number与Boolean-1"><a href="#1-Number与Boolean-1" class="headerlink" title="(1)Number与Boolean: "></a>(1)Number与Boolean: <span id="2.1.1"></span></h4><pre><code>console.log(1+false); //1console.log(1+true);  //2</code></pre><h4 id="2-Number与String-1"><a href="#2-Number与String-1" class="headerlink" title="(2)Number与String: "></a>(2)Number与String: <span id="2.1.2"></span></h4><pre><code>console.log(""+1);  //"1"console.log("1"+1);  //"11"//运算时，String优先级大于Number，Number转换为String</code></pre><h3 id="3-String与Boolean-1"><a href="#3-String与Boolean-1" class="headerlink" title="(3)String与Boolean "></a>(3)String与Boolean <span id="2.1.3"></span></h3><pre><code>console.log(""+false);  //falseconsole.log(""+true);  //trueconsole.log(typeof(""+true));  //String//按照优先级，会将boolean转换为String</code></pre><h4 id="4-null"><a href="#4-null" class="headerlink" title="(4)null "></a>(4)null <span id="2.1.4"></span></h4><pre><code>console.log(null+1);  //1//null的本质是空对象,强制转换会转换为0</code></pre><h4 id="5-undefined"><a href="#5-undefined" class="headerlink" title="(5)undefined "></a>(5)undefined <span id="2.1.5"></span></h4><pre><code>console.log(undefined+0);  //NaN//强制转换数字时为NaNconsole.log(Boolean(undefined));  //false</code></pre><h3 id="2、类型强制转换"><a href="#2、类型强制转换" class="headerlink" title="2、类型强制转换 "></a>2、类型强制转换 <span id="2.2"></span></h3><h4 id="1-Number"><a href="#1-Number" class="headerlink" title="(1)Number "></a>(1)Number <span id="2.2.1"></span></h4><pre><code>String:这里说下String()和toString()的区别toString()可以将除了null、undefined以外的一切对象转换为String，且toString()可以接收第二个参数，将字符串的进制进行改变String()可以将任何对象转换为String，String只有一个传参Boolean:console.log(Boolean(0));  //falseconsole.log(Boolean(1));  //trueconsole.log(Boolean(2));  //trueconsole.log(Boolean(-2));  //true//除0以外均为true</code></pre><h4 id="2-String"><a href="#2-String" class="headerlink" title="(2)String "></a>(2)String <span id="2.2.2"></span></h4><pre><code>Number:console.log(Number("1"));  //1console.log(Number("1a"));  //NaNconsole.log(Number(""));  //0console.log(parseInt("1a"));  //1console.log(parseInt("a1"));  //NaNconsole.log(parseInt(""));  //NaN//使用Number进行转换时必须是纯数字字符串，否则为NaN//使用parseInt转换时，头部必须有数字，否则为NaN//parseInt是全局函数，不属于Number，与Number强制转换有区别Boolean:console.log(Boolean(""));  //falseconsole.log(Boolean("true"));  //trueconsole.log(Boolean("false"));  //true//String为空是flase，其他均为true</code></pre><h4 id="3-Boolean"><a href="#3-Boolean" class="headerlink" title="(3)Boolean "></a>(3)Boolean <span id="2.2.3"></span></h4><pre><code>Number:console.log(Number(false));  //0console.log(Number(true));  //1String:输出对应的字符串</code></pre><h4 id="4-null-1"><a href="#4-null-1" class="headerlink" title="(4)null "></a>(4)null <span id="2.2.4"></span></h4><pre><code>Number:console.log(Number(null));  //0String:输出对应的字符串Boolean:console.log(Boolean(null));  //false</code></pre><h4 id="5-undefined-1"><a href="#5-undefined-1" class="headerlink" title="(5)undefined "></a>(5)undefined <span id="2.2.5"></span></h4><pre><code>Number:console.log(Number(undefined));  //NaN//此种方式强制转换依旧为非数字String:输出对应的字符串Boolean:console.log(Boolean(undefined));  //false</code></pre><p>码字不易，后面还会放出各种文章，喜欢的关注一下我吖，你们的关注是我最大的动力</p><p>github：<a href="https://github.com/LuyiaGoe" target="_blank" rel="noopener">github.com/LuyiaGoe</a></p><p>个人博客：<a href="https://LuyiaGoe.github.io" target="_blank" rel="noopener">LuyiaGoe.github.io</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Variable </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浏览器异步加载JS的方法</title>
      <link href="2021/03/01/JavaScript/HTMLAsyncLoadScript/"/>
      <url>2021/03/01/JavaScript/HTMLAsyncLoadScript/</url>
      
        <content type="html"><![CDATA[<h1 id="浏览器异步加载JS的方法"><a href="#浏览器异步加载JS的方法" class="headerlink" title="浏览器异步加载JS的方法"></a>浏览器异步加载JS的方法</h1><h2 id="浏览器加载JS的方法"><a href="#浏览器加载JS的方法" class="headerlink" title="浏览器加载JS的方法"></a>浏览器加载JS的方法</h2><p>说到这个，最常见的就是内置JS和外联JS了</p><p>内置：</p><pre><code class="highlight html"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"><span class="built_in">console</span>.log(<span class="string">'加载完成'</span>)</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></code></pre><p>外联：</p><pre><code class="highlight html"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">""</span> <span class="attr">type</span>=<span class="string">"application/javascript"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></code></pre><p>而后，由于浏览器默认的脚本语言为JavaScript，因此type属性可以去掉。</p><pre><code class="highlight html"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">""</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></code></pre><h2 id="浏览器渲染规则"><a href="#浏览器渲染规则" class="headerlink" title="浏览器渲染规则"></a>浏览器渲染规则</h2><p>浏览器的渲染规则是，从上到下加载，正常情况下加载完马上就会执行。</p><p>CSS文件可以边加载边渲染，而JS文件必须等到加载完成才能渲染。</p><p>若在加载过程中遇到大体积的JS文件，则会等到JS加载完后才会继续渲染，对整个页面的加载造成阻塞。</p><h2 id="浏览器的异步加载"><a href="#浏览器的异步加载" class="headerlink" title="浏览器的异步加载"></a>浏览器的异步加载</h2><p>而为了解决加载阻塞问题，浏览器提供了defer属性和async属性。</p><p>那么，defer和async有什么区别呢？</p><p>给script标签加上defer属性，其内部的JS会在整个页面加载完成后才执行。这个加载完包括整个页面的渲染和其他脚本的执行。存在多个defer时，会按照顺序执行。</p><p>而若是加上async属性，JS会在该script标签加载完后执行。这个加载完成后会中断渲染来执行。执行完成后再继续渲染。由于加载速度是不确定的，多个async脚本之间无法确保执行顺序。</p><h2 id="浏览器ES6模块支持"><a href="#浏览器ES6模块支持" class="headerlink" title="浏览器ES6模块支持"></a>浏览器ES6模块支持</h2><p>在ES6中，添加了JS模块化的标准，在script标签上添加<code>type="module"</code>即可声明为ES6模块。</p><pre><code class="highlight html"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"module"</span> <span class="attr">src</span>=<span class="string">""</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></code></pre><p>对添加了<code>type="module"</code>的标签，浏览器默认会对其进行defer属性的处理，即等到整个页面加载完成后再执行，同时，也可以添加async标签，这样，该标签会在加载完成后执行。</p><pre><code class="highlight html"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"module"</span> <span class="attr">src</span>=<span class="string">""</span> <span class="attr">async</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></code></pre><p>同时，添加了<code>type="module"</code>的标签也可以直接内嵌，这样浏览器会按照默认的加载方式加载。</p><pre><code class="highlight html"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"module"</span>&gt;</span><span class="javascript">    <span class="keyword">import</span> moduleA <span class="keyword">from</span> <span class="string">'./moduleA.js'</span></span><span class="javascript"><span class="built_in">console</span>.log(<span class="string">'加载完成'</span>)</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> HTML </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Async </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1ink与@import的区别</title>
      <link href="2021/02/13/HTML&amp;CSS/CSSImport/"/>
      <url>2021/02/13/HTML&amp;CSS/CSSImport/</url>
      
        <content type="html"><![CDATA[<h2 id="1ink与-import的区别"><a href="#1ink与-import的区别" class="headerlink" title="1ink与@import的区别 "></a><code>1ink</code>与<code>@import</code>的区别 <span id="home"></span></h2><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><strong><a href="#1"><code>1ink</code>与<code>@import</code>的区别 </a></strong><ul><li><strong><a href="#1.1">差别1：归属关系的差别 </a></strong></li><li><strong><a href="#1.2">差别2：加载顺序的差别 </a></strong><ul><li><strong><a href="#3.1">差别3：兼容性的差别 </a></strong></li><li><strong><a href="#3.1">差别4：使用dom控制样式时的差别 </a></strong></li></ul></li></ul></li></ul><hr><h2 id="1ink与-import的区别-1"><a href="#1ink与-import的区别-1" class="headerlink" title="1ink与@import的区别 "></a><code>1ink</code>与<code>@import</code>的区别 <span id="1"></span></h2><h4 id="差别1：归属关系的差别"><a href="#差别1：归属关系的差别" class="headerlink" title="差别1：归属关系的差别 "></a>差别1：归属关系的差别 <span id="1.1"></span></h4><p><code>link</code>属于<code>xhtml</code>标签，而<code>@import</code>属于<code>css</code>提供的方式，必须写在<code>style</code>标签里。<code>link</code>标签除了可以加载<code>css</code>外，还可以定义RSS、定义<code>rel</code>连接属性等，<code>＠import</code>只能加载<code>css</code>。</p><h4 id="差别2：加载顺序的差别"><a href="#差别2：加载顺序的差别" class="headerlink" title="差别2：加载顺序的差别 "></a>差别2：加载顺序的差别 <span id="1.2"></span></h4><p>当一个页面被加载的时候，即浏览者浏览页面时，<code>link</code>引用的<code>css</code>会同时被加载，而<code>@import</code>引用的<code>css</code>会等到页面全部被下载完后加载。使用<code>＠import</code>可能存在页面的样式在开始时不显示的问题。</p><h4 id="差别3：兼容性的差别"><a href="#差别3：兼容性的差别" class="headerlink" title="差别3：兼容性的差别 "></a>差别3：兼容性的差别 <span id="1.2"></span></h4><p><code>@import</code>是<code>CSS2.1</code>提出的，只在IE5以上才能识别，而<code>link</code>标签不存在兼容问题。</p><h4 id="差别4：使用dom控制样式时的差别"><a href="#差别4：使用dom控制样式时的差别" class="headerlink" title="差别4：使用dom控制样式时的差别 "></a>差别4：使用dom控制样式时的差别 <span id="1.2"></span></h4><p>当使用<code>JS</code>控制<code>dom</code>改变样式时，只能使用<code>link</code>，<code>dom</code>无法控制<code>＠import</code>。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>窗口间的通信与iframe跨域</title>
      <link href="2020/12/21/JavaScript/JavaScriptIframeCrossOrigin/"/>
      <url>2020/12/21/JavaScript/JavaScriptIframeCrossOrigin/</url>
      
        <content type="html"><![CDATA[<h1 id="窗口间的通信与-iframe-跨域"><a href="#窗口间的通信与-iframe-跨域" class="headerlink" title="窗口间的通信与 iframe 跨域"></a>窗口间的通信与 iframe 跨域</h1><h2 id="iframe-跨域场景"><a href="#iframe-跨域场景" class="headerlink" title="iframe 跨域场景"></a>iframe 跨域场景</h2><p>1、若需要通讯的两个窗口在同源域名下，则无需跨域。</p><p>2、若需要通讯的两个窗口在同一个顶级域名下，可以手动配置两个窗口的域名为该顶级域名，从而实现通讯。代码如下：</p><pre><code class="highlight js"><span class="built_in">document</span>.domain = <span class="string">"localhost"</span>;</code></pre><p>3、若需要通讯的两个窗口不在同一顶级域名下，则需要使用到 postMessage 方法。</p><h2 id="postMessage"><a href="#postMessage" class="headerlink" title="postMessage"></a>postMessage</h2><p>该方法是 window 下的一个方法，用于发送一条消息。</p><p>对应的事件是 onmessage 事件。</p><pre><code class="highlight js"><span class="keyword">const</span> recvMsg = <span class="function"><span class="params">event</span> =&gt;</span> {  <span class="keyword">if</span> (event.origin === <span class="string">"http://localhost:8080"</span>) {    <span class="built_in">console</span>.log(event.data);  }};<span class="built_in">window</span>.onmessage = recvMsg;<span class="comment">// 也可以用事件监听</span><span class="comment">// window.addEventListener("message", recvMsg)</span></code></pre><p>该方法可以在其他的窗口中调用，而不会产生跨域问题。（安全通讯）</p><h2 id="获取到不同窗口的-window-对象"><a href="#获取到不同窗口的-window-对象" class="headerlink" title="获取到不同窗口的 window 对象"></a>获取到不同窗口的 window 对象</h2><p>1、若是使用 window.open 打开，则可以通过 window.opener 获取到 window 对象。</p><p>2、若是使用 iframe 引用，则可以通过使用 window.top 获取到 window 对象。</p><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><p>1、同顶级域名localhost 域名<code>index.html</code></p><pre><code class="highlight html"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span><span class="tag">&lt;<span class="name">html</span>&gt;</span>  <span class="tag">&lt;<span class="name">body</span>&gt;</span>    <span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">"http://localhost:8080/iframe.html"</span> <span class="attr">frameborder</span>=<span class="string">"0"</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span>    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript">      <span class="built_in">document</span>.domain = <span class="string">"localhost"</span>;</span><span class="javascript">      <span class="built_in">window</span>.list = [];</span><span class="javascript">      <span class="built_in">window</span>.setValue = <span class="function">(<span class="params">key, value</span>) =&gt;</span> {</span><span class="javascript">        <span class="built_in">window</span>[key] = value;</span>      };<span class="javascript">      <span class="built_in">window</span>.getValue = <span class="function"><span class="params">key</span> =&gt;</span> {</span><span class="javascript">        <span class="keyword">return</span> <span class="built_in">window</span>[key];</span>      };    <span class="tag">&lt;/<span class="name">script</span>&gt;</span>  <span class="tag">&lt;/<span class="name">body</span>&gt;</span><span class="tag">&lt;/<span class="name">html</span>&gt;</span></code></pre><p>localhost:8080 域名<code>iframe.html</code></p><pre><code class="highlight html"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span><span class="tag">&lt;<span class="name">html</span>&gt;</span>  <span class="tag">&lt;<span class="name">body</span>&gt;</span>    iframe    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript">      <span class="built_in">document</span>.domain = <span class="string">"localhost"</span>;</span><span class="javascript">      <span class="built_in">console</span>.log(top.setValue(<span class="string">"list"</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]));</span><span class="javascript">      <span class="built_in">console</span>.log(top.getValue(<span class="string">"list"</span>));</span>    <span class="tag">&lt;/<span class="name">script</span>&gt;</span>  <span class="tag">&lt;/<span class="name">body</span>&gt;</span><span class="tag">&lt;/<span class="name">html</span>&gt;</span></code></pre><p>2、open 形式localhost 域名<code>index.html</code></p><pre><code class="highlight html"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span><span class="tag">&lt;<span class="name">html</span>&gt;</span>  <span class="tag">&lt;<span class="name">body</span>&gt;</span>    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript">      <span class="built_in">window</span>.open(<span class="string">"http://localhost:8080/iframe.html"</span>);</span><span class="javascript">      <span class="built_in">window</span>.onmessage = <span class="function"><span class="params">event</span> =&gt;</span> {</span><span class="actionscript">        <span class="keyword">if</span> (event.origin == <span class="string">"http://localhost:8080"</span>) {</span><span class="javascript">          <span class="built_in">console</span>.log(event.origin, event.data);</span>        }      };    <span class="tag">&lt;/<span class="name">script</span>&gt;</span>  <span class="tag">&lt;/<span class="name">body</span>&gt;</span><span class="tag">&lt;/<span class="name">html</span>&gt;</span></code></pre><p>localhost:8080 域名<code>iframe.html</code></p><pre><code class="highlight html"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span><span class="tag">&lt;<span class="name">html</span>&gt;</span>  <span class="tag">&lt;<span class="name">body</span>&gt;</span>    iframe    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript">      <span class="built_in">window</span>.onload = <span class="function"><span class="params">()</span> =&gt;</span> {</span><span class="javascript">        <span class="built_in">window</span>.opener.postMessage(<span class="string">"value"</span>, <span class="string">"http://localhost"</span>);</span>      };    <span class="tag">&lt;/<span class="name">script</span>&gt;</span>  <span class="tag">&lt;/<span class="name">body</span>&gt;</span><span class="tag">&lt;/<span class="name">html</span>&gt;</span></code></pre><p>3、iframe 形式localhost 域名<code>index.html</code></p><pre><code class="highlight html"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span><span class="tag">&lt;<span class="name">html</span>&gt;</span>  <span class="tag">&lt;<span class="name">body</span>&gt;</span>    <span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">"http://localhost:8080/iframe.html"</span> <span class="attr">frameborder</span>=<span class="string">"0"</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span>    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript">      <span class="built_in">window</span>.onmessage = <span class="function"><span class="params">event</span> =&gt;</span> {</span><span class="actionscript">        <span class="keyword">if</span> (event.origin == <span class="string">"http://localhost:8080"</span>) {</span><span class="javascript">          <span class="built_in">console</span>.log(event.origin, event.data);</span>        }      };    <span class="tag">&lt;/<span class="name">script</span>&gt;</span>  <span class="tag">&lt;/<span class="name">body</span>&gt;</span><span class="tag">&lt;/<span class="name">html</span>&gt;</span></code></pre><p>localhost:8080 域名<code>iframe.html</code></p><pre><code class="highlight html"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span><span class="tag">&lt;<span class="name">html</span>&gt;</span>  <span class="tag">&lt;<span class="name">body</span>&gt;</span>    iframe    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript">      <span class="built_in">window</span>.onload = <span class="function"><span class="params">()</span> =&gt;</span> {</span><span class="javascript">        <span class="built_in">window</span>.top.postMessage(<span class="string">"value"</span>, <span class="string">"http://localhost"</span>);</span>      };    <span class="tag">&lt;/<span class="name">script</span>&gt;</span>  <span class="tag">&lt;/<span class="name">body</span>&gt;</span><span class="tag">&lt;/<span class="name">html</span>&gt;</span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iframe </tag>
            
            <tag> postMessage </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>package.json详解</title>
      <link href="2020/11/11/Node/NodePackage.json/"/>
      <url>2020/11/11/Node/NodePackage.json/</url>
      
        <content type="html"><![CDATA[<h1 id="package-json详解"><a href="#package-json详解" class="headerlink" title="package.json详解"></a>package.json详解</h1><p><strong>name</strong>: 包名称，符合正则<code>/\w+/</code></p><p><strong>description</strong>：包详情</p><p><strong>author</strong>：包作者</p><p><strong>version</strong>：版本</p><p><strong>keywords</strong>：关键字数组</p><p><strong>maintainers</strong>：维护者数组，元素包含name [, name] [, web]</p><p><strong>licenses</strong>：许可证数组, 元素包含type和url</p><p><strong>repositories</strong>: 仓库托管地址数组, 元素包含type(仓库类型，如git)、url和path(相对于仓库的路径)</p><p><strong>dependencies</strong>: 生产环境所依赖的包, 关联数组，由包名称和版本号组成</p><p><strong>devDependencies</strong>: 开发环境所依赖的包，一个关联数组，由包名称和版本号组成</p><p><strong>main</strong>: 被require时的入口js文件</p><p><strong>node-echo</strong>: 命令行程序名和主模块位置</p><p><strong>bin</strong>: 用来指定各个内部命令对应的可执行文件的位置，可用于其他命令中，如scripts</p><pre><code class="highlight json">"bin": {    "someTool": "./bin/someTool.js"  }</code></pre><p><strong>config</strong>: 添加命令行的环境变量，在js文件中可以进行引用，如：</p><pre><code class="highlight js">process.env.npm_package_config_[key]</code></pre><p><strong>scripts</strong>: 定义脚本命令，使用<code>npm run [command]</code> 或 <code>npm [command]</code>  执行</p><pre><code class="highlight json">"scripts": {    "start": "node index.js",    "test": "tap test/*.js",    "myscript": "echo myscript"}</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Node </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Npm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Object原型梳理</title>
      <link href="2020/11/11/JavaScript/JavaScriptObjectPrototype/"/>
      <url>2020/11/11/JavaScript/JavaScriptObjectPrototype/</url>
      
        <content type="html"><![CDATA[<h1 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h1><p>最近我建议你读Vue框架的源码，你说你看不懂？什么？Object的方法不会？好吧，来，先来恶补一波Object原型吧~</p><p>Object是一种引用数据类型，也是一个构造函数。</p><h2 id="Object属性"><a href="#Object属性" class="headerlink" title="Object属性"></a>Object属性</h2><h3 id="1、Object-prototype"><a href="#1、Object-prototype" class="headerlink" title="1、Object.prototype"></a>1、Object.prototype</h3><p>Object的原型。Object原型处于原型链的顶端，是所有对象的原型。</p><h3 id="2、Object-name"><a href="#2、Object-name" class="headerlink" title="2、Object.name"></a>2、Object.name</h3><p>返回Object函数名。</p><h2 id="Object方法"><a href="#Object方法" class="headerlink" title="Object方法"></a>Object方法</h2><h3 id="1、Object-assign"><a href="#1、Object-assign" class="headerlink" title="1、Object.assign()"></a>1、Object.assign()</h3><p>将两个对象合并，并返回新的对象。在产生冲突时，后者的属性会覆盖前者。该方法属于浅拷贝。</p><pre><code class="highlight js"><span class="keyword">var</span> target={<span class="attr">name</span>: <span class="string">"failte"</span>, <span class="attr">age</span>: <span class="number">18</span>};<span class="keyword">var</span> source={<span class="attr">sex</span>: <span class="string">"man"</span>, <span class="attr">age</span>: <span class="number">22</span>};<span class="keyword">var</span> obj = <span class="built_in">Object</span>.assign(target, source);</code></pre><h3 id="2、Object-create"><a href="#2、Object-create" class="headerlink" title="2、Object.create()"></a>2、Object.create()</h3><p>以对象原型，创建一个新对象。第一个参数为原型对象，第二个参数为新描述符属性对象。</p><pre><code class="highlight js"><span class="keyword">var</span> obj = {    <span class="keyword">this</span>.a=<span class="string">"a"</span>;    <span class="keyword">this</span>.b=<span class="string">"b"</span>};<span class="keyword">var</span> nobj = <span class="built_in">Object</span>.create(obj, {    name: {        value: <span class="number">42</span>,        writable: <span class="literal">true</span>,        enumerable: <span class="literal">true</span>,        configurable: <span class="literal">true</span>    }});</code></pre><h3 id="3、Object-seal"><a href="#3、Object-seal" class="headerlink" title="3、Object.seal()"></a>3、Object.seal()</h3><p>封装对象。封装后的对象无法增删属性，但可以修改属性。可以通过<code>Object.isSealed()</code>方法判断对象是否被封装。</p><pre><code class="highlight js"><span class="keyword">var</span> obj = {<span class="attr">a</span>: <span class="number">1</span>};<span class="built_in">Object</span>.seal(obj);obj.b = <span class="string">'el'</span>;<span class="keyword">delete</span> obj.a;<span class="built_in">console</span>.log(obj);</code></pre><h3 id="4、Object-freeze"><a href="#4、Object-freeze" class="headerlink" title="4、Object.freeze()"></a>4、Object.freeze()</h3><p>冻结对象。被冻结的对象增删改属性。返回和传入的参数是同一对象。可以使用<code>Object.isFrozen()</code>方法判断对象是否被冻结。</p><pre><code class="highlight js"><span class="keyword">var</span> obj = {<span class="attr">a</span>: <span class="number">1</span>};<span class="built_in">Object</span>.freeze(obj);obj.b = <span class="number">2</span>;<span class="keyword">delete</span> obj.a;obj.a = <span class="number">10</span>;<span class="built_in">console</span>.log(obj);</code></pre><h3 id="5、Object-is"><a href="#5、Object-is" class="headerlink" title="5、Object.is()"></a>5、Object.is()</h3><p>判断两个对象是否相同。比较两方为 undefined、null、true、false、相同字符串、同一对象、NaN、+0、0、-0、数字时，返回true，其他情况返回false。</p><pre><code class="highlight js"><span class="keyword">var</span> obj = {<span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>};<span class="built_in">console</span>.log(<span class="built_in">Object</span>.is(<span class="literal">undefined</span>, <span class="literal">undefined</span>));<span class="built_in">console</span>.log(<span class="built_in">Object</span>.is(<span class="literal">null</span>, <span class="literal">null</span>));<span class="built_in">console</span>.log(<span class="built_in">Object</span>.is(<span class="literal">true</span>, <span class="literal">true</span>));<span class="built_in">console</span>.log(<span class="built_in">Object</span>.is(<span class="literal">false</span>, <span class="literal">false</span>));<span class="built_in">console</span>.log(<span class="built_in">Object</span>.is(<span class="string">'aaa'</span>, <span class="string">'aaa'</span>));<span class="built_in">console</span>.log(<span class="built_in">Object</span>.is(obj, obj));<span class="built_in">console</span>.log(<span class="built_in">Object</span>.is(<span class="literal">NaN</span>, <span class="literal">NaN</span>));<span class="built_in">console</span>.log(<span class="built_in">Object</span>.is(<span class="number">-0</span>, <span class="number">-0</span>));<span class="built_in">console</span>.log(<span class="built_in">Object</span>.is(+<span class="number">0</span>, +<span class="number">0</span>));<span class="built_in">console</span>.log(<span class="built_in">Object</span>.is(<span class="number">0</span>, <span class="number">0</span>));<span class="built_in">console</span>.log(<span class="built_in">Object</span>.is(<span class="number">100</span>, <span class="number">100</span>));</code></pre><h3 id="6、Object-preventExtensions"><a href="#6、Object-preventExtensions" class="headerlink" title="6、Object.preventExtensions()"></a>6、Object.preventExtensions()</h3><p>限制对象不可扩展。可以通过<code>Object.isExtensible()</code>判断对象是否被限制。</p><pre><code class="highlight js"><span class="keyword">var</span> obj = {<span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>};<span class="built_in">Object</span>.preventExtensions(obj);obj.c = <span class="number">3</span>;<span class="built_in">console</span>.log(obj);</code></pre><h3 id="7、Object-getOwnPropertyNames"><a href="#7、Object-getOwnPropertyNames" class="headerlink" title="7、Object.getOwnPropertyNames()"></a>7、Object.getOwnPropertyNames()</h3><p>返回对象可以遍历的属性的键名数组。</p><p>ES6的简洁写法为：<code>Object.keys(obj)</code></p><pre><code class="highlight js"><span class="keyword">var</span> obj = {<span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>};<span class="built_in">console</span>.log(<span class="built_in">Object</span>.keys(obj));</code></pre><h3 id="8、obj-hasOwnProperty"><a href="#8、obj-hasOwnProperty" class="headerlink" title="8、obj.hasOwnProperty()"></a>8、obj.hasOwnProperty()</h3><p>判断对象是否存在属性</p><p>ES6简洁写法：<code>key in obj</code></p><pre><code class="highlight js"><span class="keyword">var</span> obj = {<span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>};<span class="built_in">console</span>.log(obj.hasOwnProperty(<span class="string">'a'</span>)); <span class="comment">// ES5</span><span class="built_in">console</span>.log(<span class="string">'a'</span> <span class="keyword">in</span> obj); <span class="comment">//ES6</span></code></pre><h3 id="9、Object-getOwnPropertyDescriptor"><a href="#9、Object-getOwnPropertyDescriptor" class="headerlink" title="9、Object.getOwnPropertyDescriptor()"></a>9、Object.getOwnPropertyDescriptor()</h3><p>查询对象属性的描述符。</p><pre><code class="highlight js"><span class="keyword">var</span> obj = {<span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>};<span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptor(obj, <span class="string">'a'</span>));</code></pre><h3 id="10、Object-getOwnPropertyDescriptors"><a href="#10、Object-getOwnPropertyDescriptors" class="headerlink" title="10、Object.getOwnPropertyDescriptors()"></a>10、Object.getOwnPropertyDescriptors()</h3><p>查询对象的描述符。</p><pre><code class="highlight js"><span class="keyword">var</span> obj = {<span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>};<span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptors(obj));</code></pre><h3 id="11、Object-getOwnPropertySymbols"><a href="#11、Object-getOwnPropertySymbols" class="headerlink" title="11、Object.getOwnPropertySymbols()"></a>11、Object.getOwnPropertySymbols()</h3><p>返回对象所有的Symbol值属性键名数组。</p><pre><code class="highlight js"><span class="keyword">var</span> obj = {<span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>, [<span class="built_in">Symbol</span>(<span class="string">'a'</span>)]: <span class="number">3</span>};<span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertySymbols(obj));</code></pre><h3 id="12、Object-defineProperties"><a href="#12、Object-defineProperties" class="headerlink" title="12、Object.defineProperties()"></a>12、Object.defineProperties()</h3><p>定义对象属性。</p><pre><code class="highlight js"><span class="keyword">var</span> obj = {};<span class="built_in">Object</span>.defineProperties(obj, <span class="string">"val"</span>, {    value: <span class="literal">undefined</span>, <span class="comment">// 属性值，默认undefined</span>    writable: <span class="literal">false</span>, <span class="comment">// 是否可写，默认false</span>    enumerable: <span class="literal">false</span>, <span class="comment">// 是否可枚举，默认false</span>    configurable: <span class="literal">false</span>, <span class="comment">// 是否可配置，默认false</span>    <span class="keyword">get</span>: undefined, // 该属性的getter，默认undefined    <span class="keyword">set</span>: undefined, // 该属性的setter，默认undefined})</code></pre><h3 id="13、Object-values"><a href="#13、Object-values" class="headerlink" title="13、Object.values()"></a>13、Object.values()</h3><p>返回对象所有的属性值数组。</p><pre><code class="highlight js"><span class="keyword">var</span> obj = {<span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>};<span class="built_in">console</span>.log(<span class="built_in">Object</span>.values(obj));</code></pre><h3 id="14、Object-entries"><a href="#14、Object-entries" class="headerlink" title="14、Object.entries()"></a>14、Object.entries()</h3><p>返回对象所有属性与属性值的键值对列表。</p><pre><code class="highlight js"><span class="keyword">var</span> obj = {<span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>};<span class="built_in">console</span>.log(<span class="built_in">Object</span>.entries(obj));</code></pre><h3 id="15、Object-fromEntries"><a href="#15、Object-fromEntries" class="headerlink" title="15、Object.fromEntries()"></a>15、Object.fromEntries()</h3><p>把键值对列表转换为一个对象。与Object.entries()方法相反。</p><pre><code class="highlight js"><span class="keyword">var</span> obj = {<span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>};<span class="keyword">var</span> entries = <span class="built_in">Object</span>.entries(obj);<span class="built_in">console</span>.log(<span class="built_in">Object</span>.fromEntries(entries));</code></pre><h3 id="16、Object-getPrototypeOf"><a href="#16、Object-getPrototypeOf" class="headerlink" title="16、Object.getPrototypeOf()"></a>16、Object.getPrototypeOf()</h3><p>获取对象的原型。相当于直接获取obj.prototype。</p><pre><code class="highlight js"><span class="keyword">var</span> obj = {<span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>};<span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(obj));</code></pre><h3 id="17、Object-setPrototypeOf"><a href="#17、Object-setPrototypeOf" class="headerlink" title="17、Object.setPrototypeOf()"></a>17、Object.setPrototypeOf()</h3><p>设置对象的原型。相当于直接设置obj.prototype。</p><pre><code class="highlight js"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params"></span>) </span>{    <span class="keyword">this</span>.a = <span class="number">1</span>;    <span class="keyword">this</span>.b = <span class="number">2</span>;}<span class="keyword">var</span> obj = {};<span class="built_in">Object</span>.setPrototypeOf(obj, <span class="keyword">new</span> Animal());<span class="built_in">console</span>.log(obj.a);</code></pre><h3 id="18、Object-toString"><a href="#18、Object-toString" class="headerlink" title="18、Object.toString()"></a>18、Object.toString()</h3><h2 id="原型方法"><a href="#原型方法" class="headerlink" title="原型方法"></a>原型方法</h2><h3 id="1、apply"><a href="#1、apply" class="headerlink" title="1、apply()"></a>1、apply()</h3><p>可以修改this的指向，执行并返回改变指向后的函数的运行结果。</p><p>原函数的传参以数组的方式传入。</p><h3 id="2、arguments"><a href="#2、arguments" class="headerlink" title="2、arguments"></a>2、arguments</h3><p>返回当前函数的实参列表。</p><p>get/set</p><h3 id="3、bind"><a href="#3、bind" class="headerlink" title="3、bind()"></a>3、bind()</h3><p>可以修改this的指向，返回改变指向后的函数。</p><h3 id="4、call"><a href="#4、call" class="headerlink" title="4、call()"></a>4、call()</h3><p>可以修改this的指向，执行并返回改变指向后的函数的运行结果。</p><p>原函数的传参以多个参数的的方式传入。</p><p>get/set</p><h3 id="5、caller"><a href="#5、caller" class="headerlink" title="5、caller()"></a>5、caller()</h3><p>返回函数的调用环境。</p><h3 id="6、constructor"><a href="#6、constructor" class="headerlink" title="6、constructor()"></a>6、constructor()</h3><p>返回当前对象的构造函数。</p><h3 id="7、length"><a href="#7、length" class="headerlink" title="7、length"></a>7、length</h3><p>返回当前函数的形参个数。</p><h3 id="8、name"><a href="#8、name" class="headerlink" title="8、name"></a>8、name</h3><p>返回当前对象的名称。</p><h3 id="9、toString"><a href="#9、toString" class="headerlink" title="9、toString()"></a>9、toString()</h3><p>返回当前对象的字符串形式。</p><h3 id="10、Symbol-hasInstance"><a href="#10、Symbol-hasInstance" class="headerlink" title="10、Symbol.hasInstance"></a>10、Symbol.hasInstance</h3><p>判断某对象是否为某构造器的实例。用它自定义instanceof操作符在某个类上的行为。</p><p>获取Function原型的instanceof对应的方法</p><pre><code class="highlight js"><span class="keyword">var</span> func = <span class="function"><span class="params">()</span> =&gt;</span> {};<span class="keyword">var</span> obj = {};<span class="keyword">var</span> log1 = <span class="built_in">Function</span>[<span class="built_in">Symbol</span>.hasInstance](func, <span class="built_in">Function</span>);<span class="keyword">var</span> log2 = <span class="built_in">Object</span>[<span class="built_in">Symbol</span>.hasInstance](obj, <span class="built_in">Object</span>);<span class="built_in">console</span>.log(log1, log2)</code></pre><p>自定义类，并重写instanceof方法</p><pre><code class="highlight js"><span class="class"><span class="keyword">class</span> <span class="title">My</span> </span>{[<span class="built_in">Symbol</span>.hasInstance](instance) {<span class="built_in">console</span>.log(instance)<span class="keyword">return</span> <span class="literal">true</span>;}<span class="keyword">constructor</span>() {<span class="keyword">this</span>.a=<span class="number">1</span>}}<span class="keyword">var</span> my = <span class="keyword">new</span> My()<span class="built_in">console</span>.log(my <span class="keyword">instanceof</span> My)</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Object </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>节流和防抖</title>
      <link href="2020/11/11/JavaScript/%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81/"/>
      <url>2020/11/11/JavaScript/%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81/</url>
      
        <content type="html"><![CDATA[<h2 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h2><p>定义：在一段时间内，多次触发同一函数，只执行第一次触发的函数</p><h3 id="1、实现"><a href="#1、实现" class="headerlink" title="1、实现"></a>1、实现</h3><p>如下实现的关键是靠一个标识flag达成，只有标识为true才被允许创建一个定时器，设置完后将标识改为false防止再次创建，只有定时器所定的回调执行后，标识才会被设置回true</p><pre><code class="highlight javascript"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">callback,delay</span>)</span>{  <span class="keyword">let</span> flag = <span class="literal">true</span>;  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{    <span class="keyword">if</span>(!flag) <span class="keyword">return</span>    flag = <span class="literal">false</span>    setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>{      callback()      flag = <span class="literal">true</span>    },delay)  }}</code></pre><h3 id="2、应用"><a href="#2、应用" class="headerlink" title="2、应用"></a>2、应用</h3><ul><li>滚动加载，加载更多或者滚到底部监听</li><li>频繁点击按钮</li></ul><h2 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h2><p>定义：在函数被触发的n秒内，如果又被触发，就会重新计时</p><h3 id="1、实现-1"><a href="#1、实现-1" class="headerlink" title="1、实现"></a>1、实现</h3><p>如下实现关键靠一个标识flag达成，只有标识为true才设置一个定时器，设置完后将标识改为false，只有定时器执行后，标识才会被设置回true</p><pre><code class="highlight javascript"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">callback,delay</span>)</span>{  <span class="keyword">let</span> timer = <span class="literal">null</span>;  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{    clearTimeout(timer)  timer = setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>{      callback()    },delay)  }}</code></pre><h3 id="2、应用-1"><a href="#2、应用-1" class="headerlink" title="2、应用"></a>2、应用</h3><ul><li>input输入动作触发搜索事件</li><li>验证</li><li>resize事件</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Object </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字符串拼接性能优化</title>
      <link href="2020/10/09/JavaScript/JavaScriptStringBuffer/"/>
      <url>2020/10/09/JavaScript/JavaScriptStringBuffer/</url>
      
        <content type="html"><![CDATA[<h1 id="字符串拼接性能优化"><a href="#字符串拼接性能优化" class="headerlink" title="字符串拼接性能优化"></a>字符串拼接性能优化</h1><p>在Java中，对大量字符串处理时存在StringBuilder、StringBuffer来进行优化，那么JavaScript的String是否也能进行优化呢？</p><p>这里以Java的StringBuffer为命名实现了一个JavaScript的StringBuffer。</p><h2 id="传统String拼接"><a href="#传统String拼接" class="headerlink" title="传统String拼接"></a>传统String拼接</h2><ul><li><strong><code>ECMAScript</code></strong> 的字符串的值 <strong>不能改变</strong>。</li></ul><h3 id="字符串拼接过程"><a href="#字符串拼接过程" class="headerlink" title="字符串拼接过程"></a>字符串拼接过程</h3><pre><code class="highlight js">&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">var</span> str = <span class="string">"hello "</span>;&nbsp;&nbsp;&nbsp;&nbsp;str += <span class="string">"world"</span>;</code></pre><p>以上代码的执行步骤如下：</p><ul><li>1、创建存储 “hello “ 的字符串。</li><li>2、创建存储 “world” 的字符串。</li><li>3、创建存储连接结果的字符串。</li><li>4、把 str 的当前内容复制到结果中。</li><li>5、把 “world” 复制到结果中。</li><li>6、更新 str，使它指向结果。</li></ul><p>每次完成字符串连接都会执行步骤 2 到 6，使得这种操作非常消耗资源。如果重复这一过程几百次，甚至几千次，就会造成性能问题。</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><h3 id="数组解决方法"><a href="#数组解决方法" class="headerlink" title="数组解决方法"></a>数组解决方法</h3><p>用 <code>Array</code> 对象存储字符串，然后用 <code>join()</code> 方法创建最后的字符串。</p><pre><code class="highlight js"><span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>();arr[<span class="number">0</span>] = <span class="string">"hello "</span>;arr[<span class="number">1</span>] = <span class="string">"world"</span>;<span class="keyword">var</span> str = arr.join(<span class="string">""</span>);</code></pre><p>以上代码的执行步骤如下：</p><ul><li>1、创建数组</li><li>2、将需要拼接的字符串加入数组</li><li>3、调用join方法，创建存储结果的字符串，将数组中的元素全部拼接到字符串使用该方法只在调用 join() 方法时才会发生连接操作。缺陷：这段代码不能确切反映出它的意图。</li></ul><h4 id="StringBuffer类打包"><a href="#StringBuffer类打包" class="headerlink" title="StringBuffer类打包"></a>StringBuffer类打包</h4><ul><li>为了解决传统方法存在的缺陷，可以将传统方法类打包为StringBuffer，专门解决拼接问题。</li><li>该类存在两个方法，即 append() 和 toString() 方法。</li></ul><pre><code class="highlight javascript"><span class="function"><span class="keyword">function</span> <span class="title">StringBuffer</span>(<span class="params">str</span>)</span>{    <span class="keyword">var</span> string = str ? [str] : [];    <span class="keyword">if</span>(!StringBuffer.prototype.append){        StringBuffer.prototype.append=<span class="function"><span class="keyword">function</span>(<span class="params">str</span>)</span>{            string.push(str);        }        StringBuffer.prototype.toString=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{            <span class="keyword">return</span> string.join(<span class="string">""</span>);        }    }}</code></pre><p><code>append()</code> 是自定义方法，接收一个参数，并将该参数添加到内部数组中，<code>toString()</code>已经在继承Object原型存在，需要重写，该方法调用数组的<code>join()</code>方法，返回数组拼接后字符串。</p><p>使用demo：</p><pre><code class="highlight javascript"><span class="keyword">var</span> sb=<span class="keyword">new</span> StringBuffer(<span class="string">"failte"</span>);<span class="built_in">console</span>.log(sb);<span class="built_in">console</span>.log(sb.toString());sb.append(<span class="string">"'s"</span>);<span class="built_in">console</span>.log(sb.toString());</code></pre><h4 id="性能对比："><a href="#性能对比：" class="headerlink" title="性能对比："></a>性能对比：</h4><pre><code class="highlight javascript"><span class="function"><span class="keyword">function</span> <span class="title">StringBuffer</span>(<span class="params">str</span>)</span>{    <span class="keyword">var</span> string = str ? [str] : [];    <span class="keyword">if</span>(!StringBuffer.prototype.append) {        StringBuffer.prototype.append = <span class="function"><span class="keyword">function</span> (<span class="params">str</span>) </span>{            string.push(str);        }        StringBuffer.prototype.toString = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{            <span class="keyword">return</span> string.join(<span class="string">""</span>);        }    }}<span class="comment">// 传统拼接</span><span class="keyword">var</span> str1 = <span class="string">""</span>;<span class="keyword">var</span> d1 = <span class="built_in">Date</span>.now(); <span class="comment">// 时刻1</span><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i&lt;<span class="number">100000</span>; i++){    str1 += i;}<span class="keyword">var</span> t1 = <span class="built_in">Date</span>.now() - d1; <span class="comment">// 时间间隔1</span><span class="comment">// StringBuffer拼接</span><span class="keyword">var</span> str2 = <span class="keyword">new</span> StringBuffer(<span class="string">""</span>);<span class="keyword">var</span> d2 = <span class="built_in">Date</span>.now(); <span class="comment">// 时刻2</span><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i&lt;<span class="number">100000</span>; i++){    str2.append(i);}<span class="keyword">var</span> t2 = <span class="built_in">Date</span>.now()-d2; <span class="comment">// 时间间隔2</span><span class="built_in">console</span>.log(<span class="string">"t1: "</span>, t1, <span class="string">"t2: "</span>, t2);</code></pre><p><strong>测试结果</strong>：使用两种方法测试拼接100000个字符串，三次结果如下：</p><ul><li>Round 1：String拼接：26msStringBuffer拼接：5ms</li><li>Round 2：String拼接：24msStringBuffer拼接：5ms</li><li>Round 3：String拼接：28msStringBuffer拼接：5ms</li></ul><p>测试完成。通过比较，可以很明显的发现，StringBuffer拼接的速度比String拼接速度快5倍。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> String </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript之函数尾调用与函数尾递归</title>
      <link href="2020/09/21/JavaScript/JavaScripitFunctionTail-Call/"/>
      <url>2020/09/21/JavaScript/JavaScripitFunctionTail-Call/</url>
      
        <content type="html"><![CDATA[<h1 id="函数尾调用与函数尾递归"><a href="#函数尾调用与函数尾递归" class="headerlink" title="函数尾调用与函数尾递归"></a>函数尾调用与函数尾递归</h1><p>偶然重新学习ES6，发现原来在函数方面还有添加尾调用这个特性，尾调用可以减少一次函数调用帧的生成，而众所周知函数递归存在一个内存消耗的问题，如果把尾调用加入到递归中会怎么样呢……</p><h2 id="尾调用"><a href="#尾调用" class="headerlink" title="尾调用"></a>尾调用</h2><p>函数调用会在内存形成一个调用帧，保存调用位置和内部变量等信息。</p><p>一个函数内存在其他函数调用，其他函数就会在这个函数上形成调用帧，所有的调用帧形成了一个调用栈。</p><p>为尾调用是指在函数的最后一步操作时，返回另一个函数的调用，这个时候，由于不会用到调用的位置和内部变量等信息，不需要保留外层函数的调用帧。</p><p>尾调用：</p><pre><code class="highlight js"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>) </span>{    <span class="keyword">return</span> B() <span class="comment">// 尾调用</span>}<span class="function"><span class="keyword">function</span> <span class="title">B</span>(<span class="params"></span>) </span>{    <span class="keyword">return</span> C() + <span class="number">1</span>; <span class="comment">// 最后一步操作不是函数调用</span>}<span class="function"><span class="keyword">function</span> <span class="title">C</span>(<span class="params"></span>)</span>{    <span class="keyword">var</span> val = D()    <span class="keyword">return</span> val; <span class="comment">// 最后一步操作不是函数调用</span>}<span class="function"><span class="keyword">function</span> <span class="title">D</span>(<span class="params"></span>)</span>{    E() <span class="comment">// 最后一步操作不是函数调用</span>}<span class="function"><span class="keyword">function</span> <span class="title">E</span>(<span class="params"></span>)</span>{    <span class="built_in">console</span>.log(<span class="string">'只有A是尾调用'</span>) <span class="comment">// 最后一步操作不是函数调用</span>}</code></pre><h2 id="尾递归"><a href="#尾递归" class="headerlink" title="尾递归"></a>尾递归</h2><p>函数递归对内存消耗很大，每次递归都会产生一个调用帧，而整个递归下来会产生很多的调用帧，很容易出现栈溢出的问题。</p><p>尾调用是可以有效减少执行栈的，将尾调用和递归结合，有可能将复杂度为O(n)的计算变成O(1)。</p><p>非尾调用</p><pre><code class="highlight js"><span class="function"><span class="keyword">function</span> <span class="title">Fibonacci</span> (<span class="params">n</span>) </span>{    <span class="keyword">if</span> ( n &lt;= <span class="number">1</span> ) {<span class="keyword">return</span> <span class="number">1</span>};    <span class="keyword">return</span> Fibonacci(n - <span class="number">1</span>) + Fibonacci(n - <span class="number">2</span>);}Fibonacci(<span class="number">10</span>) <span class="comment">// 89</span>Fibonacci(<span class="number">100</span>) <span class="comment">// 超时</span>Fibonacci(<span class="number">500</span>) <span class="comment">// 超时</span></code></pre><p>尾调用</p><pre><code class="highlight js"><span class="function"><span class="keyword">function</span> <span class="title">Fibonacci2</span> (<span class="params">n , ac1 = <span class="number">1</span> , ac2 = <span class="number">1</span></span>) </span>{    <span class="keyword">if</span>( n &lt;= <span class="number">1</span> ) {<span class="keyword">return</span> ac2};    <span class="keyword">return</span> Fibonacci2 (n - <span class="number">1</span>, ac2, ac1 + ac2);}Fibonacci2(<span class="number">100</span>) <span class="comment">// 573147844013817200000</span>Fibonacci2(<span class="number">1000</span>) <span class="comment">// 7.0330367711422765e+208</span>Fibonacci2(<span class="number">10000</span>) <span class="comment">// Infinity</span></code></pre><p>建议在ES6中对递归进行尾调用优化。</p><h2 id="兼容"><a href="#兼容" class="headerlink" title="兼容"></a>兼容</h2><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Function </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript闭包详解</title>
      <link href="2020/09/14/JavaScript/JavaScriptClosure/"/>
      <url>2020/09/14/JavaScript/JavaScriptClosure/</url>
      
        <content type="html"><![CDATA[<h4 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h4><p>首先来了解一下Javascript中变量的作用域，除了常见的普通变量外，<strong>对象</strong>和<strong>函数</strong>也是一种变量。变量分为局部变量和全局变量。</p><h5 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h5><p>局部变量就是指在<strong>函数内部</strong>定义的变量，作用域是函数内部网，此变量通常只能在函数内部访问，和外界是区分开的，所以变量名即使和外部的<strong>重复</strong>，也是两个独立的变量，不会相互影响。局部变量在函数执行是创建，执行完后<strong>销毁</strong>。</p><h5 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h5><p>全局变量就是函数外部定义的变量，作用域是网页中的所有脚本和函数，它们都能够访问，全局变量是页面加载时创建，页面关闭后销毁。</p><p>综合举例：</p><pre><code class="highlight js"><span class="keyword">var</span> a = <span class="number">0</span>;<span class="function"><span class="keyword">function</span> <span class="title">fun1</span>(<span class="params"></span>) </span>{<span class="keyword">var</span> a = <span class="number">1</span>;b = <span class="number">2</span>;}</code></pre><p>这里的 <code>var a = 0;</code> 就是全局变量，<code>var a = 1;</code> 是局部变量，虽然名字重复，但这里是两个独立变量，但是还是不建议出现重复，提高代码可读性；<code>b = 2;</code> 也是<strong>全局变量</strong>，因为规定函数内部申明的变量，如果不加 <code>var</code>，即会被认为是全局变量，尤其这点需要小心。</p><h4 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h4><p>先通俗的总结一下，闭包就是一个可以访问其他函数内部变量的<strong>函数</strong>，即一个定义在函数内部的函数，也叫<strong>内嵌函数</strong>。</p><p>其次，是闭包的作用，因为通常情况函数内部变量是无法在外部访问的，即全局变量也局部变量的区别，而闭包，就实现了能在外部访问某函数内部变量的功能，让这些变量值始终保存在<strong>内存</strong>中。</p><p>然后，来讲一下如何实现闭包。有以下代码：</p><pre><code class="highlight js"><span class="function"><span class="keyword">function</span> <span class="title">fun1</span>(<span class="params"></span>) </span>{<span class="keyword">var</span> a = <span class="number">1</span>;           <span class="comment">//定义一个局部变量</span><span class="function"><span class="keyword">function</span> <span class="title">fun2</span>(<span class="params"></span>) </span>{    <span class="comment">//这里的 fun2() 就是闭包</span>alert(a);    <span class="comment">//fun2() 是 fun1()的子函数，所以能访问之前定义的局部变量，这个是关键</span>}<span class="keyword">return</span> fun2;         <span class="comment">//然后通过这里，把之前得到的局部变量成功返回到外部去</span>}fun1();                      <span class="comment">//正常执行函数</span><span class="keyword">var</span> result = fun1();         <span class="comment">//将内部变量传递出去，传给变量 result</span>result();                    <span class="comment">//执行这个函数实现对局部变量的访问</span></code></pre><p>当然形式不止这一种，万变不离其宗，最后实现的功能是一样的，例如下面的方法也是可行的：</p><pre><code class="highlight js"><span class="function"><span class="keyword">function</span> <span class="title">fun1</span>(<span class="params"></span>) </span>{<span class="keyword">var</span> a = <span class="number">1</span>;<span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{alert(a);};}fun1();<span class="keyword">var</span> result = fun1();result();</code></pre><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>也许在很多文章中都能看到这句话“避免滥用闭包”，的确，由于闭包会使一些变量一直保存在内存中，所以如果大量使用的话就会消耗大量内存，影响网页性能。</p><p>同时，由于闭包的特性，还会在外部改变函数的内部变量值，有时候这是很危险的，举个例子：</p><pre><code class="highlight js"><span class="function"><span class="keyword">function</span> <span class="title">fun1</span>(<span class="params"></span>) </span>{<span class="keyword">var</span> a = <span class="number">1</span>;<span class="function"><span class="keyword">function</span> <span class="title">fun2</span>(<span class="params"></span>) </span>{a++;}alert(a);<span class="keyword">return</span> fun2;}fun1();                   <span class="comment">//函数正常执行，输出 1</span><span class="keyword">var</span> change = fun1();change();                 <span class="comment">//在外部执行这个函数后，函数内部变量 a 的值就被改变了，输出 2</span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Closure </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript之正则</title>
      <link href="2020/09/10/JavaScript/JavaScriptRegExp/"/>
      <url>2020/09/10/JavaScript/JavaScriptRegExp/</url>
      
        <content type="html"><![CDATA[<h2 id="JavaScript正则"><a href="#JavaScript正则" class="headerlink" title="JavaScript正则 "></a>JavaScript正则 <span id="home"></span></h2><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><strong><a href="#1">构造 </a></strong></li><li><strong><a href="#2">查找模式 </a></strong><ul><li><strong><a href="#2.1">方括号 </a></strong></li><li><strong><a href="#2.2">元字符 </a></strong></li><li><strong><a href="#2.3">量词 </a></strong></li><li><strong><a href="#2.4">RegExp 对象方法 </a></strong></li><li><strong><a href="#2.5">支持正则表达式的 String 对象的方法 </a></strong></li><li><strong><a href="#2.6">方括号 </a></strong></li></ul></li><li><strong><a href="#3">常用正则式 </a></strong><ul><li><strong><a href="#3.1">验证姓名 </a></strong></li><li><strong><a href="#3.2">验证密码 </a></strong></li><li><strong><a href="#3.3">验证 Email </a></strong></li><li><strong><a href="#3.4">验证身份证 </a></strong></li><li><strong><a href="#3.5">验证手机号 </a></strong></li></ul></li><li><strong><a href="#4">常见的坑 </a></strong></li></ul><hr><h2 id="构造正则表达式"><a href="#构造正则表达式" class="headerlink" title="构造正则表达式 "></a>构造正则表达式 <span id="1"></span></h2><p>1、使用new创建对象</p><pre><code>new RegExp(pattern,modifiers)</code></pre><p>2、pattern模式</p><pre><code>/pattern/modifierspattern（模式） 描述了表达式的模式modifiers(修饰符) 用于指定全局匹配(g)、区分大小写的匹配(i)和多行匹配(m)</code></pre><hr><h2 id="正则查找模式"><a href="#正则查找模式" class="headerlink" title="正则查找模式 "></a>正则查找模式 <span id="2"></span></h2><p>1、方括号：用于查找某个范围内的字符 <span id="2.1"></span></p><pre><code>[abc]    查找方括号之间的任何字符。[^abc]    查找任何不在方括号之间的字符。[0-9]    查找任何从 0 至 9 的数字。[a-z]    查找任何从小写 a 到小写 z 的字符。[A-Z]    查找任何从大写 A 到大写 Z 的字符。[A-z]    查找任何从大写 A 到小写 z 的字符。[adgk]    查找给定集合内的任何字符。[^adgk]    查找给定集合外的任何字符。(red|blue|green)    查找任何指定的选项。</code></pre><p>2、元字符：拥有特殊含义的字符 <span id="2.2"></span></p><pre><code>.    查找单个字符，除了换行和行结束符。\w    查找单词字符。\W    查找非单词字符。\d    查找数字。\D    查找非数字字符。\s    查找空白字符。\S    查找非空白字符。\b    匹配单词边界。\B    匹配非单词边界。\0    查找 NUL 字符。\n    查找换行符。\f    查找换页符。\r    查找回车符。\t    查找制表符。\v    查找垂直制表符。\xxx    查找以八进制数 xxx 规定的字符。\xdd    查找以十六进制数 dd 规定的字符。\uxxxx    查找以十六进制数 xxxx 规定的 Unicode 字符。</code></pre><p>3、量词 <span id="2.3"></span></p><pre><code>n+    匹配任何包含至少一个 n 的字符串。n*    匹配任何包含零个或多个 n 的字符串。n?    匹配任何包含零个或一个 n 的字符串。n{X}    匹配包含 X 个 n 的序列的字符串。n{X,Y}    匹配包含 X 至 Y 个 n 的序列的字符串。n{X,}    匹配包含至少 X 个 n 的序列的字符串。n$    匹配任何结尾为 n 的字符串。^n    匹配任何开头为 n 的字符串。?=n    匹配任何其后紧接指定字符串 n 的字符串。?!n    匹配任何其后没有紧接指定字符串 n 的字符串。</code></pre><p>4、RegExp 对象方法 <span id="2.4"></span></p><pre><code>compile    编译正则表达式。exec    检索字符串中指定的值。返回找到的值，并确定其位置。test    检索字符串中指定的值。返回 true 或 false。</code></pre><p>5、支持正则表达式的 String 对象的方法 <span id="2.5"></span></p><pre><code>search    检索与正则表达式相匹配的值。match    找到一个或多个正则表达式的匹配。replace    替换与正则表达式匹配的子串。split    把字符串分割为字符串数组。</code></pre><hr><h2 id="常用的正则式"><a href="#常用的正则式" class="headerlink" title="常用的正则式 "></a>常用的正则式 <span id="3"></span></h2><p>1、验证姓名 <span id="3.1"></span></p><p>2到9位中文昵称</p><pre><code>^[\u4e00-\u9fa5]{2,9}$</code></pre><p>2、验证密码 <span id="3.2"></span></p><p>只能是字母、数字和下划线，长度不限制：</p><pre><code>^\w+$</code></pre><p>允许小写字母a-z、大写字母A-Z、数字0-9、下划线_、 连接符-，且长度在6-18位数：</p><pre><code>/^[a-zA-Z0-9_-]{6,18}$/</code></pre><p>必须包含数字+小写字母+大写字母的密码，且长度在8-10位之间：</p><pre><code>^(?=.*\d)(?=.*[a-z])(?=.*[A-Z]).{8,10}$</code></pre><p>3、验证 Email <span id="3.3"></span></p><p>允许有一个字符符合[A-Za-z0-9_]之后可以为[A-Za-z0-9_-+.] + @ + 允许有一个字符符合 [A-Za-z0-9_] 之后可以为 [A-Za-z0-9_-.] + . + 允许有一个字符符合 [A-Za-z0-9_] 之后可以有 [A-Za-z0-9_-.] 的邮箱：</p><pre><code>^\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*$</code></pre><p>4、验证身份证 <span id="3.4"></span></p><p>18位身份证号，尾数是数字或者字母X：</p><pre><code>^(\d{6})(\d{4})(\d{2})(\d{2})(\d{3})([0-9]|X)$</code></pre><p>15或者18位身份证号，尾数可以是数字及X或者x：</p><pre><code>(^\d{15}$)|(^\d{18}$)|(^\d{17}(\d|X|x)$)</code></pre><p>5、验证手机号 <span id="3.5"></span></p><p>以 1 开头，第二位数是 3/4/5/7/8 的 11 位手机号码：</p><pre><code>^1[3,4,5,7,8,9]\d{9}$</code></pre><p>移动号码：</p><pre><code>^134[0-8]\d{7}$|^(?:13[5-9]|147|15[0-27-9]|178|1703|1705|1706|18[2-478])\d{7,8}$</code></pre><p>电信号码：</p><pre><code>^(?:133|153|1700|1701|1702|177|173|18[019])\d{7,8}$</code></pre><p>联通号码：    ^(?:13[0-2]|145|15[56]|176|1704|1707|1708|1709|171|18[56])&lt;d&gt;7,8</p><hr><h2 id="常见的坑"><a href="#常见的坑" class="headerlink" title="常见的坑 "></a>常见的坑 <span id="4"></span></h2><p>在[A-Z]与[a-z]中存在其他字符，[A-z]的准确表述为</p><pre><code>[A-Z][a-z]</code></pre><p><a href="https://www.w3cschool.cn/javascript/javascript-expression.html" target="_blank" rel="noopener">w3c学习链接</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RegExp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript逻辑运算符“&amp;&amp;”和“||”短路原则的应用</title>
      <link href="2020/08/30/JavaScript/JavaScriptLogicCompute/"/>
      <url>2020/08/30/JavaScript/JavaScriptLogicCompute/</url>
      
        <content type="html"><![CDATA[<h4 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h4><p>在Javascript中，有逻辑运算符 <code>与 &amp;&amp;</code>, <code>或 ||</code>, <code>非 !</code>，常在条件句或循环中进行逻辑判断。</p><p>例如：</p><pre><code class="highlight js"><span class="keyword">var</span> a = <span class="number">1</span>, b = <span class="number">1</span>, c = <span class="number">2</span>;<span class="keyword">if</span> (a = b &amp;&amp; (b = c || a != c)){alert(<span class="string">"true"</span>);} <span class="keyword">else</span> {alert(<span class="string">"false"</span>);}</code></pre><p>括号中表达式值为<strong>真</strong>，最后提示“true”。</p><h4 id="短路原则"><a href="#短路原则" class="headerlink" title="短路原则"></a>短路原则</h4><p>在逻辑运算中，这是一个通用的原则，这是由于表达式从左到右执行的特性，为了减少运算量而给运算器规定的操作。主要针对 <code>&amp;&amp;</code> 和 <code>||</code> 两种运算。</p><ul><li><p><code>&amp;&amp;</code> 的判断是<strong>同真为真，一假为假</strong>，则运算如果左边的表达式值为 <code>false</code>，那么就不会再执行右边的表达式了，如果左表达式为 <code>true</code>，就会继续执行右表达式；</p></li><li><p><code>||</code> 的判断是<strong>一真为真，同假为假</strong>，则运算如果坐表达式值为 <code>true</code>，那么就不用执行右边的表达式了，如果左表达式为 <code>false</code>，就会继续执行右表达式；</p></li></ul><p>举例说明：</p><pre><code class="highlight js">(<span class="number">1</span> == <span class="number">1</span>) &amp;&amp; alert(<span class="string">"msg1"</span>);(<span class="number">1</span> != <span class="number">1</span>) &amp;&amp; alert(<span class="string">"msg2"</span>);(<span class="number">1</span> == <span class="number">1</span>) || alert(<span class="string">"msg3"</span>);(<span class="number">1</span> != <span class="number">1</span>) || alert(<span class="string">"msg4"</span>);</code></pre><p>结果是提示<strong>“msg1”</strong>和<strong>“msg4”</strong>。原理如上述。</p><p>因此，如果有以下表达式：</p><pre><code class="highlight js"><span class="keyword">var</span> a = <span class="number">9</span>;<span class="keyword">if</span> (a &gt; <span class="number">0</span>){alert(<span class="string">"true"</span>);} <span class="keyword">else</span>{alert(<span class="string">"false"</span>);}</code></pre><p>也许你会使用<strong>三目运算</strong>简化成这样：</p><pre><code class="highlight js"><span class="keyword">var</span> a = <span class="number">9</span>;(a &gt; <span class="number">0</span>) ? alert(<span class="string">"true"</span>) : alert(<span class="string">"false"</span>);</code></pre><p>其实也可以这样写：</p><pre><code class="highlight js"><span class="keyword">var</span> a = <span class="number">9</span>;(a &gt; <span class="number">0</span>) &amp;&amp; alert(<span class="string">"true"</span>);(a &gt; <span class="number">0</span>) || alert(<span class="string">"false"</span>);</code></pre><h4 id="Javascript中的应用"><a href="#Javascript中的应用" class="headerlink" title="Javascript中的应用"></a>Javascript中的应用</h4><p>在javascript中，只有<code>对象(Object)</code>和布尔值<code>true</code>为真，其它例如 <code>undefined</code>, <code>NaN</code>, <code>false</code> 等，值为 <code>false</code>。为被定义的对象或未赋值变量也是 <code>false</code>，因为其值都是 <code>undefined</code>，这里就可以应用于检查某变量是否<strong>已定义</strong>。</p><p>举例说明：</p><pre><code class="highlight js"><span class="keyword">var</span> a = <span class="number">1</span>;<span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();<span class="keyword">var</span> b;a &amp;&amp; alert(<span class="string">"defined"</span>);       <span class="comment">//已定义a，提示“defined”</span>o &amp;&amp; alert(<span class="string">"defined"</span>);       <span class="comment">//已定义对象o，提示“defined”</span><span class="built_in">Object</span> &amp;&amp; alert(<span class="string">"defined"</span>);  <span class="comment">//Object是一个已知的全局对象，提示“defined”</span>b || alert(<span class="string">"not defined"</span>);   <span class="comment">//b未赋值，提示“not defined”</span>p || alert(<span class="string">"not defined"</span>);   <span class="comment">//未定义p，提示“not defined”</span></code></pre><p>除了这个也能衍生出其它相同原理的应用，类似于判断赋值 <code>var  a = (b &gt; 0) &amp;&amp; '9'</code> 或判断定义变量 <code>var abc = abc || ""</code> 等。</p><p>js中使用这种方法可以减少代码量，提示性能，但同时也降低了代码<strong>可读性</strong>，比如个人觉得还是看以下代码比较舒适：</p><pre><code class="highlight js"><span class="keyword">var</span> a = <span class="number">1</span>;<span class="keyword">if</span> (a &gt; <span class="number">1</span>){alert(<span class="string">"true"</span>);}</code></pre><p>方法的选择就要视情况而权衡了。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Operator </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript设计模式之发布&amp;订阅模式</title>
      <link href="2020/08/27/JavaScript/JavaScriptObseverMode/"/>
      <url>2020/08/27/JavaScript/JavaScriptObseverMode/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="发布-amp-订阅模式"><a href="#发布-amp-订阅模式" class="headerlink" title="发布&amp;订阅模式"></a>发布&amp;订阅模式</h1><p>面试官：你能说说发布&amp;订阅模式和观察者模式有什么区别吗？懵逼了吗？来，上车~</p><h2 id="发布-amp-订阅模式满足的条件"><a href="#发布-amp-订阅模式满足的条件" class="headerlink" title="发布&amp;订阅模式满足的条件"></a>发布&amp;订阅模式满足的条件</h2><p>1、存储多个事件</p><p>2、每个事件可以订阅多个函数</p><p>3、提供订阅、取消订阅、触发三种方法</p><h2 id="on-事件绑定"><a href="#on-事件绑定" class="headerlink" title="$on 事件绑定"></a>$on 事件绑定</h2><p>1、语法：<code>$on(eventName, callback)</code></p><p>2、分析：</p><ul><li><p>一个事件对应多个事件函数</p></li><li><p>分析绑定的这个事件名称在事件仓库中是否存在 如果存在则直接将事件函数添加到数组中去</p></li><li><p>如果不存在则创建一个数组然后将事件函数添加到数组中去</p></li></ul><h2 id="emit-事件触发"><a href="#emit-事件触发" class="headerlink" title="$emit 事件触发"></a>$emit 事件触发</h2><p>1、语法：<code>$emit(eventName, params)</code></p><p>2、分析：</p><ul><li><p>判断当前事件名称是否存在</p></li><li><p>如果存在，则遍历数组中所有的函数，将参数传递到数组的函数中，并执行这些函数</p></li></ul><h2 id="off-事件解绑"><a href="#off-事件解绑" class="headerlink" title="$off  事件解绑"></a>$off  事件解绑</h2><p>1、语法：<code>$off(eventName, callback)</code></p><p>2、分析：</p><ul><li><p>判断当前事件名称是否存在</p></li><li><p>如果存在，则再判断第二个参数是否存在</p></li><li><p>如果第二个参数也存在，则解绑对应的函数</p></li><li><p>如果第二个参数不存在则解绑全部</p></li></ul><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>subscribe.js</p><pre><code class="highlight js"><span class="keyword">const</span> eventList = {};<span class="keyword">const</span> $on = <span class="function">(<span class="params">eventName,callback</span>) =&gt;</span> {    <span class="keyword">if</span>(!eventList[eventName]) {        eventList[eventName] = [];    }    eventList[eventName].push(callback);}<span class="keyword">const</span> $emit = <span class="function">(<span class="params">eventName,params</span>) =&gt;</span> {    <span class="keyword">if</span>(eventList[eventName]) {        eventList[eventName].forEach(<span class="function">(<span class="params">cb</span>) =&gt;</span> {            cb(params);        })    }}<span class="keyword">const</span> $off = <span class="function">(<span class="params">eventName,callback</span>) =&gt;</span> {    <span class="keyword">if</span>(eventList[eventName]) {        <span class="keyword">if</span>(callback) {            <span class="keyword">let</span> index = eventList[eventName].indexOf(callback);            eventList[eventName].splice(index,<span class="number">1</span>);        } <span class="keyword">else</span> {            eventList[eventName].length = <span class="number">0</span>;        }    }}<span class="keyword">export</span> <span class="keyword">default</span> {    $on,    $emit,    $off}</code></pre><h2 id="观察者模式和发布订阅模式"><a href="#观察者模式和发布订阅模式" class="headerlink" title="观察者模式和发布订阅模式"></a>观察者模式和发布订阅模式</h2><p>1、观察者模式</p><p>观察者模式主要参与者为主题Subject，观察者Observer。</p><p>Subject和Observer具有松耦合的关系。</p><p>在Subject发生变化时，通知Observer。</p><p>2、订阅模式</p><p>订阅模式的主要参与者为发布者Publisher、订阅者Subscriber、调度中心Broker。</p><p>Publisher和Subscriber没有直接关系。两者间需要通过Broker进行沟通。</p><p>Publisher发布时，会推送到Broker，调度中心负责管理订阅，会将Publisher发布的消息通知给Subscriber。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Patterns </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript核心：两链一包</title>
      <link href="2020/08/23/JavaScript/JavaScriptPrototype&amp;Closure/"/>
      <url>2020/08/23/JavaScript/JavaScriptPrototype&amp;Closure/</url>
      
        <content type="html"><![CDATA[<h1 id="JavaScript核心：两链一包"><a href="#JavaScript核心：两链一包" class="headerlink" title="JavaScript核心：两链一包"></a>JavaScript核心：两链一包</h1><h2 id="作用域与闭包"><a href="#作用域与闭包" class="headerlink" title="作用域与闭包"></a>作用域与闭包</h2><h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p>1、变量提升</p><ul><li>浏览器解析器在解析js时，预解析变量并将变量名提升到作用域的行为</li><li>函数与变量同时声明为一个字符时，预解析时函数有高优先级</li></ul><p>2、全局变量</p><ul><li>在全局声明的变量，作用域在全局</li><li>函数内有未使用声明符声明的变量时，这个变量会被浏览器转换为全局变量</li></ul><p>3、局部变量</p><ul><li>在函数内声明的变量，作用域在函数内</li><li>函数的传参作用域在函数内，传参与全局变量不是同一个变量</li></ul><p>3、作用域链</p><ul><li>执行函数时，总是先从函数内部找局部变量</li><li>若没有，则会依次向上级作用域寻找变量</li></ul><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p><strong>闭包就是访问函数内部私有属性或私有函数的公有方法</strong></p><ul><li>1、函数拥有局部作用域，无法在外部访问局部的属性或方法</li></ul><pre><code class="highlight javascript"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>{    <span class="keyword">var</span> a=<span class="string">"a"</span>;}<span class="built_in">console</span>.log(a);<span class="comment">//undefined</span></code></pre><ul><li>2、函数可以设置公共属性或方法，是的外部能够进行访问</li></ul><pre><code class="highlight javascript"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>{    <span class="keyword">this</span>.a=<span class="string">"a"</span>}<span class="built_in">console</span>.log(<span class="keyword">new</span> test().a);<span class="comment">//a;</span></code></pre><ul><li>3、通过使用公共方法操作私有属性或方法，这种方式就称之为闭包</li></ul><pre><code class="highlight javascript"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>{    <span class="keyword">var</span> a=<span class="string">"a"</span>;    <span class="keyword">this</span>.getA=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{ <span class="keyword">return</span> a; }    <span class="keyword">this</span>.setA=<span class="function"><span class="keyword">function</span>(<span class="params">a</span>)</span>{ <span class="keyword">this</span>.a=a; }}</code></pre><h2 id="原型和原型链"><a href="#原型和原型链" class="headerlink" title="原型和原型链"></a>原型和原型链</h2><h3 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h3><p>1、构造函数：<code>construct</code></p><p>用来生成对象的函数。最常见的有<code>Object</code>、<code>Function</code>、<code>Array</code>、<code>String</code>、<code>Number</code>等。</p><p>2、<code>new</code>的作用</p><p>(1)创建一个对象(2)改变构造函数的this指向为实例对象(3)在实例对象中产生<code>__proto__</code>属性，指向构造函数的<code>ptototype</code></p><p>3、原型</p><p>(1)定义函数时，会生成一个<code>prototype</code>的属性，指向当前函数，这个属性称之为函数的原型(2)构造函数<code>new</code>时，会生成一个对象，并且会生成<code>__proto__</code>属性，指向构造函数的<code>prototype</code>，这个属性称之为这个对象的原型(3)构造函数作为对象时存在<code>__proto__</code>，指向<code>Function</code>原型(4)所有的原型对象的<code>__proto__</code>最后都会指向<code>Object</code>原型，而<code>Object</code>原型的<code>__proto__</code>是null。(5)任何原型的<code>constructor</code>指向构造函数，而构造函数的<code>prototype</code>又指向原型，如此，会形成死循环（类似先有鸡还是先有蛋）</p><h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3><p>根据原型的规则画出的关系链称为原型链。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Prototype </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LESS从入门到精通</title>
      <link href="2020/08/17/Webpack/CSSLESS/"/>
      <url>2020/08/17/Webpack/CSSLESS/</url>
      
        <content type="html"><![CDATA[<h1 id="LESS-从入门到精通"><a href="#LESS-从入门到精通" class="headerlink" title="LESS 从入门到精通"></a>LESS 从入门到精通</h1><h2 id="一、LESS-是什么"><a href="#一、LESS-是什么" class="headerlink" title="一、LESS 是什么"></a>一、LESS 是什么</h2><p><strong>LESS</strong> 是 <strong>CSS 预处理语言</strong>，是 <strong>CSS</strong> 的扩展。</p><p>然后说说比较流行的几款预编译器：<strong>SASS/SCSS</strong>、<strong>LESS</strong>、<strong>Stylus</strong>。</p><p><strong>SASS</strong> 学习网站：</p><ul><li><a href="https://www.sass.hk/" target="_blank" rel="noopener">https://www.sass.hk/</a></li><li><a href="https://www.w3cschool.cn/sass/" target="_blank" rel="noopener">https://www.w3cschool.cn/sass/</a></li><li><a href="https://github.com/sass/sass" target="_blank" rel="noopener">https://github.com/sass/sass</a></li></ul><p><strong>LESS</strong> 学习网站：</p><ul><li><a href="http://lesscss.cn/" target="_blank" rel="noopener">http://lesscss.cn/</a></li><li><a href="https://less.bootcss.com/" target="_blank" rel="noopener">https://less.bootcss.com/</a></li><li><a href="https://www.w3cschool.cn/less/" target="_blank" rel="noopener">https://www.w3cschool.cn/less/</a></li><li><a href="https://github.com/less/less.js" target="_blank" rel="noopener">https://github.com/less/less.js</a></li></ul><p><strong>Stylus</strong> 学习网站：</p><ul><li><a href="https://stylus.bootcss.com/" target="_blank" rel="noopener">https://stylus.bootcss.com/</a></li><li><a href="https://github.com/stylus/stylus" target="_blank" rel="noopener">https://github.com/stylus/stylus</a></li></ul><h2 id="二、为什么用-LESS"><a href="#二、为什么用-LESS" class="headerlink" title="二、为什么用 LESS"></a>二、为什么用 LESS</h2><p>SASS/SCSS 和 Stylus 都很强，但是我还是选择了 LESS，个人喜欢 NodeJS，然后 stylus 空格我又不喜欢，就用了 LESS，现在用的也习惯了，下面就给大家介绍一下 LESS 的一些用法吧。</p><p>LESS——像写 javascript 一样书写 css</p><p>特点：</p><ul><li>1、写样式更简单：嵌套</li><li>2、使用方便：变量、运算、函数</li><li>3、学习成本低：语法</li></ul><h2 id="三、怎么用-LESS"><a href="#三、怎么用-LESS" class="headerlink" title="三、怎么用 LESS"></a>三、怎么用 LESS</h2><h3 id="1、安装使用"><a href="#1、安装使用" class="headerlink" title="1、安装使用"></a>1、安装使用</h3><h4 id="1-浏览器中使用"><a href="#1-浏览器中使用" class="headerlink" title="(1)浏览器中使用"></a>(1)浏览器中使用</h4><h5 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h5><pre><code class="highlight html"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet/less"</span> <span class="attr">type</span>=<span class="string">"text/css"</span> <span class="attr">href</span>=<span class="string">"index.less"</span> /&gt;</span><span class="comment">&lt;!-- 必须加上/less --&gt;</span><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"less-1.3.3.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span><span class="comment">&lt;!-- js必须在less后引用 --&gt;</span></code></pre><p>通过以上配置，在访问页面时，js 会自动编译 less 为 css</p><h5 id="CDN："><a href="#CDN：" class="headerlink" title="CDN："></a>CDN：</h5><p><code>https://cdnjs.cloudflare.com/ajax/libs/less.js/3.9.0/less.min.js</code></p><p><code>https://cdn.bootcss.com/less.js/3.9.0/less.js</code></p><h5 id="观察模式"><a href="#观察模式" class="headerlink" title="观察模式"></a>观察模式</h5><p>在每次保存文件后，调试时，总要进行手动刷新，于是有了观察模式</p><p><strong>基本设置</strong></p><pre><code class="highlight html"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet/less"</span> <span class="attr">href</span>=<span class="string">"index.less"</span> /&gt;</span><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="actionscript">  less = { env: <span class="string">"development"</span> };</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span>//声明开发模式<span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"less-1.3.3.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span><span class="tag">&lt;<span class="name">script</span>&gt;</span>  less.watch();<span class="tag">&lt;/<span class="name">script</span>&gt;</span>//调用观察模式</code></pre><p>调用了观察模式后，就可以实现在每次保存时自动编译观察模式的原理是每隔一段时间进行编译</p><p><strong>扩展配置</strong></p><p>在基础设置的后面添加 script 标签，内容如下</p><pre><code class="highlight js">less = {  <span class="comment">// 开发环境development，生产模式production</span>  env: <span class="string">"development"</span>,  <span class="comment">// 异步加载</span>  <span class="keyword">async</span>: <span class="literal">false</span>,  <span class="comment">// 在页面下异步读取导入</span>  fileAsync: <span class="literal">false</span>,  <span class="comment">// 观察模式间隔</span>  poll: <span class="number">1000</span>,  <span class="comment">// 使用函数</span>  functions: {},  <span class="comment">// 行信息输出comment、mediaQuery、all</span>  dumpLineNumbers: <span class="string">"all"</span>,  <span class="comment">// 是否调整url为相对</span>  relativeUrls: <span class="literal">false</span>,  <span class="comment">// 根路径</span>  rootpath: <span class="string">":/"</span>};</code></pre><h4 id="2-使用-node-编译"><a href="#2-使用-node-编译" class="headerlink" title="(2)使用 node 编译"></a>(2)使用 node 编译</h4><p><strong>使用此方法需要先安装 node</strong></p><p><strong>node 下载链接</strong>：<a href="http://nodejs.cn/download/" target="_blank" rel="noopener">http://nodejs.cn/download/</a></p><p><strong>安装了 node 之后，就可以正式安装 <code>less</code> 了</strong></p><pre><code class="highlight node">npm install -g less</code></pre><p>当 less 文件写好后，就可以使用一下命令进行编译</p><pre><code class="highlight node">lessc index.less index.css</code></pre><h4 id="3-gulp-打包工具"><a href="#3-gulp-打包工具" class="headerlink" title="(3)gulp 打包工具"></a>(3)gulp 打包工具</h4><p>使用此方法需要分别在 <strong>全局</strong> 与 <strong>项目</strong> 安装 gulp</p><pre><code class="highlight node">//全局npm install -g gulp//当前项目npm install --save-dev gulp</code></pre><p>然后在安装 gulp 的插件 <strong>gulp-less</strong></p><pre><code class="highlight node">npm install -save-dev gulp-less</code></pre><p>安装完之后，创建入口文件 <strong>gulpfile.js</strong>，并写入:</p><pre><code class="highlight node">var origin = "./index.less"; //填写你需要转化的less文件的路径var result = "./"; //填写你转化后文件存在的目录路径var gulp = require("gulp");gulp.task("less2css", function() {  gulp    .src(origin)    .pipe(less())    .pipe(result);});</code></pre><p>至此，就可以通过输入 <code>gulp less2css</code> 命令进行编译了但是，每次保存后都要去编译很麻烦，于是，补充以下代码</p><pre><code class="highlight node">gulp.task("lessc", function() {  gulp.watch("origin", ["less2css"]);});</code></pre><p>现在只需要输入 <code>gulp lessc</code> 就可以实现 less 的观察者模式了</p><h3 id="2、语法"><a href="#2、语法" class="headerlink" title="2、语法"></a>2、语法</h3><p>保留 CSS 的基础语法，并进行了扩展</p><pre><code class="highlight less"><span class="keyword">@import</span> <span class="string">"reset.css"</span> <span class="comment">//less在编译时不会变动css文件</span>  <span class="variable">@import</span> <span class="string">"base"</span> <span class="comment">//less导入其他less文件时可以省略文件格式</span>  <span class="variable">@import</span> url(<span class="string">"base.less"</span>);</code></pre><h3 id="3、运算"><a href="#3、运算" class="headerlink" title="3、运算"></a>3、运算</h3><p>在<code>less</code>中，可以在书写属性时直接进行加减乘除</p><p>例子：<code>header</code>插入了一个<code>padding</code></p><pre><code class="highlight less"><span class="variable">@fullWidth:</span> <span class="number">1200px</span>;<span class="selector-class">.header</span> {  <span class="attribute">width</span>: <span class="variable">@fullWidth</span> – <span class="number">20px</span> * <span class="number">2</span>;  <span class="attribute">padding</span>: <span class="number">0px</span> <span class="number">20px</span> * <span class="number">2</span>;}</code></pre><h3 id="4、变量"><a href="#4、变量" class="headerlink" title="4、变量"></a>4、变量</h3><h4 id="1-格式：以-开头"><a href="#1-格式：以-开头" class="headerlink" title="(1)格式：以@开头"></a>(1)格式：以@开头</h4><pre><code class="highlight less"><span class="variable">@headergray:</span> <span class="number">#c0c0c0</span>;<span class="variable">@fullWidth:</span> <span class="number">1200px</span>;<span class="variable">@logoWidth:</span> <span class="number">35%</span>;</code></pre><h4 id="2-字符串插值"><a href="#2-字符串插值" class="headerlink" title="(2)字符串插值"></a>(2)字符串插值</h4><pre><code class="highlight less"><span class="variable">@name:</span> banner;<span class="attribute">background</span>: url(<span class="string">"images/@{name}.png"</span>) no-repeat;</code></pre><p>编译：</p><pre><code class="highlight css">background: url("images/banner.png") no-repeat;</code></pre><h4 id="3-避免编译"><a href="#3-避免编译" class="headerlink" title="(3)避免编译"></a>(3)避免编译</h4><pre><code class="highlight less"><span class="attribute">background</span>: <span class="string">~"red"</span>;</code></pre><p>编译：</p><pre><code class="highlight css"><span class="selector-tag">background</span>: <span class="selector-tag">red</span>;</code></pre><h4 id="4-移动端-rem-布局中的使用"><a href="#4-移动端-rem-布局中的使用" class="headerlink" title="(4)移动端 rem 布局中的使用"></a>(4)移动端 rem 布局中的使用</h4><pre><code class="highlight less"><span class="variable">@fullWidth:</span> <span class="number">750</span>;<span class="variable">@toRem:</span> unit(<span class="variable">@fullWidth</span> / <span class="number">10</span>, rem);<span class="selector-tag">header</span> {  <span class="attribute">height</span>: <span class="number">150</span> / <span class="variable">@toRem</span>;}</code></pre><p>编译：</p><pre><code class="highlight css"><span class="selector-tag">header</span> {  <span class="attribute">height</span>: <span class="number">2rem</span>;}</code></pre><h3 id="5、混合"><a href="#5、混合" class="headerlink" title="5、混合"></a>5、混合</h3><h4 id="1-在一个类中继承另一个类"><a href="#1-在一个类中继承另一个类" class="headerlink" title="(1)在一个类中继承另一个类"></a>(1)在一个类中继承另一个类</h4><pre><code class="highlight less"><span class="selector-class">.class1</span> {  <span class="attribute">color</span>: red;}<span class="selector-class">.class2</span> {  <span class="attribute">background</span>: green;  <span class="selector-class">.class1</span>;}</code></pre><p>编译后：</p><pre><code class="highlight css"><span class="selector-class">.class1</span> {  <span class="attribute">color</span>: red;}<span class="selector-class">.class2</span> {  <span class="attribute">background</span>: green;  <span class="attribute">color</span>: red;}</code></pre><h4 id="2-用-amp-替换当前选择器"><a href="#2-用-amp-替换当前选择器" class="headerlink" title="(2)用&amp;替换当前选择器"></a>(2)用&amp;替换当前选择器</h4><pre><code class="highlight less"><span class="selector-tag">a</span> {  <span class="attribute">color</span>: <span class="number">#000</span>;  <span class="selector-tag">&amp;</span><span class="selector-pseudo">:hover</span> {    <span class="attribute">color</span>: <span class="number">#f00</span>;  }}</code></pre><p>编译后：</p><pre><code class="highlight css"><span class="selector-tag">a</span> {  <span class="attribute">color</span>: <span class="number">#000</span>;}<span class="selector-tag">a</span><span class="selector-pseudo">:hover</span> {  <span class="attribute">color</span>: <span class="number">#f00</span>;}</code></pre><h4 id="3-在父类中嵌套子类"><a href="#3-在父类中嵌套子类" class="headerlink" title="(3)在父类中嵌套子类"></a>(3)在父类中嵌套子类</h4><pre><code class="highlight less"><span class="selector-class">.class1</span> {  <span class="selector-tag">p</span> {    <span class="selector-tag">span</span> {      <span class="selector-tag">a</span> {      }    }    <span class="selector-tag">&amp;</span><span class="selector-pseudo">:hover</span> {    }  }  <span class="selector-tag">div</span> {  }}</code></pre><p>编译后：</p><pre><code class="highlight css"><span class="selector-class">.class1</span>{ }<span class="selector-class">.class1</span> <span class="selector-tag">p</span>{ }<span class="selector-class">.class1</span> <span class="selector-tag">p</span> <span class="selector-tag">span</span>{.class1 p span a{ }<span class="selector-class">.class1</span> <span class="selector-tag">p</span><span class="selector-pseudo">:hover</span>{  }<span class="selector-class">.class1</span> <span class="selector-tag">div</span>{  }</code></pre><h4 id="4-带参混合"><a href="#4-带参混合" class="headerlink" title="(4)带参混合"></a>(4)带参混合</h4><pre><code class="highlight less"><span class="selector-class">.color</span>(<span class="variable">@color</span>=red) {  <span class="attribute">color</span>: <span class="variable">@color</span>;}<span class="selector-class">.class1</span> {  <span class="selector-class">.color</span>(<span class="number">#0f0</span>);}<span class="selector-class">.class2</span> {  <span class="selector-class">.color</span>();}</code></pre><p>编译后：</p><pre><code class="highlight css"><span class="selector-class">.class1</span> {  <span class="attribute">color</span>: <span class="number">#0f0</span>;}<span class="selector-class">.class2</span> {  <span class="attribute">color</span>: red;}</code></pre><h4 id="5-块定义"><a href="#5-块定义" class="headerlink" title="(5)块定义"></a>(5)块定义</h4><pre><code class="highlight less"><span class="variable">@demo:</span> {  <span class="attribute">color</span>: <span class="number">#f00</span>;};<span class="selector-tag">body</span> {  <span class="variable">@demo</span>();}</code></pre><p>编译后：</p><pre><code class="highlight css"><span class="selector-tag">body</span> {  <span class="attribute">color</span>: <span class="number">#f00</span>;}</code></pre><p>该方式和类继承的区别在于该块不会出现在编译的 CSS 中。</p><h3 id="6、函数"><a href="#6、函数" class="headerlink" title="6、函数"></a>6、函数</h3><h4 id="1-逻辑控制"><a href="#1-逻辑控制" class="headerlink" title="(1)逻辑控制"></a>(1)逻辑控制</h4><ul><li><p>格式：statement when(conditons)、prop: if((conditions),value);</p></li><li><p>例子 1：在 less 中使用一个带参类名展示上下左右四个方向的纯 CSS 三角形</p></li></ul><p><strong>index.less</strong></p><pre><code class="highlight less"><span class="selector-class">.base</span>() {  <span class="attribute">width</span>: <span class="number">0</span>;  <span class="attribute">height</span>: <span class="number">0</span>;}<span class="variable">@normal:</span> <span class="number">20px</span> solid transparent;<span class="variable">@anger:</span> <span class="number">20px</span> solid <span class="number">#f00</span>;<span class="selector-class">.triangle</span>(<span class="variable">@val</span>) <span class="keyword">when</span>(<span class="variable">@val</span>=left) {  <span class="selector-class">.base</span>();  <span class="attribute">border-left</span>: none;  <span class="attribute">border-right</span>: <span class="variable">@anger</span>;  <span class="attribute">border-top</span>: <span class="variable">@normal</span>;  <span class="attribute">border-bottom</span>: <span class="variable">@normal</span>;}<span class="selector-class">.triangle</span>(<span class="variable">@val</span>) <span class="keyword">when</span>(<span class="variable">@val</span>=right) {  <span class="selector-class">.base</span>();  <span class="attribute">border-right</span>: none;  <span class="attribute">border-left</span>: <span class="variable">@anger</span>;  <span class="attribute">border-top</span>: <span class="variable">@normal</span>;  <span class="attribute">border-bottom</span>: <span class="variable">@normal</span>;}<span class="selector-class">.triangle</span>(<span class="variable">@val</span>) <span class="keyword">when</span>(<span class="variable">@val</span>=top) {  <span class="selector-class">.base</span>();  <span class="attribute">border-left</span>: <span class="variable">@normal</span>;  <span class="attribute">border-right</span>: <span class="variable">@normal</span>;  <span class="attribute">border-top</span>: none;  <span class="attribute">border-bottom</span>: <span class="variable">@anger</span>;}<span class="selector-class">.triangle</span>(<span class="variable">@val</span>) <span class="keyword">when</span>(<span class="variable">@val</span>=bottom) {  <span class="selector-class">.base</span>();  <span class="attribute">border-left</span>: <span class="variable">@normal</span>;  <span class="attribute">border-right</span>: <span class="variable">@normal</span>;  <span class="attribute">border-top</span>: <span class="variable">@anger</span>;  <span class="attribute">border-bottom</span>: none;}<span class="selector-class">.div1</span> {  <span class="selector-class">.triangle</span>(left);}<span class="selector-class">.div2</span> {  <span class="selector-class">.triangle</span>(right);}<span class="selector-class">.div3</span> {  <span class="selector-class">.triangle</span>(top);}<span class="selector-class">.div4</span> {  <span class="selector-class">.triangle</span>(bottom);}</code></pre><p><strong>index.html</strong></p><pre><code class="highlight html"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span><span class="tag">&lt;<span class="name">html</span>&gt;</span>    <span class="tag">&lt;<span class="name">head</span>&gt;</span>        <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet/less"</span> <span class="attr">href</span>=<span class="string">"index.less"</span>&gt;</span>        <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"../less-1.3.3.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span>    <span class="tag">&lt;/<span class="name">head</span>&gt;</span>    <span class="tag">&lt;<span class="name">body</span>&gt;</span>        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"div1"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span>        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"div2"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span>        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"div3"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span>        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"div4"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span>    <span class="tag">&lt;/<span class="name">body</span></span>&lt;/html&gt;</code></pre><ul><li>例子 2：</li></ul><pre><code class="highlight less"><span class="attribute">background</span>: if((true), <span class="number">#f00</span>);</code></pre><h4 id="2-循环"><a href="#2-循环" class="headerlink" title="(2)循环"></a>(2)循环</h4><p>例子：将 8 个 td 的背景依次更换为 bg_1.png、bg_2.png、…、bg_8.png</p><pre><code class="highlight less"><span class="selector-tag">table</span> <span class="selector-tag">td</span> {  <span class="attribute">width</span>: <span class="number">200px</span>;  <span class="attribute">height</span>: <span class="number">200px</span>;  <span class="selector-class">.loop</span>(<span class="variable">@i</span>) <span class="keyword">when</span>(<span class="variable">@i</span>&lt;<span class="number">9</span>) {    <span class="selector-tag">&amp;</span><span class="selector-pseudo">:nth-child(</span><span class="variable">@{i}</span>) {      <span class="attribute">background</span>: url(<span class="string">~"../images/partner_@{i}.png"</span>) no-repeat;    }    <span class="selector-class">.loop</span>(<span class="variable">@i</span>+<span class="number">1</span>);  }  <span class="selector-class">.loop</span>(<span class="number">1</span>);}</code></pre><h4 id="3-列表"><a href="#3-列表" class="headerlink" title="(3)列表"></a>(3)列表</h4><pre><code class="highlight less"><span class="variable">@backgroundlist:</span> apple, pear, coconut, orange;</code></pre><h4 id="4-less-函数库"><a href="#4-less-函数库" class="headerlink" title="(4)less 函数库"></a>(4)less 函数库</h4><pre><code class="highlight less"><span class="selector-tag">image-size</span>(“bg.png”) <span class="comment">//获取图片的Width和Height</span><span class="selector-tag">image-width</span>() <span class="comment">//获取图片的Width和Height</span><span class="selector-tag">image-height</span>() <span class="comment">//获取图片的Width和Height</span><span class="selector-tag">convert</span>(<span class="number">9s</span>, ms) <span class="comment">//转换9秒为毫秒</span><span class="selector-tag">convert</span>(<span class="number">14cm</span>, mm) <span class="comment">//转换14厘米为毫米</span></code></pre><p>更多函数参考官方函数库，包括混合函数、数学函数、字符串函数、列表函数等等</p><h3 id="7、使用-JS-表达式"><a href="#7、使用-JS-表达式" class="headerlink" title="7、使用 JS 表达式"></a>7、使用 JS 表达式</h3><ul><li><p>less 中还可以引用 js 表达式，不过一般都不推荐使用，此种方式在使用 nodejs 将 less 编译 css 时可能会报错。</p></li><li><p>格式：<strong>`javascript`</strong></p></li><li><p>例子：将高度设置为当前获取到的浏览器的高度</p></li></ul><pre><code class="highlight less"><span class="variable">@fullHeight:</span> unit(<span class="built_in">` window.screen.height `</span>, px);<span class="selector-tag">div</span> {  <span class="attribute">height</span>: <span class="variable">@fullHeight</span>;}</code></pre><ul><li>尝试将 <strong>@width: unit(` window.screen.width `, px)</strong> 引进 <strong>vw 布局</strong> ？不推荐，不建议 less 在正式环境中使用，使用 LESS 时需要在头部引入 js，而在 js 执行时的时候，会消耗时间，而 less 编译需要在 js 执行后，会在一定程度上影响到性能。</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LESS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>有趣的list-style</title>
      <link href="2020/08/12/HTML&amp;CSS/CSSlist-style/"/>
      <url>2020/08/12/HTML&amp;CSS/CSSlist-style/</url>
      
        <content type="html"><![CDATA[<h2 id="有趣的list-style"><a href="#有趣的list-style" class="headerlink" title="有趣的list-style "></a>有趣的list-style <span id="home"></span></h2><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><strong><a href="#1">一、list-style-type </a></strong><ul><li><strong><a href="#1.1">1、CSS2.0 </a></strong></li><li><strong><a href="#1.2">2、CSS2.1 的值 </a></strong></li></ul></li><li><strong><a href="#2">二、list-style-position </a></strong><ul><li><strong><a href="#2.1">1、书写格式 </a></strong></li><li><strong><a href="#2.2">2、可能的值 </a></strong></li></ul></li><li><strong><a href="#3">三、list-style-image </a></strong><ul><li><strong><a href="#3.1">书写格式 </a></strong></li><li><strong><a href="#3.1">可能的值 </a></strong></li></ul></li></ul><hr><h2 id="一、list-style-type"><a href="#一、list-style-type" class="headerlink" title="一、list-style-type "></a>一、list-style-type <span id="1"></span></h2><h4 id="1、CSS2-0"><a href="#1、CSS2-0" class="headerlink" title="1、CSS2.0 "></a>1、CSS2.0 <span id="1.1"></span></h4><pre><code>值                        描述none                    无标记。disc                    默认。标记是实心圆。circle                    标记是空心圆。square                    标记是实心方块。decimal                    标记是数字。decimal-leading-zero    0开头的数字标记。(01, 02, 03, 等。)lower-roman                小写罗马数字(i, ii, iii, iv, v, 等。)upper-roman                大写罗马数字(I, II, III, IV, V, 等。)lower-alpha                小写英文字母The marker is lower-alpha (a, b, c, d, e, 等。)upper-alpha                大写英文字母The marker is upper-alpha (A, B, C, D, E, 等。)lower-greek                小写希腊字母(alpha, beta, gamma, 等。)lower-latin                小写拉丁字母(a, b, c, d, e, 等。)upper-latin                大写拉丁字母(A, B, C, D, E, 等。)hebrew                    传统的希伯来编号方式armenian                传统的亚美尼亚编号方式georgian                传统的乔治亚编号方式(an, ban, gan, 等。)cjk-ideographic            简单的表意数字hiragana                标记是：a, i, u, e, o, ka, ki, 等。（日文片假名）katakana                标记是：A, I, U, E, O, KA, KI, 等。（日文片假名）hiragana-iroha            标记是：i, ro, ha, ni, ho, he, to, 等。（日文片假名）katakana-iroha            标记是：I, RO, HA, NI, HO, HE, TO, 等。（日文片假名）</code></pre><h4 id="2、CSS2-1-的值"><a href="#2、CSS2-1-的值" class="headerlink" title="2、CSS2.1 的值 "></a>2、CSS2.1 的值 <span id="1.2"></span></h4><pre><code>disc | circle | square | decimal | decimal-leading-zero |lower-roman | upper-roman | lower-greek | lower-latin | upper-latin | armenian | georgian | none | inherit</code></pre><hr><h2 id="二、list-style-position"><a href="#二、list-style-position" class="headerlink" title="二、list-style-position "></a>二、list-style-position <span id="2"></span></h2><h4 id="1、说明"><a href="#1、说明" class="headerlink" title="1、说明 "></a>1、说明 <span id="2.1"></span></h4><p>该属性用于声明列表标志相对于列表项内容的位置。外部 (outside) 标志会放在离列表项边框边界一定距离处，不过这距离在 CSS 中未定义。内部 (inside) 标志处理为好像它们是插入在列表项内容最前面的行内元素一样</p><h4 id="2、可能的值"><a href="#2、可能的值" class="headerlink" title="2、可能的值 "></a>2、可能的值 <span id="2.2"></span></h4><pre><code>值            描述inside        列表项目标记放置在文本以内，且环绕文本根据标记对齐。outside        默认值。保持标记位于文本的左侧。列表项目标记放置在文本以外，且环绕文本不根据标记对齐。inherit        规定应该从父元素继承 list-style-position 属性的值。</code></pre><hr><h2 id="三、list-style-image"><a href="#三、list-style-image" class="headerlink" title="三、list-style-image "></a>三、list-style-image <span id="3"></span></h2><h4 id="1、书写格式"><a href="#1、书写格式" class="headerlink" title="1、书写格式 "></a>1、书写格式 <span id="3.1"></span></h4><pre><code>url("position")</code></pre><h4 id="2、可能的值-1"><a href="#2、可能的值-1" class="headerlink" title="2、可能的值 "></a>2、可能的值 <span id="3.2"></span></h4><pre><code>值            描述URL            图像的路径。none        默认。无图形被显示。inherit        规定应该从父元素继承 list-style-image 属性的值。</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从输入URL到显示页面的步骤</title>
      <link href="2020/08/11/HTML&amp;CSS/%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E6%98%BE%E7%A4%BA%E9%A1%B5%E9%9D%A2%E7%9A%84%E6%AD%A5%E9%AA%A4/"/>
      <url>2020/08/11/HTML&amp;CSS/%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E6%98%BE%E7%A4%BA%E9%A1%B5%E9%9D%A2%E7%9A%84%E6%AD%A5%E9%AA%A4/</url>
      
        <content type="html"><![CDATA[<h2 id="精简"><a href="#精简" class="headerlink" title="精简"></a>精简</h2><ol><li>根据请求的<code>URL</code>交给<code>DNS</code>域名解析，找到真实<code>IP</code>，向服务器发起请求；</li><li>服务器交给后台处理完成后返回数据，浏览器接受文件（<code>HTML、JS、CSS</code>、图像等）；</li><li>浏览器对返还的资源进行解析，并建立相应的内部数据结构（如<code>HTML</code>的<code>DOM</code>）；</li><li>载入解析到的资源文件，渲染页面</li></ol><h2 id="详细"><a href="#详细" class="headerlink" title="详细"></a>详细</h2><ol><li>输入URL</li><li>浏览器检查缓存<ul><li>若未缓存，发起新请求</li><li>若有缓存，且新鲜，则直接使用缓存，跳到转码步骤</li><li>若不新鲜，则携带缓存标识对服务器发起请求，根据服务器相应数据再生成页面</li></ul></li><li>浏览器解析URL获取协议、主机、端口、path</li><li>组装一个HTTP请求报文</li><li>浏览器获取主机IP地址，过程如下：<ul><li>浏览器缓存</li><li>本级缓存</li><li>hosts文件</li><li>路由器缓存</li><li>ISP DNS缓存</li><li>DNS递归查询</li></ul></li><li>打开一个socket与目标IP地址，开始TCP三次握手：<ul><li>客户端发送一个TCP的<code>SYN=1,Seq=X</code>的包到服务器端口</li><li>服务器返回<code>SYN=1,ACK=X+1,Seq=Y</code>的响应包</li><li>客户端发送<code>ACK=Y+1,Seq=Z</code></li></ul></li><li>TCP连接建立后发送HTTP请求</li><li>服务器接受请求并解析，转到服务程序</li><li>检查请求头是否携带缓存标识，有则验证是否新鲜，返回304等对应状态码</li><li>处理程序读取完整请求并准备HTTP相应，可能需要查询数据库等操作</li><li>服务器等响应报文通过TCP连接发送回浏览器</li><li>浏览器接受HTTP响应，根据情况选择关闭TCP连接或保留重用，关闭则进行TCP四次挥手：<ul><li>主动方发送<code>Fin=1, Ack=Z, Seq=X</code></li><li>被动方发送<code>ACK=X+1, Seq=Z</code></li><li>被动方发送<code>Fin=1, ACK=X, Seq=Y</code></li><li>主动方发送<code>ACK=Y,Seq=X</code></li></ul></li><li>浏览器检查响应码：是否为1XX，3XX，4XX，5XX，这些情况处理与2XX不同</li><li>查看是否可缓存，可以则缓存</li><li>对相应进行解码（如gzip压缩）</li><li>根据资源类型决定如何处理（假设资源为HTML文档）</li><li>解析HTML文档，构件DOM树，下载资源，构造CSSOM树，执行JS脚本，这些操作没有严格的先后顺序</li><li>构件DOM树：<ul><li><code>Tokenizing</code>：根据<strong>HTML规范</strong>将字符流解析为标记</li><li><code>Lexing</code>：<strong>词法分析</strong>将标记转换为对象并定义属性和规则</li><li><code>DOM construction</code>：根据<strong>HTML标记关系</strong>将对象组成DOM树</li></ul></li><li>解析过程中遇到图片、样式表、js脚本，启动下载</li><li>构件<strong>CSSOM树：</strong><ul><li><code>Tokenizing</code>：将字符流转换为标记流</li><li><code>Node</code>：根据标记创建节点</li><li><code>CSSOM</code>：节点创建CSSOM树</li></ul></li><li><strong>根据DOM树和CSSOM树构件渲染树：</strong><ul><li>从DOM树的根节点遍历所有可见节点，不可见节点包括：</li><li><code>script、meta</code>这样本身不可见的标签</li><li>被css隐藏的节点，如<code>display:none</code></li><li>对没一个可见节点，找到恰当的CSSOM规则并应用</li><li>发布可视节点的内容个计算样式</li></ul></li><li>JS解析如下：<ul><li>浏览器创建Document对象，并解析HTML，将解析到的元素和文本节点添加到文档中，此时<strong>document.readystate为loading</strong></li><li>遇到<strong>同步的script</strong>时，将它们添加到文档，文档暂停解析，转而进行下载并运行脚本。如此可以用document.write()可以吧文本插入到输入流中。<strong>同步脚本经常简单定义函数和注册事件处理程序，他们可以遍历和操作script和他们之前的文档内容</strong></li><li>遇到<strong>async的script</strong>时，开始下载脚本，并继续解析文档。脚本会在<strong>下载完成后尽快执行</strong>。<strong>异步脚本禁止使用write，它们可以访问自己script和之前的文档元素</strong></li><li>当文档完成解析，<strong>document.readyState变成interactive</strong></li><li>所有<strong>defer的script</strong>也会挂起下载而不阻塞解析，<strong>在文档完全被解析和显示后，按照在文档中出现的顺序进行执行</strong>，可以访问完整文档树，禁止使用write()</li><li>Document对象<strong>触发DOMContentLoaded事件</strong></li><li>此时文档完全解析，浏览器可能还在等待如图片的内容的加载，这些内容完成载入并且所有异步脚本完成载入和执行，<strong>document.readyState变为complete，window触发load事件</strong></li></ul></li><li>显示页面（HTML解析过程中会逐步显示页面）<ul><li>从浏览器接受<code>URL</code>到开启网络请求线程（可以展开浏览器的机制及进程与线程间的关系）</li><li>开启网络线程到发出一个完整的<code>HTTP</code>请求（设计到DNS查询，<code>TCP/IP</code>请求，五层因特网协议栈等）</li><li>服务器接受到请求到对应后台接收到请求（可能设计到负载均衡，安全拦截以及后台内部的处理）</li><li>后台和前台的<code>HTTP</code>交互（这部分包括报文组成、<code>cookie</code>等知识，静态资源的<code>cookie</code>优化，以及编码解码，如<code>gzip</code>压缩等）</li><li>单独拎出来的缓存问题（包括缓存头部、ETag、catch-control等）</li><li>浏览器接收到数据包后的解析流程（解析<code>HTML</code>-词法分析-生成DOM树、解析<code>CSS</code>生成css规则树、合并成<code>render</code>树，然后<code>layout</code>、<code>painting</code>渲染、复合图层的合成、<code>GPU</code>绘制、外链资源的处理、<code>loaded</code>和<code>DOMContentLoaded</code>等）</li><li>CSS的可视化格式模型（元素的渲染规则，如包含块、控制框、BFC、IFC等概念）</li><li>JS引擎解析过程（JS的解释阶段、预处理阶段、执行阶段生成执行上下文，VO，作用域链、回收机制等等）</li><li>其他（如跨域、web安全、hybrid模式等等）</li></ul></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> HTML </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS样式之内容居中方法</title>
      <link href="2020/07/14/HTML&amp;CSS/CSSInCenter/"/>
      <url>2020/07/14/HTML&amp;CSS/CSSInCenter/</url>
      
        <content type="html"><![CDATA[<h3 id="水平居中"><a href="#水平居中" class="headerlink" title="水平居中"></a>水平居中</h3><p>HTML中要实现某一内容水平居中显示，要通过设置css样式来实现，主要分为<strong>行内元素</strong>和<strong>块状元素</strong>两种情况，<strong>块状元素</strong>又可分为<strong>块状定宽</strong>与<strong>块状不定宽</strong>两种情况，接下来依次介绍分析。</p><h4 id="行内元素"><a href="#行内元素" class="headerlink" title="行内元素"></a>行内元素</h4><p>像 a、span、i 这类元素叫做行内元素，<strong>文本</strong>和<strong>图片</strong>也是行内元素。行内元素水平居中方法简单，只需要给行内元素的<strong>父元素</strong>设置 <code>text-align: center;</code> css样式就内实现内容水平居中，例如：html:</p><pre><code class="highlight html"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span> = <span class="string">"txt"</span>&gt;</span>居中内容<span class="tag">&lt;/<span class="name">div</span>&gt;</span></code></pre><p>css:</p><pre><code class="highlight css"><span class="selector-class">.txt</span> {<span class="attribute">text-align</span>: center;}</code></pre><p>文本内容的<strong>父元素</strong>就是 <code>div</code> ，这样就内实现水平居中，效果如下：</p><div align="center"><b>居中内容</b></div><h4 id="块状定宽元素"><a href="#块状定宽元素" class="headerlink" title="块状定宽元素"></a>块状定宽元素</h4><p>常见块状元素有 div, p, h 等，定宽即为其设置固定宽度值 <code>width</code>，这时我们可以为元素设置 <code>margin-left</code> 和 <code>margin-right</code> 来实现水平居中，也可以简写为 <code>margin: 0 auto;</code>，例如：html:</p><pre><code class="highlight html"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span> = <span class="string">"txt"</span>&gt;</span>居中内容<span class="tag">&lt;/<span class="name">div</span>&gt;</span></code></pre><p>css:</p><pre><code class="highlight css"><span class="selector-class">.txt</span> {<span class="attribute">width</span>: <span class="number">100px</span>;<span class="attribute">margin</span>: <span class="number">10px</span> auto;}</code></pre><p>实现效果如下：</p><div align="center"><b>居中内容</b></div><h4 id="块状不定宽"><a href="#块状不定宽" class="headerlink" title="块状不定宽"></a>块状不定宽</h4><p>有时候我们不能限制块状元素的宽度，就是块状不定宽元素，主要有三种方法，接下来一次介绍。</p><h5 id="1、加入-table-标签"><a href="#1、加入-table-标签" class="headerlink" title="1、加入 table 标签"></a>1、加入 table 标签</h5><p>利用 table 标签的<strong>长度自适应性</strong>，长度根据内容自动调整，然后通过设置 <code>margin: auto;</code> 实现水平居中，例如：html:</p><pre><code class="highlight html"><span class="tag">&lt;<span class="name">table</span>&gt;</span><span class="tag">&lt;<span class="name">tbody</span>&gt;</span><span class="tag">&lt;<span class="name">tr</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span> = <span class="string">"txt"</span>&gt;</span>居中内容<span class="tag">&lt;/<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">tr</span>&gt;</span><span class="tag">&lt;/<span class="name">tbody</span>&gt;</span><span class="tag">&lt;/<span class="name">table</span>&gt;</span></code></pre><p>css:</p><pre><code class="highlight css"><span class="selector-class">.txt</span> {<span class="attribute">margin</span>: auto;}</code></pre><p>效果如下：</p><div align="center"><b>居中内容</b></div><h5 id="2、设置为行内元素"><a href="#2、设置为行内元素" class="headerlink" title="2、设置为行内元素"></a>2、设置为行内元素</h5><p>就是通过设置 <code>display: inline;</code> 将块状元素设置为<strong>行内元素</strong>，然后就是像行内元素一样设置 <code>text-align: center;</code> 来是内容水平居中，例如：html:</p><pre><code class="highlight html"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span> = <span class="string">"txt"</span>&gt;</span>居中内容<span class="tag">&lt;/<span class="name">div</span>&gt;</span></code></pre><p>css:</p><pre><code class="highlight css"><span class="selector-class">.txt</span> {<span class="attribute">display</span>: inline;<span class="attribute">text-align</span>: center;}</code></pre><p>效果为：</p><div align="center"><b>居中内容</b></div><p><strong>注：</strong></p><blockquote><p><strong>使用这种方法虽然可以不用像table增加无语义标签，但是改变了display，所以会少了一些功能，例如不能设置宽度。</strong></p></blockquote><h5 id="3、设置浮动和相对定位"><a href="#3、设置浮动和相对定位" class="headerlink" title="3、设置浮动和相对定位"></a>3、设置浮动和相对定位</h5><p>这种方法设置就相对复杂，同时设置<strong>浮动</strong>和<strong>相对定位</strong>来实现元素的水平居中。首先设置<strong>父元素</strong>：</p><pre><code class="highlight css"><span class="selector-tag">float</span>: <span class="selector-tag">left</span>;<span class="selector-tag">position</span>: <span class="selector-tag">relative</span>;<span class="selector-tag">left</span>: 50%;</code></pre><p>然后设置<strong>子元素</strong>：</p><pre><code class="highlight css"><span class="selector-tag">position</span>: <span class="selector-tag">relative</span>;<span class="selector-tag">left</span>: <span class="selector-tag">-50</span>%;</code></pre><p>通过代码应该好理解，就是通过<strong>50%</strong>那个关键位置来实现水平居中效果，因为<strong>50%</strong>是界面的中央位置，将父元素右移，直到左边框移到中线位置，在将子元素向左移，这样子元素不就居中了吗。</p><p>这里要<strong>注意</strong>的是分别设置<strong>父元素</strong>的 <code>50%</code> 和<strong>子元素</strong>的 <code>-50%</code>。实现效果如下：</p><div align="center"><b>居中内容</b></div><h3 id="垂直居中"><a href="#垂直居中" class="headerlink" title="垂直居中"></a>垂直居中</h3><p>说完水平居中接着说垂直居中，这里主要又分为两种情况：<strong>父元素高度确定的单行文本</strong> 和<strong>父元素高度确定的多行文本</strong>。</p><h4 id="单行文本"><a href="#单行文本" class="headerlink" title="单行文本"></a>单行文本</h4><p>对于<strong>父元素</strong>高度确定的单行文本，可以通过设置<strong>父元素</strong>的 <code>height</code> 和 <code>line-height</code> 高度一致来实现。</p><p>这里可以这样理解，<code>height</code> 是元素的高度，例如文本字体的高度，<code>line-height</code> 是行高，例如文本的行间距，一行文本中，行间距被<strong>分为两部分</strong>，分别位于这行文本的<strong>顶部</strong>和<strong>底部</strong>（因为行间距是两行之间的距离），所以设置 <code>height</code> 和 <code>line-height</code> <strong>一样大</strong>的话，<code>line-height</code> 就被均分为两部分，分别位于元素顶部和底部，这样中间设置为 <code>height</code> 的元素不就实现<strong>垂直居中</strong>了吗 ^_^ .</p><p>例如：html:</p><pre><code class="highlight html"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span> = <span class="string">"txt"</span>&gt;</span>居中内容<span class="tag">&lt;/<span class="name">div</span>&gt;</span></code></pre><p>css:</p><pre><code class="highlight css"><span class="selector-class">.txt</span> {<span class="attribute">height</span>: <span class="number">200px</span>;<span class="attribute">line-height</span>: <span class="number">200px</span>;}</code></pre><p>效果如下：</p><pre>居中内容</pre><blockquote><p><strong>这里需要注意的是关键词“单行文本”，如果使用这种方法但是一行文本超过宽度限制的话，某些内容就会脱离元素块，子元素有多行的话，这几行就会并排居中，并保持设置的行高。</strong></p></blockquote><h4 id="多行文本"><a href="#多行文本" class="headerlink" title="多行文本"></a>多行文本</h4><p>对于父元素高度确定的<strong>文本</strong>和<strong>图片</strong>等内容设置垂直居中，主要有两种方法。</p><h5 id="1、使用-table-标签"><a href="#1、使用-table-标签" class="headerlink" title="1、使用 table 标签"></a>1、使用 table 标签</h5><p>对元素使用<strong>table</strong>标签，包括 tbody，tr，td，然后对父元素设置 <code>vertical-align: middle;</code> 样式，就能使 <code>inline-block</code> 类型的子元素垂直居中显示。</p><p>因为 td 标签<strong>默认</strong>设置了 <code>vertical-align: middle</code>，所以也可以不用单独设置 <code>vertical-align</code>。例如：html:</p><pre><code class="highlight html"><span class="tag">&lt;<span class="name">table</span>&gt;</span><span class="tag">&lt;<span class="name">tbody</span>&gt;</span><span class="tag">&lt;<span class="name">tr</span>&gt;</span><span class="tag">&lt;<span class="name">td</span> <span class="attr">class</span>=<span class="string">"txt"</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span>居中内容<span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span>居中内容<span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span>居中内容<span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">tr</span>&gt;</span><span class="tag">&lt;/<span class="name">tbody</span>&gt;</span><span class="tag">&lt;/<span class="name">table</span>&gt;</span></code></pre><p>css:</p><pre><code class="highlight css"><span class="selector-class">.txt</span> {        <span class="attribute">height</span>: <span class="number">300px</span>;<span class="attribute">background-color</span>: <span class="number">#ccc</span>;}</code></pre><blockquote><p><strong>这里的父元素就是 td，父元素的高度必须确定，就要为其设置 height。</strong></p></blockquote><p><strong>注意</strong>这里的 p 元素是 <strong>inline</strong> 类型的，所以设置 <code>vertical-align: middle</code> 的话会出现错误，若果是图片元素 img 的话，就可以设置 <code>vertical-align: middle</code>，但是由于 td 标签默认，所以都可以不写。</p><p>效果如下：</p><pre>居中内容</pre><h5 id="2、设置-table-cell"><a href="#2、设置-table-cell" class="headerlink" title="2、设置 table-cell"></a>2、设置 table-cell</h5><p>第二种方法是把要垂直居中显示的元素的父元素设置为<strong>table-cell (表格单元)</strong>类型：<code>display: table-cell;</code>，然后设置 <code>vertical-align: middle</code>就能实现元素垂直居中。</p><p>但是这个方法存在兼容性问题，<strong>chrome, firefox, IE8以上</strong>才支持这个操作。</p><p>例如：html:</p><pre><code class="highlight html"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"txt"</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span>居中内容<span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span>居中内容<span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span>居中内容<span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></code></pre><p>css:</p><pre><code class="highlight css"><span class="selector-class">.txt</span> {        <span class="attribute">height</span>: <span class="number">300px</span>;<span class="attribute">background-color</span>: <span class="number">#ccc</span>;<span class="attribute">display</span>: table-cell;<span class="attribute">vertical-align</span>: middle;}</code></pre><blockquote><p><strong>同样，要为父元素 div 设置高度 height</strong></p></blockquote><p>效果如下：</p><pre>居中内容</pre><p>这种方法除了兼容性问题外，同时也改变了 <strong>display</strong>类型，会在某些方面带来不便。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DIV+CSS布局</title>
      <link href="2020/07/08/HTML&amp;CSS/CSSDIVCSS/"/>
      <url>2020/07/08/HTML&amp;CSS/CSSDIVCSS/</url>
      
        <content type="html"><![CDATA[<h2 id="DIV-CSS布局"><a href="#DIV-CSS布局" class="headerlink" title="DIV+CSS布局"></a>DIV+CSS布局</h2><h3 id="一、DIV结构"><a href="#一、DIV结构" class="headerlink" title="一、DIV结构"></a>一、DIV结构</h3><pre><code class="highlight plain">│body {}　/* 这是一个HTML元素 */└#Container {}　/* 页面层容器 */├#Header {}　/* 页面头部 */├#MianBody {}　/* 页面主体 */│　├#mainbody-left {}　/* 主体页面左边 */│　└#mainbody-center {}　/* 主体页面中间 */│　└#MainBody -right{}　/* 主体页面右边 */└#footer {}　/*页面底部*/</code></pre><p>用DIV+CSS做一个导航栏是非常容易的，而且我们可以通过css来对导航栏的样式方便的作出调整。用div设置导航栏一般就用</p><ul>和<li>标签。<p></p><p>4、高度显示效果不同</p><p>一般情况下只需要使用<code>height: 100px</code>; 即可，当显示效果不同时，则可以<code>_height: 100px</code>;来对IE6的高度进行设置。</p><p>5、嵌套效果不不同</p><p>有些情况下如果div中嵌套的图片大于外层div的高度，则IE6中对高度的设置始终无效，这时要注意对该css添加overflow属性，<code>overloaw:hidden</code>，则可隐藏超出边界的部分。</p><h3 id="二、文件命名规范"><a href="#二、文件命名规范" class="headerlink" title="二、文件命名规范"></a>二、文件命名规范</h3><p>全局样式：global.css；</p><p>框架布局：layout.css；</p><p>字体样式：font.css；</p><p>链接样式：link.css；</p><p>打印样式：print.css；</p><h3 id="三、常用类-ID命名规范"><a href="#三、常用类-ID命名规范" class="headerlink" title="三、常用类/ID命名规范"></a>三、常用类/ID命名规范</h3><p>页　眉：header</p><p>内　容：content</p><p>容　器：container</p><p>页　脚：footer</p><p>版　权：copyright　</p><p>导　航：menu</p><p>主导航：mainMenu</p><p>子导航：subMenu</p><p>标　志：logo</p><p>标　语：banner</p><p>标　题：title</p><p>侧边栏：sidebar</p><p>图　标：Icon</p><p>注　释：note</p><p>搜　索：search</p><p>按　钮：btn</p><p>登　录：login</p><p>链　接：link</p><p>信息框：manage</p><h3 id="四、常规书写规范及方法"><a href="#四、常规书写规范及方法" class="headerlink" title="四、常规书写规范及方法"></a>四、常规书写规范及方法</h3><p>1、选择DOCTYPE</p><p>html5声明</p><pre><code class="highlight html"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></code></pre><p>过渡的(Transitional): 要求非常宽松的DTD // 推荐</p><pre><code class="highlight html"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//W3C//DTD XHTML 1.0 Transitional//EN"</span> <span class="meta-string">"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"</span>&gt;</span></code></pre><p>严格的(Strict):要求严格的DTD</p><pre><code class="highlight html"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//W3C//DTD XHTML 1.0 Strict//EN"</span> <span class="meta-string">"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"</span>&gt;</span></code></pre><p>框架的(Frameset):专门针对框架页面设计使用的DTD</p><pre><code class="highlight html"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//W3C//DTD XHTML 1.0 Frameset//EN"</span> <span class="meta-string">"http://www.w3.org/TR/xhtml1/DTD/xhtml1-frameset.dtd"</span>&gt;</span></code></pre><p>2、指定语言及字符集</p><p>语言定义:</p><pre><code class="highlight html"><span class="tag">&lt;<span class="name">html</span> <span class="attr">xmlns</span>=<span class="string">:http://www.w3.org/1999/xhtml</span>" <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></code></pre><p>编码定义:</p><pre><code class="highlight html"><span class="comment">&lt;!-- 老浏览器 --&gt;</span><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Content-Type"</span> <span class="attr">content</span>=<span class="string">"text/html; charset=utf-8"</span> /&gt;</span><span class="comment">&lt;!-- XML文件 --&gt;</span><span class="meta">&lt;?xml version="1.0" encoding=" utf-8"?&gt;</span></code></pre><ol start="3"><li>调用样式表</li></ol><p>外部调用法：将样式表写在一个独立的.css文件中，然后在页面head区用类似以下代码调用。（推荐）</p><p>页面内嵌法：就是将样式表直接写在页面代码的head区。</p><p>4、选用恰当的元素</p><p>根据文档的结构来选择HTML元素，而不是根据HTML元素的样式来选择。例如，使用P元素来包含文字段落，而不是为了换行。</p><p>避免过渡使用div和span</p><p>尽可能少地使用标签和结构嵌套，这样不但可以使文档结构清晰，同时也可以保持文件的小巧，在提高用户下载速度的同时，也易于浏览器对文档的解释及呈视；</p><p>5、派生选择器</p><p>可以使用派生选择器给一个元素里的子元素定义样式，在简化命名的同时也使结构更加的清晰化</p><p>如：</p><pre><code class="highlight css"><span class="selector-class">.mainMenu</span> <span class="selector-tag">ul</span> <span class="selector-tag">li</span> { <span class="attribute">background</span>: <span class="built_in">url</span>(images/bg.gif;) }</code></pre><p>6、辅助图片用背影图处理  仅用于修饰、间隔、提醒的图片</p><p>7、结构与样式分离  在页面里只写入文档的结构，而将样式写于css文件中，通过外部调用CSS样式表来实现结构与样式的分离。</p><p>8、文档的结构化书写</p><p>页面CSS文档都应采用结构化的书写方式，逻辑清晰易于阅读。如：</p><pre><code class="highlight html"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"mainMenu"</span>&gt;</span><span class="tag">&lt;<span class="name">ul</span>&gt;</span><span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">ul</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></code></pre><pre><code class="highlight css"><span class="selector-id">#mainMenu</span> <span class="selector-tag">ul</span> <span class="selector-tag">li</span> { }</code></pre><p>9、鼠标手势</p><p>在XHTML标准中，hand只被IE识别，当需要将鼠标手势转换为“手形”时，则将“hand”换为“pointer”，即“cursor:pointer;”</p><h3 id="五、注释书写"><a href="#五、注释书写" class="headerlink" title="五、注释书写"></a>五、注释书写</h3><p>1、行间注释</p><p>直接写于属性值后面</p><pre><code class="highlight css"><span class="selector-tag">border</span>: 1<span class="selector-tag">px</span> <span class="selector-tag">solid</span> <span class="selector-id">#fff</span>; <span class="comment">/*定义搜索输入框边框*/</span></code></pre><p>2、整段注释</p><pre><code class="highlight css"><span class="comment">/*===== 搜索条开始 =====*/</span>   <span class="selector-class">.search</span> {    <span class="attribute">border</span>:<span class="number">1px</span> solid <span class="number">#fff</span>;       <span class="attribute">background</span>:<span class="built_in">url</span>(../images/icon.gif) no-repeat <span class="number">#333</span>;   }<span class="comment">/*===== 搜索条结束 =====*/</span></code></pre><h3 id="六、样式属性代码缩写"><a href="#六、样式属性代码缩写" class="headerlink" title="六、样式属性代码缩写"></a>六、样式属性代码缩写</h3><p>1、不同类有相同属性及属性值的缩写</p><p>对于两个不同的类，但是其中有部分相同甚至是全部相同的属性及属性值时，应对其加以合并缩写，特别是当有多个不同的类而有相同的属性及属性值时，合并缩写可以减少代码量并易于控制。</p><p>2、同一属性的缩写</p><p>background包含：background-color、background-image、background-repeat、background-position</p><p>同一属性根据它的属性值也可以进行简写</p><p>3、内外侧边框的缩写</p><p>margin、padding</p><p>top right bottom left</p><p>上边与下边、左边与右边的边框属性值相同时，则属性值可以直接缩写为两个(上下、左右)</p><p>上下左右四个边框的属性值都相同时，则可以直接缩写成一个</p><p>在CSS中关于内外侧边框的距离是按照上、右、下、左的顺序来排列的，当这四个属性值不同时也可直接缩写</p><p>4、颜色值的缩写</p><p>当RGB三个颜色值数值相同时，可缩写颜色值代码</p></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>flex布局</title>
      <link href="2020/07/08/HTML&amp;CSS/CSSFlexBox/"/>
      <url>2020/07/08/HTML&amp;CSS/CSSFlexBox/</url>
      
        <content type="html"><![CDATA[<h1 id="flex布局"><a href="#flex布局" class="headerlink" title="flex布局"></a>flex布局</h1><h2 id="一、使用注意"><a href="#一、使用注意" class="headerlink" title="一、使用注意"></a>一、使用注意</h2><blockquote><p>将元素display声明为flex，该元素将成为flex布局的父元素，下一级的直系子元素将成为flex子项</p></blockquote><blockquote><p>flex容器内元素，即flex item的float，clear、vertical-align属性将失效</p></blockquote><h2 id="二、flex容器属性"><a href="#二、flex容器属性" class="headerlink" title="二、flex容器属性"></a>二、flex容器属性</h2><p>1、flex-direction  排列方向</p><blockquote><p>row:主轴为水平方向，项目沿主轴从左至右排列</p></blockquote><blockquote><p>column：主轴为竖直方向，项目沿主轴从上至下排列</p></blockquote><blockquote><p>row-reverse：主轴水平，项目从右至左排列，与row反向</p></blockquote><blockquote><p>column-reverse：主轴竖直，项目从下至上排列，与column反向</p></blockquote><p>2、flex-wrap  换行方式</p><blockquote><p>nowrap：自动缩小项目，不换行</p></blockquote><blockquote><p>wrap：换行，且第一行在上方</p></blockquote><blockquote><p>wrap-reverse：换行，第一行在下面</p></blockquote><p>3、flex-flow  flex-direction和flex-wrap的简写</p><p>默认值为row nowrap</p><p>4、justify-content  主轴对齐方式</p><blockquote><p>flex-start：左对齐</p></blockquote><blockquote><p>flex-end：右对齐</p></blockquote><blockquote><p>center：居中对齐</p></blockquote><blockquote><p>space- between：两端对齐</p></blockquote><blockquote><p>space-around：沿轴线均匀分布</p></blockquote><p>5、align-items  交叉轴对齐方式</p><p>6、align-content  多行交叉轴对齐方式</p><p>定义了align-content后，align-items属性将失效</p><blockquote><p>flex-start：左对齐</p></blockquote><blockquote><p>flex-end：右对齐</p></blockquote><blockquote><p>center：居中对齐</p></blockquote><blockquote><p>space-between：两端对齐</p></blockquote><blockquote><p>space-around：沿轴线均匀分布</p></blockquote><blockquote><p>stretch：各行将根据其flex-grow值伸展以充分占据剩余空间</p></blockquote><h2 id="三、flex-item属性详述"><a href="#三、flex-item属性详述" class="headerlink" title="三、flex item属性详述"></a>三、flex item属性详述</h2><p>item的属性在item的style中设置。</p><p>1、order</p><p>order的值是整数，默认为0，整数越小，item排列越靠前</p><p>2、flex-grow</p><p>定义当flex容器有多余空间时，item是否放大。默认值为0，即当有多余空间时也不放大；可能的值为整数，表示不同item的放大比例</p><p>3、flex-shrink定义当容器空间不足时，item是否缩小。默认值为1，表示当空间不足时，item自动缩小，其可能的值为整数，表示不同item的缩小比例。</p><p>4、flex-basis</p><p>主轴占据空间，默认值为auto。</p><p>5、flex</p><p>flex属性是flex-grow、flex-shrink和flex-basis三属性的简写总和。</p><p>6、align-self</p><blockquote><p>align-self属性允许item有自己独特的在交叉轴上的对齐方式，它有六个可能的值。默认值为auto</p></blockquote><blockquote><p>auto：和父元素align-self的值一致</p></blockquote><blockquote><p>flex-start：顶端对齐</p></blockquote><blockquote><p>flex-end：底部对齐</p></blockquote><blockquote><p>center：竖直方向上居中对齐</p></blockquote><blockquote><p>baseline：item第一行文字的底部对齐</p></blockquote><blockquote><p>stretch：当item未设置高度时，item将和容器等高对齐</p></blockquote><h2 id="四、比值排序"><a href="#四、比值排序" class="headerlink" title="四、比值排序"></a>四、比值排序</h2><p>1、等比</p><pre><code class="highlight css"><span class="selector-class">.div1</span>{<span class="attribute">flex</span>:<span class="number">1</span>;}<span class="selector-class">.div2</span>{<span class="attribute">flex</span>:<span class="number">1</span>;}<span class="selector-class">.div3</span>{<span class="attribute">flex</span>:<span class="number">1</span>;}</code></pre><p>2、左固定，其余等比</p><pre><code class="highlight css"><span class="selector-class">.div1</span>{<span class="attribute">width</span>:<span class="number">20%</span>;}<span class="selector-class">.div2</span>{<span class="attribute">flex</span>:<span class="number">1</span>;}<span class="selector-class">.div3</span>{<span class="attribute">flex</span>:<span class="number">1</span>;}</code></pre><p>3、左右固定，其余等比</p><pre><code class="highlight css"><span class="selector-class">.div1</span>{<span class="attribute">width</span>:<span class="number">20%</span>;}<span class="selector-class">.div2</span>{<span class="attribute">flex</span>:<span class="number">1</span>;}<span class="selector-class">.div3</span>{<span class="attribute">width</span>:<span class="number">20%</span>;}</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS布局模型详细介绍</title>
      <link href="2020/07/08/HTML&amp;CSS/CSSLayoutModel/"/>
      <url>2020/07/08/HTML&amp;CSS/CSSLayoutModel/</url>
      
        <content type="html"><![CDATA[<p>HTML中元素有三种布局模型：流动模型、浮动模型、层模型。</p><h4 id="流动模型（flow）"><a href="#流动模型（flow）" class="headerlink" title="流动模型（flow）"></a>流动模型（flow）</h4><p>HTML网页默认布局就是流动模型，布局如下：</p><p><strong>块级元素(block)</strong>自上而下垂直分布，因为块级元素默认宽度为浏览器窗口的<strong>100%</strong>，或者理解为每个块级元素默认<strong>占一行</strong>。常见块级元素有 <code>div</code>, <code>p</code>, <code>h</code> 等；</p><p><strong>内联元素(inline)</strong>从左到右水平分布，即不像块级元素那样每个独占一行。常见内联元素有 <code>a</code>, <code>span</code>, <code>em</code> 等。</p><h4 id="浮动模型（float）"><a href="#浮动模型（float）" class="headerlink" title="浮动模型（float）"></a>浮动模型（float）</h4><p>上面提到的块级元素是每个独占一行显示，但是定义css浮动模型后就能使两个块级元素<strong>并排一行</strong>显示。例如HTML代码：</p><pre><code class="highlight html"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span> = <span class="string">"div1"</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span> = <span class="string">"div2"</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span>World !<span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></code></pre><p>显示结果是这样：</p><pre><code>HelloWorld !</code></pre><p>但是设置浮动css后：</p><pre><code class="highlight css"><span class="selector-tag">div</span> {<span class="attribute">float</span>: left;}</code></pre><p>效果就是这样：</p><pre><code>HelloWorld !</code></pre><p>也可以设置元素一左一右显示：</p><pre><code class="highlight css"><span class="selector-id">#div1</span> {<span class="attribute">float</span>: left;}<span class="selector-id">#div2</span> {<span class="attribute">float</span>: right;}</code></pre><h4 id="层模型（layer）（position）"><a href="#层模型（layer）（position）" class="headerlink" title="层模型（layer）（position）"></a>层模型（layer）（position）</h4><p>类似于PS中的<strong>图层</strong>编辑，HTML中也存在层模型布局，对元素进行<strong>定位</strong>。层模型有三种：<strong>绝对定位</strong>(absolute)、<strong>相对定位</strong>(relative)、<strong>固定定位</strong>(fixed)。</p><h5 id="绝对定位"><a href="#绝对定位" class="headerlink" title="绝对定位"></a>绝对定位</h5><p>理解就是字面上的意思，简言之就是<strong>相对于上级设置了 position 属性的元素</strong>进行定位，如果没有这类上级就是相对于 <code>body</code> 标签，也是<strong>浏览器窗口</strong>。需要设置css：<code>position: absolute;</code>，然后就可以使用 <code>top</code>, <code>right</code>, <code>bottom</code>, <code>left</code> 这类属性进行定位。例如：</p><pre><code class="highlight css"><span class="selector-tag">div</span> {<span class="attribute">position</span>: absolute;<span class="attribute">top</span>: <span class="number">100px</span>;<span class="attribute">left</span>: <span class="number">150px</span>;}</code></pre><p>这样就使板块<strong>向下</strong>移动100像素，<strong>向右</strong>移动150像素。</p><h5 id="相对定位"><a href="#相对定位" class="headerlink" title="相对定位"></a>相对定位</h5><p>这里的<strong>相对</strong>较难理解，与数理中的“相对”不太一样，这里是<strong>“相对于自己原来应在的位置”</strong>，需要设置css：<code>position:  relative;</code>，重要的是不用关心<strong>上级是否设置了position属性</strong>，这样就很方便。例如：</p><pre><code class="highlight css"><span class="selector-tag">div</span> {<span class="attribute">position</span>: relative;<span class="attribute">top</span>: <span class="number">100px</span>;<span class="attribute">right</span>: <span class="number">100px</span>;}</code></pre><p>板块就相对于自己没设置样式前的位置，同时向左向下移动100px。</p><h5 id="固定定位"><a href="#固定定位" class="headerlink" title="固定定位"></a>固定定位</h5><p>这个就好理解了，所谓<strong>固定</strong>就是指固定于整个浏览器网页窗口不动，即使滚动网页内容也不改变位置，需要设置css：<code>position: fixed</code>，也可以设置 <code>top</code>, <code>right</code>等调整固定的位置。还记得浏览器某些网页右下角的小广告吗，是不是固定在那怎么浏览网页都不动 -_- .</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS选择符的权重</title>
      <link href="2020/07/06/HTML&amp;CSS/CSSSelector/"/>
      <url>2020/07/06/HTML&amp;CSS/CSSSelector/</url>
      
        <content type="html"><![CDATA[<h2 id="CSS选择符的权重"><a href="#CSS选择符的权重" class="headerlink" title="CSS选择符的权重 "></a>CSS选择符的权重 <span id="home"></span></h2><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><strong><a href="#1">css选择符权重 </a></strong><ul><li><strong><a href="#1.1">css选择器权重列表 </a></strong></li><li><strong><a href="#1.2">CSS选择符冲突处理 </a></strong></li></ul></li></ul><hr><h2 id="css选择符权重"><a href="#css选择符权重" class="headerlink" title="css选择符权重 "></a><code>css</code>选择符权重 <span id="1"></span></h2><h4 id="css选择器权重列表"><a href="#css选择器权重列表" class="headerlink" title="css选择器权重列表 "></a><code>css</code>选择器权重列表 <span id="1.1"></span></h4><pre><code>选择器        权重内联样式        1000ID            0100CLASS        0010属性选择符    0010TAG            0001伪元素        0001伪类            0001inhref        0000群组选择符    不变后代选择符    相加</code></pre><h4 id="CSS选择符冲突处理"><a href="#CSS选择符冲突处理" class="headerlink" title="CSS选择符冲突处理 "></a><code>CSS</code>选择符冲突处理 <span id="1.2"></span></h4><p>1、权重不同：选择符的<code>css</code>发生冲突时，拥有高权值的<code>css</code>选择符将会显示</p><p>2、权重相同：选择符权重一样，将会按照加载顺序进行覆盖（就近原则）</p><p>3、<code>a</code>和<code>a:link</code>同时存在时，以<code>a:link</code>优先，注：使用<code>a</code>的伪类时，需要四个伪类(<code>a:link</code>、<code>a:hover</code>、<code>a:active</code>、<code>a:visited</code>)同时使用</p><p>4、<code>!important</code>的权重为正无穷</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue的响应式原理</title>
      <link href="2020/03/25/Vue/VueBottomImplementation/"/>
      <url>2020/03/25/Vue/VueBottomImplementation/</url>
      
        <content type="html"><![CDATA[<h1 id="Vue的响应式原理"><a href="#Vue的响应式原理" class="headerlink" title="Vue的响应式原理"></a>Vue的响应式原理</h1><h2 id="一、响应式的底层实现"><a href="#一、响应式的底层实现" class="headerlink" title="一、响应式的底层实现"></a>一、响应式的底层实现</h2><h3 id="1、Vue与MVVM"><a href="#1、Vue与MVVM" class="headerlink" title="1、Vue与MVVM"></a>1、Vue与MVVM</h3><p>Vue是一个 <code>MVVM框架</code>，其各层的对应关系如下</p><ul><li><p><code>View层</code>：在Vue中是绑定dom对象的HTML</p></li><li><p><code>ViewModel层</code>：在Vue中是实例的vm对象</p></li><li><p><code>Model层</code>：在Vue中是data、computed、methods等中的数据</p></li></ul><p>在 <code>Model</code> 层的数据变化时，<code>View</code>层会在ViewModel的作用下，实现自动更新</p><h3 id="2、Vue的响应式原理"><a href="#2、Vue的响应式原理" class="headerlink" title="2、Vue的响应式原理"></a>2、Vue的响应式原理</h3><p>Vue响应式底层实现方法是 <code>Object.defineProperty()</code> 方法，该方法中存在一个getter和setter的可选项，可以对属性值的获取和设置造成影响</p><p>Vue中编写了一个wather来处理数据</p><p>在使用getter方法时，总会通知wather实例对view层渲染页面</p><p>同样的，在使用setter方法时，总会在变更值的同时，通知wather实例对view层进行更新</p><h3 id="3、响应式原理与兼容"><a href="#3、响应式原理与兼容" class="headerlink" title="3、响应式原理与兼容"></a>3、响应式原理与兼容</h3><p>由于 <code>Object.defineProperty()</code> 方法只部分支持IE9，所以Vue兼容IE版本最低为IE9，在IE9中，Vue的核心框架、vue-router、vuex是确保可以正常使用的</p><h3 id="4、响应式原理示意图"><a href="#4、响应式原理示意图" class="headerlink" title="4、响应式原理示意图"></a>4、响应式原理示意图</h3><p>![Vue的响应式原理示意图](<a href="https://hn-failte.github.io/assets/posts/vue-bottom-implementation.png#pic_center" target="_blank" rel="noopener">https://hn-failte.github.io/assets/posts/vue-bottom-implementation.png#pic_center</a> =30x30)</p><h2 id="二、响应式数据"><a href="#二、响应式数据" class="headerlink" title="二、响应式数据"></a>二、响应式数据</h2><h3 id="1、在实例前声明"><a href="#1、在实例前声明" class="headerlink" title="1、在实例前声明"></a>1、在实例前声明</h3><pre><code class="highlight js"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue({    data: {        name: <span class="string">"failte"</span>    }})</code></pre><p>在实例前声明的属性会在实例时添加 <code>getter()</code>、<code>setter()</code> 方法，因此此时的name是响应式的，每当name变化时，会自动更新视图</p><h3 id="2、在实例后添加"><a href="#2、在实例后添加" class="headerlink" title="2、在实例后添加"></a>2、在实例后添加</h3><pre><code class="highlight js">vm.name = <span class="string">"failte"</span></code></pre><p>由于data中没有该属性，因此实例后，此时的name是非响应式的，name变化时，不会更新视图</p><p>若需要转换为响应式数据，需要使用 <code>Vue.set()</code> 方法手动添加为响应式属性</p><pre><code class="highlight js">Vue.set(vm.data, <span class="string">"name"</span>, <span class="string">"ajaccio"</span>)<span class="comment">//Vue.$set是该方法的别名</span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实现call、apply、bind</title>
      <link href="2020/02/17/JavaScript/JavaScriptCall%E3%80%81apply%E3%80%81bindPolyfill2/"/>
      <url>2020/02/17/JavaScript/JavaScriptCall%E3%80%81apply%E3%80%81bindPolyfill2/</url>
      
        <content type="html"><![CDATA[<h1 id="面试题：实现call、apply、bind"><a href="#面试题：实现call、apply、bind" class="headerlink" title="面试题：实现call、apply、bind"></a>面试题：实现call、apply、bind</h1><h2 id="实现call"><a href="#实现call" class="headerlink" title="实现call"></a>实现call</h2><pre><code class="highlight js"><span class="built_in">Function</span>.prototype.myCall = <span class="function"><span class="keyword">function</span>(<span class="params">context</span>)</span>{    <span class="comment">// 首先判断调用者是不是函数</span>    <span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="keyword">this</span> !== <span class="string">'function'</span>){      <span class="keyword">return</span> <span class="built_in">console</span>.log(<span class="string">'type error'</span>)    }    <span class="comment">// 处理传入参数</span>    <span class="keyword">var</span> args = [...arguments].slice(<span class="number">1</span>)    <span class="keyword">var</span> result = <span class="literal">null</span>    <span class="comment">// 判断是否有传入上下文,未传入则设为全局上下文</span>    context = context || <span class="built_in">window</span>    <span class="comment">// 将调用函数设为context的方法</span>    context.fn = <span class="keyword">this</span>    <span class="comment">// 调用</span>    result = context.fn(...args)    <span class="keyword">return</span> result;}</code></pre><p>apply实现方法类似，只需要更改传入参数的形式即可</p><h2 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h2><pre><code class="highlight js"><span class="built_in">Function</span>.prototype.myBind = <span class="function"><span class="keyword">function</span>(<span class="params">context</span>)</span>{  <span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="keyword">this</span> !== <span class="string">'function'</span>){      <span class="keyword">return</span> <span class="built_in">console</span>.log(<span class="string">'type error'</span>)    }  context = context || <span class="built_in">window</span>;  <span class="keyword">var</span> args = [...arguments].slice(<span class="number">1</span>)  <span class="comment">// 保存当前调用函数</span>  fn = <span class="keyword">this</span>;  <span class="comment">// 创建一个函数返回</span>  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">Fn</span>(<span class="params"></span>)</span>{    <span class="comment">// 根据不同的方式，传入不同的绑定值</span>    <span class="keyword">return</span> fn.apply(      <span class="keyword">this</span> <span class="keyword">instanceof</span> Fn ? <span class="keyword">this</span> : context,      args.concat(...arguments)    )  }}</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Polyfill </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
